{"prompt":"-- Remove any undesirable characters that might gum up the works\nlocal function removebadchars(token)\n\treturn string.gsub(token, \"[^a-zA-Z0-9_]\", \"\")\nen","completion":""}
{"prompt":"-- Integer addition mod c.\n-- Parameters\n-- ----------\n-- a,b : int\n-- Integers to be added\n-- c : int\n-- Integer to mod out by\n-- Returns\n-- -------\n-- s : a + b (mod c)\nlocal function add_mod_c(a, b, c)\n    local s = (a + b) % c\n    if s < 0 then\n        s = s + c\n    end\n    return s\nen","completion":""}
{"prompt":"-- Compute derivative of Tanh function\nlocal function derivative_tanh(tanh_output)\n  return 1 - tanh_output^2\nen","completion":""}
{"prompt":"-- Enclose code blocks in formatting tags. Default settings are consistent with\n-- markdown-styled code blocks for Python code.\n-- Args:\n-- txt: String to search for code blocks.\n-- keyword(optional, string): String that a code block must start with.\n-- split(optional, string): String that a code block must end with.\n-- tag(optional, string): String to enclose code block with.\n-- lang(optional, string) : String that determines what programming\n-- language is used in all code blocks. Set this to '' to disable\n-- syntax highlighting in markdown.\n-- Returns:\n-- string: A copy of the input with code formatting tags inserted (if any\n-- code blocks were found).\nlocal function mark_code_blocks(txt, keyword, split, tag, lang)\n    keyword = keyword or '```'\n    split = split or keyword\n    tag = tag or '<code class=\"language-python\">'\n    lang = lang or 'python'\n    return string.gsub(txt, split .. string.rep(string.rep('%.', #keyword), 4) .. '([^\\n]*)\\n' .. keyword, tag .. '%1<\/code>\\n')\nen","completion":""}
{"prompt":"-- Return the height corresponding to ``new_width`` that's proportional\n-- to the original size (``width`` x ``height``).\nlocal function choose_height(new_width, width, height)\n    return math.floor(height * (new_width \/ width))\nen","completion":""}
{"prompt":"-- (Point, Point) -> Point\n-- Return the point that lies in between the two input points.\nlocal function _mid(pt1, pt2)\n\treturn { pt1[1] + (pt2[1] - pt1[1]) \/ 2, pt1[2] + (pt2[2] - pt1[2]) \/ 2 }\nen","completion":""}
{"prompt":"-- Return the number of leftover candies that must be smashed after distributing\n-- the given number of candies evenly between 3 friends.\n-- >>> to_smash(91)\n-- 1\nlocal function to_smash(total_candies)\n  local num_candies = math.floor(total_candies \/ 3)\n  return total_candies - (3 * num_candies)\nen","completion":""}
{"prompt":"-- Given two bearings, returns the angle between them\nlocal function get_bearing_difference(bearing1, bearing2)\n\treturn (bearing1 - bearing2 + 540) % 360 - 180\nen","completion":""}
{"prompt":"-- Gets list of unique target names and return dictionary\nlocal function get_unique_value_from_summary_ext(test_summary, index_key, index_val)\n    -- print(test_summary)\n    local ret_table = {}\n    for i, v in ipairs(test_summary) do\n        -- print(v)\n        ret_table[v[index_key]] = v[index_val]\n    end\n    -- print(ret_table)\n    return ret_table\nen","completion":""}
{"prompt":"-- Return the Babel locale code, given a normal one.\nlocal function _babel_locale(locale)\n  return string.gsub(locale, \"-\", \"_\")\nen","completion":""}
{"prompt":"-- General wrapper around objective function evaluations to get the score.\n-- :param value: output of the objective function\n-- :returns: the score\n-- If value is a scalar, it is returned immediately. If value is iterable, its first element is returned.\nlocal function score(value)\n    if type(value) == 'number' then\n        return value\n    else\n        local v = value[1]\n        return (v == nil and 0) or v\n    end\nen","completion":""}
{"prompt":"-- Clauset et al 2007 equation 3.2:\n-- sigma = (alpha-1)\/sqrt(n)\nlocal function sigma(alpha, n)\n    local sigma = (alpha - 1) \/ math.sqrt(n)\n    return sigma\nen","completion":""}
{"prompt":"-- Convert integer color to (r,g,b)\nlocal function integer_color_to_rgb(color)\n  return { math.floor(color \/ 65536) % 256, math.floor(color \/ 256) % 256, color % 256 }\nen","completion":""}
{"prompt":"-- Given a positive floating point number, it can be decomposed into\n-- and integer part (largest integer smaller than given number) and decimals\n-- (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n-- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n  return number - math.floor(number)\nen","completion":""}
{"prompt":"-- :param x: Dispersion\n-- :type x: np.ndarray\n-- :param amp: Amplitude of the power law\n-- :type amp: float\n-- :param slope: Slope of the power law\n-- :type slope: float\n-- :return: Power law model\n-- :rtype: np.ndarray\nlocal function power_law(x, amp, slope)\n    return amp * x ^ slope\nen","completion":""}
{"prompt":"-- Resolve a realtive path or shot tree URI to a full path.\n-- :rtype: str\n-- :return: the full path\nlocal function resolve(path)\n\tlocal path = string.gsub(path, \"%.shot$\", \"\")\n\treturn path\nen","completion":""}
{"prompt":"-- Calculate the n2o concentration average between the historical n2o and\n-- current n2o concentrations\n-- Parameters\n-- ----------\n-- n_0 : float\n-- Historical n2o concentration, in ppm\n-- n_curr : float\n-- Current n2o concentration, in ppm\n-- Return\n-- ------\n-- n_bar : float\n-- Averaged concentration, in W m^-2 ppb^-1\nlocal function calc_nbar(n_0, n_curr)\n    local n_bar = 0.5 * (n_0 + n_curr)\n    return n_bar\nen","completion":""}
{"prompt":"-- Returns the number of digits in the number, assuming base 10\nlocal function get_number_of_digits(num)\n    local count = 0\n    while num > 0 do\n        num = math.floor(num \/ 10)\n        count = count + 1\n    end\n    return count\nen","completion":""}
{"prompt":"-- Extract the immediate child nodes of a tree root\n-- Inputs:\n-- tree: a plan decomposition tree\n-- Outputs:\n-- children: the immediate child nodes of root (with their own subtrees omitted)\nlocal function extract_children(tree)\n   local children = {}\n   for _, v in ipairs(tree) do\n      if type(v) == 'table' then\n         table.insert(children, v)\n      end\n   end\n   return children\nen","completion":""}
{"prompt":"-- Provide an organization payload for adding a member.\nlocal function org_add_payload(org_default_payload)\n  return setmetatable(org_default_payload, {\n    __index = {\n      role = \"member\",\n    },\n  })\nen","completion":""}
{"prompt":"-- argparse returns and string althout webcam uses int (0, 1 ...)\n-- Cast to int if needed\nlocal function str2int(video_path)\n  local video_path_int = tonumber(video_path)\n  if video_path_int then\n    video_path = video_path_int\n  end\n  return video_path\nen","completion":""}
{"prompt":"-- wrapper for the heuristics to avoid recomputing when already called for a specific state. The heuristics are stored in dic\nlocal function getHeuristic(state, problem, heuristic, dic)\n    if dic[state] ~= nil then\n        return dic[state]\n    end\n    if heuristic == \"h1\" then\n        return getHeuristicH1(state, problem)\n    elseif heuristic == \"h2\" then\n        return getHeuristicH2(state, problem)\n    elseif heuristic == \"h3\" then\n        return getHeuristicH3(state, problem)\n    elseif heuristic == \"h4\" then\n        return getHeuristicH4(state, problem)\n    elseif heuristic == \"h5\" then\n        return getHeuristicH5(state, problem)\n    elseif heuristic == \"h6\" then\n        return getHeuristicH6(state, problem)\n    end\n    return -1\nen","completion":""}
{"prompt":"-- Returns the first line of a multi-line string\nlocal function first_line(s)\n   return string.match(s, \"^([^\\r\\n]*)\")\nen","completion":""}
{"prompt":"-- Restricts a number to a certain range of values,\n-- returning the min or max value if the value is too small or large, respectively\n-- :param n: The value to clamp\n-- :param min_value: The minimum possible value\n-- :param max_value: The maximum possible value\n-- :return: The clamped value\nlocal function clamp(n, min_value, max_value)\n    return math.min(math.max(n, min_value), max_value)\nen","completion":""}
{"prompt":"-- Converts RGB data to `viewable values <https:\/\/en.wikipedia.org\/wiki\/Gamma_correction>`_.\nlocal function gamma_encode(x)\n   return x^(1\/2.2)\nen","completion":""}
{"prompt":"-- Array index for given (ell,mp,m) mode\n-- Assuming an array (e.g., Wigner D matrices) in the order\n-- [[ell,mp,m] for ell in range(ell_min, ell_max+1)\n-- for mp in range(-ell,ell+1)\n-- for m in range(-ell,ell+1)]\n-- this function returns the index of the (ell,mp,m) element.  (Note that\n-- ell_max doesn't actually come into this calculation, so it is not taken\n-- as an argument to the function.)\n-- This can be calculated in sympy as\n-- from sympy import symbols, summation\n-- ell,mp,m,ell_min, = symbols('ell,mp,m,ell_min,', integer=True)\n-- summation((2*ell + 1)**2, (ell, ell_min, ell-1)) + (2*ell+1)*(ell+mp) + (ell+m)\nlocal function LMpM_index(ell, mp, m, ell_min)\n   local total = 0\n   for i=ell_min,ell-1 do\n      total = total + (2*i+1)^2\n   end\n   return total + (2*ell+1)*(ell+mp) + (ell+m)\nen","completion":""}
{"prompt":"-- Return version in dotted string format.\nlocal function _version_format(version)\n    return table.concat(version, \".\")\nen","completion":""}
{"prompt":"-- Checks that `delay` is a positive float number else raises a\n-- ValueError.\nlocal function _safe_delay(delay)\n\tlocal delay = tonumber(delay)\n\tif not delay or delay < 0 then\n\t\tlocal msg = string.format(\n\t\t\t\"invalid delay argument: '%s'\", tostring(delay))\n\t\terror(msg, 2)\n\tend\n\treturn delay\nen","completion":""}
{"prompt":"-- :param fom: Fixed operation and maintentance costs as CURR\/KWY\n-- :param vom: Variable cost in the form of CURR\/ KWH\n-- :param cf: Capacity factor assumed for the plant, default is 1\n-- :return: LCOE O&M component in CURR per KWh\nlocal function calc_lcoe_om(fom, vom, cf)\n\t-- default is 1 for cf\n\tif cf == nil then cf = 1 end\n\t\n\t-- fom and vom need to be in CURR\/KW\n\tlocal fom_kw = tonumber(fom) \/ 1000\n\tlocal vom_kw = tonumber(vom) \/ 1000\n\t\n\t-- calculate lcoe\n\tlocal lcoe = cf * (fom_kw + vom_kw)\n\t\n\t-- print(\"LCOE O&M: \" .. lcoe)\n\t\n\t-- convert to CURR\/KWH\n\treturn lcoe * 1000\nen","completion":""}
{"prompt":"-- Bitwise MAJ function\nlocal function np_bitwise_maj(x, y, z)\n  return bit32.bor(\n    bit32.bor(bit32.band(x, y), bit32.band(x, z)),\n    bit32.band(y, z)\n  )\nen","completion":""}
{"prompt":"-- Filters out objects in `patterns` that do not match with `string`.\n-- args:\n-- string: a str to match against `patterns`\n-- patterns: an iterable of objects implementing a `match` method\n-- returns:\n-- a list of objects in `patterns` that match `string`\nlocal function matches(string, patterns)\n  local matches = {}\n  for _, pattern in pairs(patterns) do\n    if pattern:match(string) then\n      matches[#matches+1] = pattern\n    end\n  end\n  return matches\nen","completion":""}
{"prompt":"-- Keep dividing(a\/b) till it's divisible(a % b == 0)\n-- e.g.\n-- Input: a = 300; b = 2\n-- Output: 75\n-- :param a:\n-- :param b:\n-- :return:\nlocal function max_divisible(a, b)\n    while a % b == 0 do\n        a = a \/ b\n    end\n    return a\nen","completion":""}
{"prompt":"-- Sanitizes a string for a postgres COPY insert\n-- :param string: a string\n-- :return: the sanitized string\nlocal function postgres_sanitize_str(string)\n  return string:gsub('\\\\', '\\\\\\\\'):gsub('\\n', '\\\\\\n')\nen","completion":""}
{"prompt":"-- `84, 3` --> `084`\n-- `321, 1` --> `321`\n-- `hello, 3` --> `hello`\n-- :param value:\n-- :param min_length:\n-- :return:\nlocal function convert_to_string_with_leading_zeroes(value, min_length)\n  if value then\n    local s = tostring(value)\n    if min_length then\n      local n = string.len(s)\n      if n < min_length then\n        s = ('0'):rep(min_length - n) .. s\n      end\n    end\n    return s\n  end\n  return nil\nen","completion":""}
{"prompt":"-- The function action_build builds the image\n-- Arguments:\n-- image_name: Name of the image file.\n-- image_tag: Tag of the build image file.\n-- dockerfile_name: This is the Dockerfile to be used for building the image.\n-- docker_path: working directory of docker.\nlocal function action_build(image_name, image_tag, dockerfile_name, docker_path)\n  if not os.execute(\"docker build --tag=\" .. image_name .. \":\" .. image_tag .. \" -f \" .. dockerfile_name .. \" \" .. docker_path) then\n    print(\"Error: failed to build the image\")\n    os.exit()\n  end\nen","completion":""}
{"prompt":"-- Check if argument is a 1 character string containing + or - or !\nlocal function tochr(arg)\n  if arg == \"+\" or arg == \"-\" or arg == \"!\" then\n    return arg\n  else\n    return nil\n  end\nen","completion":""}
{"prompt":"-- Convert the given path to an absolute path.\n-- Since FS objects have no concept of a 'current directory' this simply\n-- adds a leading '\/' character if the path doesn't already have one.\nlocal function abspath(path)\n    if path:sub(1,1) ~= '\/' then\n        path = '\/' .. path\n    end\n    return path\nen","completion":""}
{"prompt":"-- Return the 1D index which corresponds to 2D position (x, y).\n-- Examples:\n-- If we have a 2D grid like this:\n-- 0 1 2\n-- 3 4 5\n-- 6 7 8\n-- We can assert that element 8 is of the coordinate (2, 2):\n-- >>> 8 == coord_to_index(3, 2, 2)\n-- True\nlocal function coord_to_index(width, x, y)\n  return x + width * y\nen","completion":""}
{"prompt":"-- Create a dictionary from the value of an inline style attribute\nlocal function parseStyle(s)\n\tlocal t = {}\n\tif s then\n\t\tfor c in s:gmatch('[^;]+') do\n\t\t\tlocal k, v = c:match('([^:]+):(.+)')\n\t\t\tif k and v then\n\t\t\t\tk = k:match('^%s*(.-)%s*$')\n\t\t\t\tv = v:match('^%s*(.-)%s*$')\n\t\t\t\tt[k] = v\n\t\t\tend\n\t\tend\n\tend\n\treturn t\nen","completion":""}
{"prompt":"-- Profile used for gradually translating a branch to be clamped.\n-- Currently using a linear profile, ranging from 0 to 1.\n-- Args:\n-- centerline_id (int): ID at current centerline point\n-- number_of_points (int): Number of centerline points\n-- Returns:\n-- float: Clamp factor, ranging from 0 to 1\nlocal function clamp_profile(centerline_id, number_of_points)\n\treturn math.abs((number_of_points - centerline_id) \/ number_of_points)\nen","completion":""}
{"prompt":"-- Returns the y-label for the plot given the type of plot.\n-- Parameters\n-- ----------\n-- to_plot : string\n-- Type of thing to plot. Can be 'pmf', 'cdf', 'fid', or 'wern'.\n-- Returns\n-- -------\n-- string\n-- The y-label for the plot.\nlocal function _ylab(to_plot)\n\tif to_plot == 'pmf' then\n\t\treturn 'Probability'\n\telseif to_plot == 'cdf' then\n\t\treturn 'Cumulative Probability'\n\telseif to_plot == 'fid' then\n\t\treturn 'Fidelity'\n\telseif to_plot == 'wern' then\n\t\treturn 'Wernicke Index'\n\telse\n\t\tprint('Error: Unknown to_plot type: ', to_plot)\n\t\tos.exit()\n\tend\nen","completion":""}
{"prompt":"-- Takes a list of :class:`HostedMediaFile`s representing web pages that are\n-- thought to be associated with media content. If no resolver plugins exist\n-- to resolve a :class:`HostedMediaFile` to a link to a media file it is\n-- removed from the list.\n-- Args:\n-- source_list (list of :class:`HostedMediaFile`): A list of\n-- :class:`HostedMediaFiles` representing web pages that are thought to be\n-- associated with media content.\n-- Returns:\n-- The same list of :class:`HostedMediaFile` but with any that can't be\n-- resolved by a resolver plugin removed.\nlocal function filter_source_list(source_list)\n  local valid_sources = {}\n  for _, source in ipairs(source_list) do\n    local result = resolve_source(source)\n    if result then\n      table.insert(valid_sources, result)\n    end\n  end\n  return valid_sources\nen","completion":""}
{"prompt":"-- Converts '1.2.3' into '00001.00002.00003'\nlocal function sortable_version(version)\n    local t = {}\n    for s in string.gmatch(version, \"[^.]+\") do\n        t[#t+1] = string.format(\"%05d\", s)\n    end\n    return table.concat(t, \".\")\nen","completion":""}
{"prompt":"-- Return quaduple (4 tuple) result of quaternion multiplation of q1 * q2\n-- Quaternion multiplication is not commutative  q1 * q2 != q2 * q1\n-- Quaternions q1 and q2 are sequences are of the form [w, x, y, z]\nlocal function qconj(q)\n  return {q[1], -q[2], -q[3], -q[4]}\nen","completion":""}
{"prompt":"-- Remove special characters in column names\nlocal function easy_name(s)\n\treturn string.gsub(string.gsub(s, '[^%w]', '_'), '_+$', '')\nen","completion":""}
{"prompt":"-- Change AMQP class name to Python class name\nlocal function name_class(classname)\n\tlocal str = string.upper(classname:sub(1, 1))..classname:sub(2, #classname)\n\treturn str:gsub(\"amqp_\", \"\")\nen","completion":""}
{"prompt":"-- Pad vocab size so it is divisible by model parallel size and\n-- still having GPU friendly size.\nlocal function vocab_size_with_padding(vocab_size, make_vocab_size_divisible_by, world_size)\n  local vocab_size_per_partition = math.ceil(vocab_size \/ world_size)\n  local padding_size = vocab_size_per_partition % make_vocab_size_divisible_by\n  if padding_size ~= 0 then\n    vocab_size_per_partition = vocab_size_per_partition + make_vocab_size_divisible_by - padding_size\n  end\n  return vocab_size_per_partition * world_size\nen","completion":""}
{"prompt":"-- If a name has exactly 4 letters in it, you can be sure that it has to be a friend of yours! Otherwise, you can\n-- be sure he's not...\n-- :param x: an array of strings.\n-- :return: an array of strings of length 4.\nlocal function friend(x)\n    local new_table = {}\n    for k,v in ipairs(x) do\n        if string.len(v) == 4 then\n            new_table[#new_table+1] = v\n        end\n    end\n    return new_table\nen","completion":""}
{"prompt":"-- Handles the formula used for y=mx+b format to find slope\nlocal function slope_intercept_form(m, x, b)\n    return (m * x) + b\nen","completion":""}
{"prompt":"-- Returns reflected angle of `a` in x-direction in degrees.\n-- Angles are counter clockwise orientated and +x-axis is at 0 degrees.\n-- Args:\n-- a: angle to reflect in degrees\nlocal function reflect_angle_x_deg(a)\n    local a = a % 360\n    local new_a = 180 - a\n    if new_a < 0 then\n        new_a = new_a + 360\n    end\n    return new_a\nen","completion":""}
{"prompt":"-- Takes a number and returns a string putting a zero in front if it's \n-- single digit.\nlocal function stringify(num)\n  if (tostring(num):len() == 1) then\n    return \"0\" .. tostring(num)\n  end\n  return tostring(num)\nen","completion":""}
{"prompt":"-- decodes a prediction {0, 1, 2, 3} into the corresponding output\nlocal function fizz_buzz_decode(i, prediction)\n  if prediction == 0 then\n    return string.format('%d', i)\n  elseif prediction == 1 then\n    return 'fizz'\n  elseif prediction == 2 then\n    return 'buzz'\n  elseif prediction == 3 then\n    return 'fizzbuzz'\n  else\n    return '?'\n  end\nen","completion":""}
{"prompt":"-- Convert a positive integer into its ordinal representation\nlocal function ordinal(n)\n  if n % 100 == 11 or n % 100 == 12 or n % 100 == 13 then\n    return n .. \"th\"\n  else\n    local last_digit = n % 10\n    if last_digit == 1 then\n      return n .. \"st\"\n    elseif last_digit == 2 then\n      return n .. \"nd\"\n    elseif last_digit == 3 then\n      return n .. \"rd\"\n    else\n      return n .. \"th\"\n    end\n  end\nen","completion":""}
{"prompt":"-- returns \"s\" if val > 1 or \"\" otherwise.\n-- Can be used in strings to have proper plural form.\nlocal function plural_s(val)\n    if val > 1 then\n        return \"s\"\n    else\n        return \"\"\n    end\nen","completion":""}
{"prompt":"-- Calculates linear interpolation.\n-- Parameters\n-- ----------\n-- v1: :class:`float`\n-- The start value.\n-- v2: :class:`float`\n-- The end value.\n-- p: :class:`float`\n-- The point along the line in the range ``[0, 1]``.\n-- Returns\n-- -------\n-- :class:`float`\n-- The interpolated value.\nlocal function interpolate(v1, v2, p)\n    return (v2 - v1) * p + v1\nen","completion":""}
{"prompt":"-- Comprueba que el valor ingresado sea numerico\n-- Si el valor ingresado no es numerico muestra un mensaje de error y vuelve a pedir el valor\n-- Parametros\n-- ----------\n-- numero : valor que sera comprobado\nlocal function comprobar(numero)\n    local ok, _ = pcall(tonumber, numero)\n    if not ok then\n        print(\"ERROR: El valor ingresado no es un numero\")\n        return pedirNumer()\n    end\n    return numero\nen","completion":""}
{"prompt":"-- Convert a number to a string of raindrop sounds.\n-- param: int number\n-- return: str formatted string based on input\nlocal function convert(number)\n\tlocal raindrops = \"\"\n\tif number == 0 then return \"0\" end\n\tif number % 3 == 0 then raindrops = \"Pling\" end\n\tif number % 5 == 0 then raindrops = raindrops .. \"Plang\" end\n\tif number % 7 == 0 then raindrops = raindrops .. \"Plong\" end\n\tif raindrops == \"\" then raindrops = tostring(number) end\n\treturn raindrops\nen","completion":""}
{"prompt":"-- Given a GeoNames place URI, returns the GeoNames place Id\nlocal function get_geonames_id(geonames_uri)\n  return string.match(geonames_uri, \"([0-9]+)\")\nen","completion":""}
{"prompt":"-- Turn the data into int if possible, then a float, else a unicode\nlocal function fix_data_type(data)\n  local num = tonumber(data)\n  if num then\n    if num % 1 == 0 then\n      data = num\n    else\n      data = num + 0.0\n    end\n  else\n    data = tostring(data)\n  end\n  return data\nen","completion":""}
{"prompt":"-- Split sourceparams string of the form key1=val1[,key2=val2,...]\n-- into a dict.  Also accepts valueless keys i.e. without =.\n-- Returns dict of param key\/val pairs (note that val may be None).\nlocal function parse_sourceparams(sourceparams)\n    local dict = {}\n    if sourceparams == nil then return dict end\n    for kv in sourceparams:gmatch(\"[^,]+\") do\n        local key, val = kv:match(\"^([^=]*)=(.*)$\")\n        if key == nil then\n            key, val = kv, nil\n        end\n        dict[key] = val\n    end\n    return dict\nen","completion":""}
{"prompt":"-- Converts a string of length 1 (char) to an int.\nlocal function convertCharToInt(value)\n  return string.byte(value) - string.byte(\"0\")\nen","completion":""}
{"prompt":"-- Handles typing of data\n-- :param value: value to cast\n-- :type value: *\n-- :raises ValueError: cannot cast data\n-- :return: data with the right type\n-- :rtype: *\nlocal function typed(value)\n  if type(value) == \"string\" then\n    if value == \"true\" then\n      return true\n    elseif value == \"false\" then\n      return false\n    elseif value == \"nil\" then\n      return nil\n    end\n    local num = tonumber(value)\n    if num ~= nil then\n      return num\n    end\n  end\n  return value\nen","completion":""}
{"prompt":"-- Get a tringle area.\n-- Args:\n-- a: an edge length.\n-- b: an edge length.\n-- c: an edge length.\n-- Returns:\n-- the area of the tringle.\nlocal function GetTringleArea(a, b, c)\n    local p = (a + b + c) \/ 2\n    return math.sqrt(p * (p - a) * (p - b) * (p - c))\nen","completion":""}
{"prompt":"-- Validate encoding name.\nlocal function validate_encoding(encoding_name)\n  -- TODO: Validate encoding name.\n  return encoding_name\nen","completion":""}
{"prompt":"-- Trees or tuples, final leaves have None as values.\nlocal function make_tree(depth)\n  if depth == 0 then\n    return {}\n  end\n  return {\n    make_tree(depth - 1),\n    make_tree(depth - 1)\n  }\nen","completion":""}
{"prompt":"-- Converts time in tenths of seconds to formatted string A:BC.D\nlocal function format(time)\n  local minutes = math.floor(time \/ 600)\n  time = time - minutes * 600\n  local seconds = math.floor(time \/ 10)\n  time = time - seconds * 10\n  return string.format(\"%d:%02d.%d\", minutes, seconds, time)\nen","completion":""}
{"prompt":"-- format and return given verification record into dictionary\nlocal function format_verification_record(verification_record)\n  local record_table = {}\n  for k, v in pairs(verification_record) do\n    record_table[k] = v\n  end\n  return record_table\nen","completion":""}
{"prompt":"-- Normalize FQDN.\n-- >>> normalize('this.is.a.test....')\n-- 'this.is.a.test'\n-- >>> normalize('this...is..a.test..')\n-- 'this...is..a.test'\n-- >>> normalize('this..is.a.test')\n-- 'this..is.a.test'\n-- >>> normalize('this.is.a.test')\n-- 'this.is.a.test'\nlocal function normalize(name)\n  return name:gsub(\"[%.%-]+$\", \"\")\nen","completion":""}
{"prompt":"-- a*x**2 + b*x + c\nlocal function quad_func(x, a, b, c)\n    return a * x * x + b * x + c\nen","completion":""}
{"prompt":"-- checks if the filename is correct and adapts it if necessary\n-- Parameters:\n-- filename     - media filename\n-- return:\n-- string: updated filename\nlocal function check_filename(filename)\n    filename = string.gsub(filename, '%.m3u8', '')\n    filename = string.gsub(filename, '%.m3u', '')\n    return filename\nen","completion":""}
{"prompt":"-- Get a list of color blind friednly colors to cycle in plots\n-- Notes\n-- -----\n-- - Credit @ thriveth: https:\/\/gist.github.com\/thriveth\/8560036\nlocal function get_CB_color_cycle()\n  return {\n    \"#377eb8\",\n    \"#ff7f00\",\n    \"#4daf4a\",\n    \"#f781bf\",\n    \"#a65628\",\n    \"#984ea3\",\n    \"#999999\",\n    \"#e41a1c\",\n    \"#dede00\",\n  }\nen","completion":""}
{"prompt":"-- Compute max(1, ceil(log(number, base))).\n-- Use only integer arithmetic in order to avoid numerical error.\nlocal function ceil_log(number, base)\n    if number <= 0 or base <= 0 then\n        return 0\n    end\n    return math.max(1, math.ceil(math.log(number) \/ math.log(base)))\nen","completion":""}
{"prompt":"-- Returns 1 if the percent of masked pixels\n-- (pre-calculated) is less than or equal to a\n-- defined threshold value indicating a clear day,\n-- else returns 0.\n-- Parameters\n-- ----------\n-- percent_cloudy : int or float\n-- Percent of an image that is masked (cloudy).\n-- cloudy_threshold :\n-- Threshold value that determines if an image\n-- represents a clear day (<= threshold value)\n-- or cloudy image (> threshold value).\n-- Returns\n-- -------\n-- clear : boolean\n-- Boolean indicating clear (1) or cloudy (0) image.\n-- Example\n-- -------\n-- >>> # Get image status, clear or cloudy\n-- >>> image_status = clear_day(image.percent_masked, 50)\n-- >>> Show clear or cloudy\n-- >>> image status\n-- 1\nlocal function clear_day(percent_cloudy, cloudy_threshold)\n   return percent_cloudy <= cloudy_threshold and 1 or 0\nen","completion":""}
{"prompt":"-- If it is \"None\", return an empty iterator; otherwise, return iterator.\n-- The purpose of this function is to make iterating over results from\n-- functions which return either an iterator or None cleaner.\n-- Parameters\n-- ----------\n-- it: None or some object\n-- Returns\n-- -------\n-- empty_iterator: list of size 0\n-- If iterator is None\n-- --- OR ---\n-- iterator:\n-- The original iterator, if it was not None\nlocal function replace_none_with_empty_iter(iterator)\n    if iterator == nil then\n        return {}\n    else\n        return iterator\n    end\nen","completion":""}
{"prompt":"-- This operation takes an index into the three-value discrete space (constant, increase, decrease) and\n-- converts that into a continuous camera value.\n-- This is done quite simply, by returning `camera_angle` for an index of 1, and -1*camera_angle\n-- for an index of 2\nlocal function _get_delta(index, camera_angle)\n  if index == 1 then\n    return camera_angle\n  elseif index == 2 then\n    return -1*camera_angle\n  else\n    return 0.0\n  end\nen","completion":""}
{"prompt":"-- Find either the perimeter of a rectangle or the area of a square.\n-- :param l: an integer value.\n-- :param w: an integer value.\n-- :return: If it is a square, return its area. If it is a rectangle, return its perimeter\nlocal function area_or_perimeter(l, w)\n    if w == l then\n        return l * w\n    else\n        return 2 * (l + w)\n    end\nen","completion":""}
{"prompt":"-- param fill_val:\n-- param axis_val:\n-- param dims:\n-- param axis:\n-- return:\nlocal function slice_a(fill_val, axis_val, dims, axis)\n    local slice_a = {}\n    for i = 1, dims do\n        if i == axis + 1 then\n            slice_a[#slice_a + 1] = axis_val\n        else\n            slice_a[#slice_a + 1] = fill_val\n        end\n    end\n    return slice_a\nen","completion":""}
{"prompt":"-- Parse Supervisor message headers.\nlocal function get_headers(line)\n  local headers = {}\n  for k, v in line:gmatch(\"(%w+):%s*([%w%p ]*)\") do\n    headers[k] = v\n  end\n  return headers\nen","completion":""}
{"prompt":"-- An imperative implementation using a loop and in-place mutation.\nlocal function loop_add(x, y)\n    local c = x\n    for i = 1, y do\n        c = c + 1\n    end\n    return c\nen","completion":""}
{"prompt":"-- Returns bayer coupling matrix for predefined\nlocal function bayerCouplingMatrix(camera_label)\n  if camera_label == \"BayerGBRG\" then\n    return torch.Tensor{1, 1,\n                         1, 1\/2,\n                         1\/2, 1\/4,\n                         1\/2, 1\/8}\n  elseif camera_label == \"BayerRGGB\" then\n    return torch.Tensor{1\/2, 1\/4,\n                         1\/2, 1\/8,\n                         1, 1,\n                         1, 1\/2}\n  elseif camera_label == \"BayerGRBG\" then\n    return torch.Tensor{1\/2, 1\/8,\n                         1\/2, 1\/4,\n                         1, 1\/2,\n                         1, 1}\n  elseif camera_label == \"BayerGBRG\" then\n    return torch.Tensor{1, 1\/2,\n                         1, 1\/4,\n                         1\/2, 1\/8,\n                         1\/2, 1}\n  elseif camera_label == \"BayerBGGR\" then\n    return torch.Tensor{1\/4, 1\/8,\n                         1\/4, 1\/2,\n                         1, 1\/2,\n                         1, 1}\n  elseif camera_label == \"BayerRGGB\" then\n    return torch.Tensor{1\/8, 1\/2,\n                         1\/8, 1\/4,\n                         1, 1\/2,\n                         1, 1}\n  elseif camera_label == \"BayerGRBG\" then\n    return torch.Tensor{1\/8, 1\/4,\n                         1\/8, 1\/2,\n                         1, 1,\n                         1, 1\/2}\n  else\n    print(\"Wrong bayer pattern:\", camera_label)\n    os.exit()\n  end\nen","completion":""}
{"prompt":"-- [summary]\n-- Args:\n-- number (int): [positive number]\n-- Returns:\n-- bool: [Return True If The Number Is Odd And False If The Number Is Even]\nlocal function odd_check(number)\n\t-- body\n\tif (number % 2 == 0) then\n\t\treturn false\n\telse\n\t\treturn true\n\tend\nen","completion":""}
{"prompt":"-- Adds an 's' to `word`.\n-- Note:\n-- This is a simple function that only adds an 's'.  No attempt is made to follow proper\n-- pluralization rules.\n-- Args:\n-- word (str): A string.\n-- Returns:\n-- str: A string with 's' added to it.\nlocal function makePlural(word)\n    return word .. \"s\"\nen","completion":""}
{"prompt":"-- Return the index of the least significant bit in the mask\nlocal function _mask_to_shift(mask)\n\tlocal i = 0\n\twhile mask % 2 == 0 do\n\t\tmask = mask \/ 2\n\t\ti = i + 1\n\tend\n\treturn i\nen","completion":""}
{"prompt":"-- Extract one row from the client result, and return result as dict\nlocal function extract_row(key, clientresult)\n  local row = {}\n  for fieldname, value in pairs(clientresult[key]) do\n    row[fieldname] = value\n  end\n  return row\nen","completion":""}
{"prompt":"-- For a given vertex, find all faces containing this vertex.\n-- Note: faces do not have to be triangles.\n-- Parameters\n-- ----------\n-- index : integer\n-- index to a vertex\n-- faces : list of lists of three integers\n-- the integers for each face are indices to vertices, starting from zero\n-- Returns\n-- -------\n-- faces_with_vertex : list of lists of three integers\n-- the integers for each face are indices to vertices, starting from zero\n-- Examples\n-- --------\n-- >>> # Simple example:\n-- >>> from mindboggle.guts.mesh import find_faces_with_vertex\n-- >>> faces = [[0,1,2],[0,2,3],[0,3,4],[0,1,4],[4,3,1]]\n-- >>> index = 3\n-- >>> find_faces_with_vertex(index, faces)\n-- [[0, 2, 3], [0, 3, 4], [4, 3, 1]]\nlocal function find_faces_with_vertex(index, faces)\n   local faces_with_vertex = {}\n   for _, face in ipairs(faces) do\n      for _, v in ipairs(face) do\n         if v == index then\n            table.insert(faces_with_vertex, face)\n            break\n         end\n      end\n   end\n   return faces_with_vertex\nen","completion":""}
{"prompt":"-- Get GCP project id from service_account_email\n-- >>> get_project_id_from_service_account_email('cromwell-test@tob-wgs.iam.gserviceaccount.com')\n-- 'tob-wgs'\nlocal function get_project_id_from_service_account_email(service_account_email)\n  return service_account_email:match('@(.+)%.iam%.gserviceaccount%.com')\nen","completion":""}
{"prompt":"-- Return a 2D shape \n-- Args:\n-- in_val (int or list with length 2)\n-- Returns:\n-- list with length 2\nlocal function get_shape2D(in_val)\n\tif type(in_val) == \"number\" then\n\t\treturn { in_val, in_val }\n\tend\n\treturn in_val\nen","completion":""}
{"prompt":"-- Convert a uid with underscores to the original format\nlocal function reform_uid(uid)\n\tif not uid then return nil end\n\tlocal s = uid:gsub(\"%_+\", \"\/\")\n\ts = s:gsub(\"^\/\", \"\")\n\ts = s:gsub(\"\/$\", \"\")\n\treturn s\nen","completion":""}
{"prompt":"-- Returns the ceiling of a \/ b, equivalent to math.ceil(a \/ b)\nlocal function ceildiv(a, b)\n\treturn math.ceil(a \/ b)\nen","completion":""}
{"prompt":"-- Accepts an integer in [lower, upper].\nlocal function bounded_integer(lower, upper)\n    return function(arg)\n        local num = tonumber(arg)\n        if not num then\n            return nil, \"Not a number: \" .. arg\n        elseif num < lower then\n            return nil, \"Value too low: \" .. arg .. \" < \" .. lower\n        elseif num > upper then\n            return nil, \"Value too high: \" .. arg .. \" > \" .. upper\n        end\n        return num\n    end\nen","completion":""}
{"prompt":"-- Gets last atom at end of string as extension if\n-- no extension whole string is returned\n-- @param file_str: path or file name to get extension from\nlocal function GetFileExtension(file_str)\n\tif file_str:match(\"[^\/]*$\") ~= nil then\n\t\tlocal extension = file_str:match(\"[^.]*$\")\n\t\tif extension == nil then\n\t\t\textension = \"\"\n\t\tend\n\t\treturn extension\n\tend\n\treturn \"\"\nen","completion":""}
{"prompt":"-- Computes network round trip time between nodes using network coordinates.\n-- https:\/\/www.consul.io\/docs\/internals\/coordinates.html\nlocal function compute_rtt(coord_a, coord_b)\n  if coord_a.error or coord_b.error then\n    return 0\n  end\n  return math.sqrt(math.pow(coord_a.Vec[1] - coord_b.Vec[1], 2) + math.pow(coord_a.Vec[2] - coord_b.Vec[2], 2))\nen","completion":""}
{"prompt":"-- (int) -> int\n-- Calcula la sumatoria de todos los numeros hasta el valor dado\n-- >>> sumatoria(10)\n-- 55\n-- >>> sumatoria(19)\n-- 190\n-- >>> sumatoria(1000000000)\n-- 500000000500000000\n-- :param num: int el numero hasta donde queremos calcular la sumatoria\n-- :return: int la suma de todos los digitos hasta el valor\nlocal function sumatoria(num)\n    return num * (num + 1) \/ 2\nen","completion":""}
{"prompt":"-- Subtracts matrix B from matrix A and returns difference\n-- :param A: The first matrix\n-- :param B: The second matrix\n-- :return: Matrix difference\nlocal function matsubtraction(A, B)\n    local n, m = #A, #A[1]\n    assert(n == #B and m == #B[1], \"Matrices must have equal dimensions\")\n    local C = {}\n    for i = 1, n do\n        C[i] = {}\n        for j = 1, m do\n            C[i][j] = A[i][j] - B[i][j]\n        end\n    end\n    return C\nen","completion":""}
{"prompt":"-- Zig-zag decodes an integer value.\nlocal function decode_signed_varint(i)\n  if (i & 0x1) == 0 then\n    return (i >> 1)\n  else\n    return -((i + 1) >> 1)\n  end\nen","completion":""}
{"prompt":"-- Something like a sieve of Eratosthenes for factorization - 1\n-- Complexity: O(sqrt(N))\n-- We can find all the factors of a number using a simple\n-- alternation to the Eratosthenes sieve. Factors are the\n-- numbers you multiply to get another number. Those numbers\n-- can be written as prime only numbers. Why? Lets take the\n-- number 20 for example. Its factors are 4 and 5, or 2 and 10\n-- etc. All of these can be written as 2 * 2 * 5 though, which\n-- is unique. It becomes obvious that every non prime number\n-- can be written as the multiplication of primes. As already\n-- stated if n is non prime then there is a prime that divides\n-- it and p^2 <= n and that's the reason why we loop only up\n-- to sqrt(n). We basically find the minimum prime that divides\n-- our number. When we find it, we divide the number by that\n-- prime and we continue the same process.\nlocal function mod_sqrt_fact_eratosthenes_sieve(n)\n\tlocal factors = {}\n\tlocal i = 2\n\twhile i * i <= n do\n\t\twhile n % i == 0 do\n\t\t\ttable.insert(factors, i)\n\t\t\tn = n \/ i\n\t\tend\n\t\ti = i + 1\n\tend\n\tif n > 1 then\n\t\ttable.insert(factors, n)\n\tend\n\treturn factors\nen","completion":""}
{"prompt":"-- Linearly rescale a value to 0 and 1 using the min and max values.\n-- :param min:\n-- :param max:\n-- :param value:\n-- :rtype: float\nlocal function linear_rescale(min, max, value)\n  return (value - min) \/ (max - min)\nen","completion":""}
{"prompt":"-- only rename the end values of nested dictionary {ignore : {ignore : {ignore : target}, ignore_2 : target}}\n-- val = {ignore : {ignore : {ignore : target}, ignore_2 : target}}\n-- rename_di = {ignore: 1, target: 2, ignore_2: 3}\n-- output {ignore : {ignore : {ignore : 2}, ignore_2 : 2}}\nlocal function rename(val, rename_di)\n  if type(val) ~= \"table\" then\n    if val then\n      return rename_di[val] or val\n    else\n      return val\n    end\n  else\n    local new_val = {}\n    for key, value in pairs(val) do\n      new_val[key] = rename(value, rename_di)\n    end\n    return new_val\n  end\nen","completion":""}
{"prompt":"-- Reverse orientation of `sequence`.\n-- Returns a string with `sequence` in the reverse order.\n-- If `sequence` is empty, an empty string is returned.\nlocal function get_reverse(rna_sequence)\n\tlocal reverse = \"\"\n\tif (rna_sequence) then\n\t\tfor i = #rna_sequence, 1, -1 do\n\t\t\treverse = reverse .. rna_sequence:sub(i, i)\n\t\tend\n\tend\n\treturn reverse\nen","completion":""}
{"prompt":"-- Return the value of G(n), computed iteratively.\n-- >>> g_iter(1)\n-- 1\n-- >>> g_iter(2)\n-- 2\n-- >>> g_iter(3)\n-- 3\n-- >>> g_iter(4)\n-- 10\n-- >>> g_iter(5)\n-- 22\n-- >>> from construct_check import check\n-- >>> check(HW_SOURCE_FILE, 'g_iter', ['Recursion'])\n-- True\nlocal function g_iter(n)\n  if n == 1 then\n    return 1\n  elseif n == 2 then\n    return 2\n  elseif n == 3 then\n    return 3\n  else\n    return g_iter(n - 1) + 2 * g_iter(n - 2) + 3 * g_iter(n - 3)\n  end\nen","completion":""}
{"prompt":"-- Return number's suffix\n-- Example:\n-- 1 -> \"st\"\n-- 42 -> \"nd\"\n-- 333 -> \"rd\"\nlocal function suffix(n)\n\tlocal rem = n % 10\n\tif rem == 1 and n ~= 11 then\n\t\treturn \"st\"\n\telseif rem == 2 and n ~= 12 then\n\t\treturn \"nd\"\n\telseif rem == 3 and n ~= 13 then\n\t\treturn \"rd\"\n\telse\n\t\treturn \"th\"\n\tend\nen","completion":""}
{"prompt":"-- Returns the squared difference between two numbers\nlocal function squared_loss(x1, x2)\n\tlocal diff = x1 - x2\n\treturn diff * diff\nen","completion":""}
{"prompt":"-- This method decides if a given floating point number is an integer or not --\n-- so only 0s after the decimal point.\n-- For example 1.0 is an integer 1.0002 is not.\nlocal function isnointeger(number)\n\tlocal integer, decimal, dot, zeros\n\tinteger, decimal, dot, zeros = string.match(number, \"(%d+)(%.%d+)?(%.)?\")\n\tif decimal and #decimal > 1 then\n\t\tif #zeros == #decimal then\n\t\t\treturn true\n\t\telse\n\t\t\treturn false\n\t\tend\n\telse\n\t\treturn true\n\tend\nen","completion":""}
{"prompt":"-- This function will truncate the stripped doc string to a more manageable\n-- length for incorporation into wrapped vistrails functions\n-- Parameters\n-- ----------\n-- original_description : list\n-- This object is the original description stripped from the\n-- doc string. The object is actually a list of strings.\n-- word_cnt_to_include : int\n-- specify the number of words to trim the description down to\n-- Returns\n-- -------\n-- short_description : string\n-- truncated description that will be passed into vistrails\nlocal function _truncate_description(original_description, word_cnt_to_include)\n    if not original_description or not word_cnt_to_include or word_cnt_to_include == 0 then\n        return \"\"\n    end\n    if #original_description < word_cnt_to_include then\n        return original_description[1]\n    end\n    local short_description = \"\"\n    for i=1,word_cnt_to_include do\n        short_description = short_description .. \" \" .. original_description[i]\n    end\n    return short_description\nen","completion":""}
{"prompt":"-- takes a comma separated string and returns a list of strings\n-- using the comma as the delimiter\n-- example:\n-- 'HMC, V7000 ' -> ['HMC','V7000']\n-- args:\n-- strings:   comma separated string list\n-- returns:\n-- string[]  list of strings\nlocal function get_strip_strings_array(strings)\n  local new_string = string.gsub(strings, '%s+','')\n  local new_string_array = {}\n  for word in string.gmatch(new_string, \"([^,]+)\") do\n    table.insert(new_string_array, word)\n  end\n  return new_string_array\nen","completion":""}
{"prompt":"-- Linear interpolation\nlocal function interp(x, in_min, in_max, out_min, out_max)\n\treturn out_min + (out_max - out_min) * ((x - in_min) \/ (in_max - in_min))\nen","completion":""}
{"prompt":"-- Trivial function that returns the month portion of a night. Can be given a string or int.\n-- Args:\n-- night, int or str. The night you want the month of.\n-- Returns:\n-- str. The zero-padded (length two) string representation of the month corresponding to the input month.\nlocal function night_to_month(night)\n    night = tonumber(night)\n    if not night then return night end\n    local month = tonumber(string.sub(tostring(night),1,2))\n    if not month then return month end\n    return (\"%02d\"):format(month)\nen","completion":""}
{"prompt":"-- Compute the square of standard Euclidean distance between two points\n-- represented as n-tuples.  This is the default distance metric for the\n-- K-means object.\nlocal function euclidean_distance(pt1, pt2)\n    local result = 0\n    for i, value in ipairs(pt1) do\n        result = result + (value - pt2[i]) ^ 2\n    end\n    return result\nen","completion":""}
{"prompt":"-- Get number of users, using https:\/\/api.slack.com\/methods\/users.list\nlocal function get_nb_users(response)\n\tif not response then\n\t\tresponse = do_https_request(\"\/api\/users.list\", {})\n\t\tif response == nil then return 0 end\n\tend\n\treturn response.members and #response.members or 0\nen","completion":""}
{"prompt":"-- Basic Hermite curve.\nlocal function Q(p0, p1, v0, v1, t0, t1, t)\n  local s = (t - t0) \/ (t1 - t0)\n  return (2 * s^3 - 3 * s^2 + 1) * p0\n         + (s^3 - 2 * s^2 + s) * v0\n         + (-2 * s^3 + 3 * s^2) * p1\n         + (s^3 - s^2) * v1\nen","completion":""}
{"prompt":"-- >>> binary(0, 5)\n-- [0, 0, 0, 0, 0]\n-- >>> binary(15, 4)\n-- [1, 1, 1, 1]\n-- >>> binary(14, 4)\n-- [1, 1, 1, 0]\nlocal function binary(i, width)\n\tassert(type(i) == 'number', 'number expected')\n\tassert(type(width) == 'number', 'number expected')\n\tassert(i >= 0, 'negative number not allowed')\n\tassert(width >= 1, 'width expected to be greater than 0')\n\tlocal t = {}\n\tfor j = width, 1, -1 do\n\t\tt[j] = i % 2\n\t\ti = math.floor(i \/ 2)\n\tend\n\treturn t\nen","completion":""}
{"prompt":"-- Add leading zeros to a number.\n-- :type number: number\n-- :param number: The number to add the leading zeros to.\n-- :type minlength: integer\n-- :param minlength: If the number is shorter than this length than add leading zeros to make the length correct.\n-- :return: The number with a leading zero\n-- :rtype: string\n-- >>> leadingzero(1, 2)\n-- '01'\nlocal function leadingzero(number, minlength)\n    minlength = minlength or 0\n    number = tostring(number)\n    while #number < minlength do\n        number = '0' .. number\n    end\n    return number\nen","completion":""}
{"prompt":"-- Returns the WGS-84 EPSG for a given UTM zone\n-- Input:\n-- zone(int): Zone, positive values for North\n-- Output:\n-- epsg code(int).\nlocal function epsg_from_utm_zone(zone)\n    if zone > 0 then\n        -- North\n        return zone + 32600\n    else\n        -- South\n        return 32700 - zone\n    end\nen","completion":""}
{"prompt":"-- Return the number of times `key` occurs as a key in `list_of_tuples`.\nlocal function _count_key_occurence_list_of_tuples(list_of_tuples, key)\n  local count = 0\n  for _, v in ipairs(list_of_tuples) do\n    if v[1] == key then\n      count = count + 1\n    end\n  end\n  return count\nen","completion":""}
{"prompt":"-- The opposite of the ``join`` template tag\nlocal function split(value, delimiter)\n  local delimiter = delimiter or ' '\n  local result = {}\n  for match in (value..delimiter):gmatch(\"(.-)\"..delimiter) do\n    table.insert(result, match)\n  end\n  return result\nen","completion":""}
{"prompt":"-- Linear interpolation between two values.\nlocal function interpolate(x0, y0, x1, y1, x)\n  return (y0 * (x1 - x) + y1 * (x - x0)) \/ (x1 - x0)\nen","completion":""}
{"prompt":"-- This function is used to find out the dimension of problem with the help of the q array\n-- since the solution field have one element more which contains the number of unknowns per subcell the dimension \n-- computed by substracting one from the size of the solution list.\nlocal function get_dimension(q)\n    return (#q - 1)\nen","completion":""}
{"prompt":"-- Convert the IPv4 address integer to the IPv4 address string.\n-- :param int intIPv4AddrInteger: IPv4 address integer.\n-- :return: IPv4 address string.\n-- :rtype: str\n-- Example::\n-- intIPv4AddrInteger    Return\n-- ---------------------------------\n-- 3221225985         -> '192.0.2.1'\n-- Test:\n-- >>> _toIPv4AddrString(3221225985)\n-- '192.0.2.1'\nlocal function _toIPv4AddrString(intIPv4AddrInteger)\n    return string.format(\"%d.%d.%d.%d\",\n            intIPv4AddrInteger >> 24,\n            intIPv4AddrInteger >> 16 & 0xFF,\n            intIPv4AddrInteger >> 8 & 0xFF,\n            intIPv4AddrInteger & 0xFF)\nen","completion":""}
{"prompt":"-- Wait 1, 2, 5 seconds. All retries after the 3rd retry will wait 5*N-5 seconds.\nlocal function straight_backoff(count)\n\tlocal n = count + 1\n\treturn n == 1 and 1 or (n == 2 and 2 or (n == 3 and 5 or math.max(5, math.min(15, math.floor(2^n-10)))))\nen","completion":""}
{"prompt":"-- Color wheel to allow for cycling through the rainbow of RGB colors.\nlocal function rgb_color_wheel(wheel_pos)\n\tif wheel_pos < 85 then\n\t\treturn {255 - wheel_pos * 3, 0, wheel_pos * 3}\n\telseif wheel_pos < 170 then\n\t\twheel_pos = wheel_pos - 85\n\t\treturn {0, wheel_pos * 3, 255 - wheel_pos * 3}\n\telse\n\t\twheel_pos = wheel_pos - 170\n\t\treturn {wheel_pos * 3, 255 - wheel_pos * 3, 0}\n\tend\nen","completion":""}
{"prompt":"-- Right-aligns the value in a field of a given width.\n-- Argument: field size.\nlocal function rjust(value, arg)\n    value = tostring(value)\n    return string.rep(\" \", arg - #value) .. value\nen","completion":""}
{"prompt":"-- Compute factorial of given value.\n-- :param value: A non-negative integer.\n-- :return: Factorial of given value.\n-- >>> factorial(0)\n-- 1\n-- >>> factorial(1)\n-- 1\n-- >>> factorial(2)\n-- 2\n-- >>> factorial(3)\n-- 6\n-- >>> factorial(4)\n-- 24\nlocal function factorial(value)\n    local result = 1\n    for i=value,1,-1 do result = result * i end\n    return result\nen","completion":""}
{"prompt":"-- Analytically evaluate Gaussian log probability.\nlocal function gaussian_lp(x, mean, var)\n    if var == 0 then\n        return 0\n    else\n        return -(x - mean) * (x - mean) \/ (2 * var)\n    end\nen","completion":""}
{"prompt":"-- vytvori dvojrozmerne pole (matice, seznam v seznamu)\n-- dle zadane sirky a delky a vyplni se kazde mi sto \".\"\nlocal function vytvor_pole(pocet_radku, pocet_sloupcu)\n    local pole = {}\n    for i=1,pocet_radku do\n        local rad = {}\n        for j=1,pocet_sloupcu do\n            rad[j] = \".\"\n        end\n        pole[i] = rad\n    end\n    return pole\nen","completion":""}
{"prompt":"-- Returns the inverse of n_words = matrix_size * (matrix_size + 1)\nlocal function _infer_fortran_zones(n_words)\n  local n_rows = math.floor(math.sqrt(n_words))\n  assert(n_rows * (n_rows + 1) == n_words)\n  return n_rows\nen","completion":""}
{"prompt":"-- Check if the user guessed the right letter.\n-- :param ans: The correct word string.\n-- :param temp_ans:Every temporarily answer when the user guess a letter.\n-- :param input_ch: The character the user input.\n-- :return: return to the temporarily answer when the user do a new guess.\nlocal function check(ans, temp_ans, input_ch)\n    if (string.find(ans, input_ch) ~= nil) then\n        if (string.find(temp_ans, input_ch) == nil) then\n            temp_ans = temp_ans .. input_ch\n        end\n    else\n        temp_ans = temp_ans .. \"_\"\n    end\n    return temp_ans\nen","completion":""}
{"prompt":"-- Check if year is leapyear\nlocal function leapyr_check(year)\n\treturn (year % 4 == 0 and year % 100 ~= 0) or year % 400 == 0\nen","completion":""}
{"prompt":"-- Dimensionless production rate for a gene regulated by two\n-- activators with OR logic in the absence of leakage with single\n-- occupancy.\n-- Parameters\n-- ----------\n-- x : float or NumPy array\n-- Concentration of first activator.\n-- y : float or NumPy array\n-- Concentration of second activator.\n-- nx : float\n-- Hill coefficient for first activator.\n-- ny : float\n-- Hill coefficient for second activator.\n-- Returns\n-- -------\n-- output : NumPy array or float\n-- (x**nx + y**ny) \/ (1 + x**nx + y**ny)\nlocal function aa_or_single(x, y, nx, ny)\n  return (x ^ nx + y ^ ny) \/ (1 + x ^ nx + y ^ ny)\nen","completion":""}
{"prompt":"-- Function removes the leading \/ characters. They're\n-- messing up the directory structure.\nlocal function sanitize_destination(path)\n\tif not path then return \"\" end\n\treturn path:gsub(\"^\/+\", \"\")\nen","completion":""}
{"prompt":"-- Compute derivative of sigmoid function\nlocal function derivative_sigmoid(sigmoid_output)\n  return sigmoid_output * (1 - sigmoid_output)\nen","completion":""}
{"prompt":"-- returns the perimeter of the island described in grid\nlocal function island_perimeter(grid)\n  local result = 0\n  for x, row in ipairs(grid) do\n    for y, cell in ipairs(row) do\n      if cell == 1 then\n        result = result + 4\n        if x > 1 and grid[x - 1][y] == 1 then\n          result = result - 1\n        end\n        if y > 1 and grid[x][y - 1] == 1 then\n          result = result - 1\n        end\n        if x < #grid and grid[x + 1][y] == 1 then\n          result = result - 1\n        end\n        if y < #grid[x] and grid[x][y + 1] == 1 then\n          result = result - 1\n        end\n      end\n    end\n  end\n  return result\nen","completion":""}
{"prompt":"-- Return square root of n, with maximum absolute error epsilon\nlocal function square_root(n, epsilon)\n  return math.sqrt(n, epsilon)\nen","completion":""}
{"prompt":"-- The hamacher (t-norm) product of a and b.\n-- computes (a * b) \/ ((a + b) - (a * b))\n-- Args:\n-- a (float): 1st term of hamacher product.\n-- b (float): 2nd term of hamacher product.\n-- Raises:\n-- ValueError: a and b must range between 0 and 1\n-- Returns:\n-- float: The hammacher product of a and b\nlocal function hamacher_product(a, b)\n  if a < 0 or b < 0 or a > 1 or b > 1 then\n    error(\"hamacher_product() - a and b must be between 0 and 1\")\n  end\n  if a == 0 or b == 0 then\n    return 0\n  end\n  return (a * b) \/ (a + b - (a * b))\nen","completion":""}
{"prompt":"-- Calculate total Sulphur\n-- Morris, A. W., and Riley, J. P., Deep-Sea Research 13:699-705, 1966:\n-- this is .02824.*Sali.\/35. = .0008067.*Sali\nlocal function calc_TS(Sal)\n  local TS = .0008067 * Sal\n  return TS\nen","completion":""}
{"prompt":"-- Converts runtimes in seconds to hours:minutes:seconds format.\nlocal function time_convert(seconds)\n\treturn string.format(\"%d:%02d:%02d\", math.floor(seconds \/ 3600), math.floor(seconds \/ 60 - (math.floor(seconds \/ 3600) * 60)), math.floor(seconds - (math.floor(seconds \/ 60) * 60)))\nen","completion":""}
{"prompt":"-- Rounds up the given value to the next multiple of 16.\nlocal function roundup_16(x)\n    local remainder = x % 16\n    if remainder == 0 then\n        return x\n    end\n    return x + 16 - remainder\nen","completion":""}
{"prompt":"-- :param list_of_tuples:\n-- :return: New tuples list sorted by prices high to low\nlocal function sort_prices(list_of_tuples)\n  table.sort(list_of_tuples, function(a, b) return a[2] > b[2] end)\n  return list_of_tuples\nen","completion":""}
{"prompt":"-- calculates the angle between two points on the globe\n-- output:\n-- initial_bearing  from -180 to + 180 deg\nlocal function bearing(lon1, lat1, lon2, lat2)\n  -- Convert latitude and longitude to radians\n  local lat1_rad, lon1_rad = math.rad(lat1), math.rad(lon1)\n  local lat2_rad, lon2_rad = math.rad(lat2), math.rad(lon2)\n  -- Calculate angle\n  local y = math.sin(lon2_rad - lon1_rad) * math.cos(lat2_rad)\n  local x = math.cos(lat1_rad) * math.sin(lat2_rad) - math.sin(lat1_rad) * math.cos(lat2_rad) * math.cos(lon2_rad - lon1_rad)\n  local bearing = math.deg(math.atan2(y, x))\n  -- Return an angle between -180 and +180 degrees\n  if bearing < 0 then\n    return bearing + 360\n  else\n    return bearing\n  end\nen","completion":""}
{"prompt":"-- Escapes spaces in the given filename, Unix-style.\nlocal function _escape_filename(filename)\n  return filename:gsub(' ', '\\\\ ')\nen","completion":""}
{"prompt":"-- Returns the given object within a list if it is not already\nlocal function expect_list(obj)\n    if (type(obj) == \"table\") then\n        return obj\n    else\n        return { obj }\n    end\nen","completion":""}
{"prompt":"-- Find shortest number of edges between nodes x and y.\n-- :x: a node\n-- :y: a node\n-- :Returns: shortest number of edges from node x to y or -1 if none exists\nlocal function bfs_shortest_path(graph, x, y)\n    local visited = {}\n    local queue = { x }\n    local depth = {}\n    depth[x] = 0\n    while #queue > 0 do\n        local u = table.remove(queue, 1)\n        if u == y then\n            return depth[y]\n        end\n        for i, v in ipairs(graph[u]) do\n            if not visited[v] then\n                table.insert(queue, v)\n                visited[v] = true\n                depth[v] = depth[u] + 1\n            end\n        end\n    end\n    return -1\nen","completion":""}
{"prompt":"-- Converts numbers in word format into number format\n-- >>> convert_words_to_numbers(['five', \"o'clock\"])\n-- ['5', \"o'clock\"]\n-- >>> convert_words_to_numbers(['seven', \"o'clock\"])\n-- ['7', \"o'clock\"]\nlocal function convert_words_to_numbers(tokens)\n\tlocal number_map = {\n\t\t[\"zero\"] = \"0\",\n\t\t[\"one\"] = \"1\",\n\t\t[\"two\"] = \"2\",\n\t\t[\"three\"] = \"3\",\n\t\t[\"four\"] = \"4\",\n\t\t[\"five\"] = \"5\",\n\t\t[\"six\"] = \"6\",\n\t\t[\"seven\"] = \"7\",\n\t\t[\"eight\"] = \"8\",\n\t\t[\"nine\"] = \"9\",\n\t\t[\"ten\"] = \"10\",\n\t\t[\"eleven\"] = \"11\",\n\t\t[\"twelve\"] = \"12\",\n\t\t[\"thirteen\"] = \"13\",\n\t\t[\"fourteen\"] = \"14\",\n\t\t[\"fifteen\"] = \"15\",\n\t\t[\"sixteen\"] = \"16\",\n\t\t[\"seventeen\"] = \"17\",\n\t\t[\"eighteen\"] = \"18\",\n\t\t[\"nineteen\"] = \"19\",\n\t\t[\"twenty\"] = \"20\",\n\t\t[\"thirty\"] = \"30\",\n\t\t[\"forty\"] = \"40\",\n\t\t[\"fifty\"] = \"50\",\n\t\t[\"sixty\"] = \"60\",\n\t\t[\"seventy\"] = \"70\",\n\t\t[\"eighty\"] = \"80\",\n\t\t[\"ninety\"] = \"90\",\n\t}\n\tlocal result = {}\n\tfor i, token in ipairs(tokens) do\n\t\tif number_map[token] then\n\t\t\tresult[i] = number_map[token]\n\t\telse\n\t\t\tresult[i] = token\n\t\tend\n\tend\n\treturn result\nen","completion":""}
{"prompt":"-- Scales a dataset using a minmax function with range\n-- :param data:\n-- :param min_val:\n-- :param max_val:\n-- :param min_scale:\n-- :param max_scale:\n-- :return:\nlocal function scale_minmax_range(data, min_val, max_val, min_scale, max_scale)\n    return (data - min_val) * (max_scale - min_scale) \/ (max_val - min_val) + min_scale\nen","completion":""}
{"prompt":"-- (str) -> str\n-- Return a reversed version of s.\n-- >>> reverse('hello')\n-- 'olleh'\n-- >>> reverse('a')\n-- 'a'\nlocal function reverse(s)\n  local res = ''\n  for i = #s, 1, -1 do\n    res = res .. s:sub(i, i)\n  end\n  return res\nen","completion":""}
{"prompt":"-- Subtract one 3-dimensional point from another\n-- Parameters\n-- coords1: coordinates of form [x,y,z]\n-- coords2: coordinates of form [x,y,z]\n-- Returns\n-- list:  List of coordinates equal to coords1 - coords2 (list)\nlocal function subtract(coords1, coords2)\n    local result = {}\n    for i = 1, 3, 1 do\n        result[i] = coords1[i] - coords2[i]\n    end\n    return result\nen","completion":""}
{"prompt":"-- Given a tuple (bookID, ratings_iterable) \n-- returns (bookID, (ratings_count, ratings_avg))\nlocal function get_counts_and_averages(ID_and_ratings_tuple)\n  local bookID = ID_and_ratings_tuple[1]\n  local ratings_iterable = ID_and_ratings_tuple[2]\n  local ratings_count = #ratings_iterable\n  local ratings_sum = 0\n  for i = 1, ratings_count do\n    ratings_sum = ratings_sum + ratings_iterable[i]\n  end\n  local ratings_avg = ratings_sum \/ ratings_count\n  return {bookID, {ratings_count, ratings_avg}}\nen","completion":""}
{"prompt":"-- Quick function to determine if an Axes object is 3D (can accept x, y, z data)\n-- or 2d (can only accept x, y data)\nlocal function _get_axes_ndim(axes)\n  if type(axes) == \"table\" then\n    return #axes\n  else\n    return 2\n  end\nen","completion":""}
{"prompt":"-- Given a string of the form [item item item], return a list of strings, one per item.\n-- WARNING: does not yet work right when an item has spaces.  I believe in that case we'll be\n-- given a string like '[item1 \"item2 with spaces\" item3]'.\nlocal function _splitlist(s)\n  local ls = {}\n  -- First, strip off the leading '[' and trailing ']'\n  s = string.sub(s,2,-2)\n  -- Second, split on ' ' (space)\n  local tokens = string.gmatch(s, \"([^%s]+)\")\n  for token in tokens do\n    ls[#ls+1] = token\n  end\n  return ls\nen","completion":""}
{"prompt":"-- Get all keys from a value in a dictionnary\nlocal function get_keys_from_val(dic, val)\n    local keys = {}\n    for k, v in pairs(dic) do\n        if v == val then\n            keys[#keys + 1] = k\n        end\n    end\n    return keys\nen","completion":""}
{"prompt":"-- Convert a single value (padding or border) to a dict\n-- with keys 'top', 'bottom', 'left' and 'right'\nlocal function format_all_sides(value)\n  return {\n    top = value,\n    bottom = value,\n    left = value,\n    right = value,\n  }\nen","completion":""}
{"prompt":"-- Add basic attribute\n-- Args:\n-- _sample: data sample\n-- class_id: class label asscociated with the data\n-- (sometimes indicting from which subset the data are drawn)\nlocal function attrib_basic(_sample, class_id)\n    return {\n        class_id = class_id,\n        -- class_id = tostring(class_id),\n        -- class_id = class_id and class_id or 'undefined'\n    }\nen","completion":""}
{"prompt":"-- Return a label with an optional plural suffix\nlocal function plural(length, label, suffix)\n  suffix = suffix or 's'\n  return string.format(\"%d %s%s\", length, label, length ~= 1 and suffix or '')\nen","completion":""}
{"prompt":"-- This function takes two vectors, a and b, and find's their cross product.\nlocal function cross_prod(a, b)\n\treturn {\n\t\ta[2]*b[3] - a[3]*b[2],\n\t\ta[3]*b[1] - a[1]*b[3],\n\t\ta[1]*b[2] - a[2]*b[1],\n\t}\nen","completion":""}
{"prompt":"-- Converts given column number into a column letters.\n-- Right shifts the column index by 26 to find column letters in reverse\n-- order. These numbers are 1-based, and can be converted to ASCII\n-- ordinals by adding 64.\n-- Parameters\n-- ----------\n-- number : int\n-- Column number to convert to column letters.\n-- Returns\n-- -------\n-- unicode\n-- Column letters.\n-- References\n-- ----------\n-- :cite:`OpenpyxlDevelopers2019`\n-- Examples\n-- --------\n-- # Doctests skip for Python 2.x compatibility.\n-- >>> _column_number_to_letters(128)  # doctest: +SKIP\n-- 'DX'\nlocal function _column_number_to_letters(number)\n  local letters = ''\n  while number > 0 do\n    -- Make the number right-shift the number of letters in the base (26).\n    local remainder = number % 26\n    if remainder == 0 then\n      remainder = 26\n    end\n    number = math.floor((number - remainder) \/ 26)\n    -- Add the appropriate letter for the remainder.\n    letters = string.char(64 + remainder) .. letters\n  end\n  return letters\nen","completion":""}
{"prompt":"-- Given an integer, returns a string representation, padded with [desired_digits] zeros.\nlocal function leading_zeros(value, desired_digits)\n    local zeros = string.rep(\"0\", desired_digits - #tostring(value))\n    return zeros .. tostring(value)\nen","completion":""}
{"prompt":"-- Removes comments from a JSON string.\n-- Supporting a trivial extension to the JSON format.  Allow comments\n-- to be embedded within the JSON, requiring that a comment be on an\n-- independent line starting with '\/\/' or '#'.\n-- Example...\n-- {\n-- \/\/ comment\n-- 'name' : 'value'\n-- }\n-- Args:\n-- commented_json_str (str):  a JSON string\n-- Returns:\n-- str: uncommented, legal JSON\nlocal function uncomment_json(commented_json_str)\n  -- Remove all comments that follow the JSON specification, namely,\n  -- comments that begin with '\/\/' or '#'.  We do this by replacing each\n  -- comment line with a single space.\n  local uncommented_json_str = commented_json_str:gsub('^%s*\/\/.*\\n', '\\n')\n  uncommented_json_str = uncommented_json_str:gsub('^%s*#.*\\n', '\\n')\n  -- Eliminate any remaining comment lines by removing their newline\n  -- characters.\n  uncommented_json_str = uncommented_json_str:gsub('\\n', '')\n  return uncommented_json_str\nen","completion":""}
{"prompt":"-- Single bit addition\nlocal function half_adder(a, b)\n\tlocal s = a + b -- full adder\n\tlocal c = (s > 1) and 1 or 0 -- carry\n\ts = (s % 2) -- sum\n\t\n\treturn s, c\nen","completion":""}
{"prompt":"-- Returns a boolean only if value satisfies the threshold test. In case of failure of any sort, returns the default value (which defaults to 'False').\n-- Accepted mode values are '<', '>', '<=' and '>='.\nlocal function compareThresh(value, threshold, mode, inclusive)\n  if type(value) == 'number' and type(threshold) == 'number' and type(mode) == 'string' then\n    if mode == '<' then\n      return inclusive and value <= threshold or value < threshold\n    elseif mode == '>' then\n      return inclusive and value >= threshold or value > threshold\n    elseif mode == '<=' then\n      return inclusive and value < threshold or value <= threshold\n    elseif mode == '>=' then\n      return inclusive and value > threshold or value >= threshold\n    end\n  end\n  return false\nen","completion":""}
{"prompt":"-- Make list when it is necessary\nlocal function _make_list(x)\n\tif type(x) == \"table\" then\n\t\treturn x\n\telse\n\t\treturn {x}\n\tend\nen","completion":""}
{"prompt":"-- Return the last (bottom) row of a matrix.\n-- Returns a tuple (immutable).\nlocal function bottom_row(matrix)\n\treturn matrix[#matrix]\nen","completion":""}
{"prompt":"-- Retrieves the \"other\" index that is not equal to the stack index or target stack index.\n-- Parameters\n-- ----------\n-- si : int\n-- The stack index that would be removed from.\n-- ti : int\n-- The target stack index that would be added to.\n-- Returns\n-- -------\n-- int\n-- The \"other\" index in the list [0, 1, 2] that equates to the stack index that is unused (not stack index or target stack index).\nlocal function other(si, ti)\n\treturn 3 - si - ti\nen","completion":""}
{"prompt":"-- Convert F to C.\nlocal function f_to_c(temp_f)\n   return ((temp_f - 32) * 5 \/ 9)\nen","completion":""}
{"prompt":"-- Convert a number to a reversed array of digits.\nlocal function digitize(n)\n    local t = {}\n    repeat\n        local d = n % 10\n        n = math.floor(n \/ 10)\n        t[#t+1] = d\n    until n == 0\n    return t\nen","completion":""}
{"prompt":"-- Helper function to assist in handling multiple translations of a message.\nlocal function _translate(messages, language_code)\n\t-- Search for the message in the message table.\n\tlocal message = messages[language_code]\n\tif message then\n\t\t-- A message was found. Return it.\n\t\treturn message\n\telse\n\t\t-- Search for the message in the default message table.\n\t\tlocal default_message = messages[\"en\"]\n\t\tif default_message then\n\t\t\t-- A message was found. Return it.\n\t\t\treturn default_message\n\t\telse\n\t\t\t-- No message was found. Return the passed table.\n\t\t\treturn messages\n\t\tend\n\tend\nen","completion":""}
{"prompt":"-- Return *text* as a unicode string. All text in Python 3 is unicode, so\n-- this just returns *text* unchanged.\nlocal function to_unicode(text)\n    return text\nen","completion":""}
{"prompt":"-- Add class names without underscores for compatibility.\n-- Previously, no resources had underscores in APIClient.  Parsing of\n-- resources has been fixed so now these resources will have underscores.\n-- This adds an extra class for those resources without an underscore\n-- for compatibility. Additionally, this removes the resource \"feature_flags\"\n-- as APIClient has a name collision with this resource. This will\n-- be removed in v2.0.0.\nlocal function _add_no_underscore_compatibility(classes)\n    local classes_no_underscore = {}\n    for k, v in pairs(classes) do\n        classes_no_underscore[k] = v\n        classes_no_underscore[k:gsub(\"_\", \"\")] = v\n    end\n    return classes_no_underscore\nen","completion":""}
{"prompt":"-- (number, number, number, number, number) -> float\n-- Linear scaling. Scales old_value in the range (in_high - in-low) to a value\n-- in the range (out_high - out_low). Returns the result.\n-- >>> linear_scale(0.5, 0.0, 1.0, 0, 127)\n-- 63.5\nlocal function linear_scale(input, in_low, in_high, out_low, out_high)\n    return (input - in_low) \/ (in_high - in_low) * (out_high - out_low) + out_low\nen","completion":""}
{"prompt":"-- Returns the 1-based index of the first bit set to 1 from the right side of a\n-- 32bit integer\n-- >>> trailing_zeros(0)\n-- 32\n-- >>> trailing_zeros(0b1000)\n-- 4\n-- >>> trailing_zeros(0b10000000)\n-- 8\nlocal function trailing_zeros(number)\n\tif number == 0 then return 32 end\n\tlocal bit = 1\n\twhile number % 2 == 0 do\n\t\tnumber = number \/ 2\n\t\tbit = bit + 1\n\tend\n\treturn bit\nen","completion":""}
{"prompt":"-- Encode &, < and > entities in text that will\n-- be used in\/as HTML.\nlocal function html_encode(text)\n\tif type(text) == \"string\" then\n\t\treturn text:gsub(\"[<>&]\", {\n\t\t\t[\"&\"] = \"&amp;\";\n\t\t\t[\"<\"] = \"&lt;\";\n\t\t\t[\">\"] = \"&gt;\";\n\t\t})\n\telse\n\t\treturn tostring(text)\n\tend\nen","completion":""}
{"prompt":"-- Return roman version of the specified arabic number.\nlocal function arabic_to_roman(number)\n  local arabic = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 }\n  local roman = { 'M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I' }\n  local result = ''\n  for i = 1, #arabic do\n    while number >= arabic[i] do\n      result = result .. roman[i]\n      number = number - arabic[i]\n    end\n  end\n  return result\nen","completion":""}
{"prompt":"-- Rescale X linearly to be in `new_range` rather than `old_range`.\nlocal function rescale_range(X, old_range, new_range)\n   return (X - old_range[1]) \/ (old_range[2] - old_range[1]) * (new_range[2] - new_range[1]) + new_range[1]\nen","completion":""}
{"prompt":"-- Convert the month, provided as an int, to a yearly quarter, also an int.\n-- Args:\n-- month_num (int): The month number to convert (1-12)\n-- Returns:\n-- int: The quarter this month is in\n-- Examples:\n-- >>> month_to_quarter(1)\n-- 1\n-- >>> month_to_quarter(9)\n-- 3\nlocal function month_to_quarter(month_num)\n    return math.ceil(month_num \/ 3)\nen","completion":""}
{"prompt":"-- :param budget: float - the amount of money you are planning to exchange.\n-- :param denomination: int - the value of a single bill.\n-- :return: int - number of bills after exchanging all your money.\nlocal function get_number_of_bills(budget, denomination)\n  return math.floor(budget \/ denomination)\nen","completion":""}
{"prompt":"-- Return case insensitive dpkg -S regexp.\nlocal function ci_regexp(name)\n    return string.gsub(name, \"%w\", function(ch)\n        return \"[\" .. string.upper(ch) .. string.lower(ch) .. \"]\"\n    end)\nen","completion":""}
{"prompt":"-- Dynamic programming in a down-top way.\n-- The function can be enhanced by only store three elements, which can save sapce usage.\nlocal function solve_iter(n, memo)\n    if n == 1 then\n        return 1\n    elseif n == 2 then\n        return 2\n    elseif memo[n] ~= nil then\n        return memo[n]\n    else\n        memo[n] = solve_iter(n - 1, memo) + solve_iter(n - 2, memo)\n        return memo[n]\n    end\nen","completion":""}
{"prompt":"-- Just convert to string\nlocal function _tick_formatter(value, _index, _tick_count)\n  return tostring(value)\nen","completion":""}
{"prompt":"-- The fibonacci function.\n-- Parameters\n-- ----------\n-- >>> fib(1)\n-- 1\n-- >>> fib(6)\n-- 8\nlocal function fib(n)\n    if n <= 1 then return n end\n    return fib(n-1) + fib(n-2)\nen","completion":""}
{"prompt":"-- Fibonacci Recursion uses naive recursion to calculate fibonacci(N)\n-- Performance is O(Really Bad) from deep call stacks on N > 30\nlocal function fibonacciNaiveRecursion(N)\n\tif N <= 1 then\n\t\treturn N\n\telse\n\t\treturn fibonacciNaiveRecursion(N - 1) + fibonacciNaiveRecursion(N - 2)\n\tend\nen","completion":""}
{"prompt":"-- parses string as float, ignores -- as 0\nlocal function parse_float(val)\n  val = string.gsub(val, \",\", \".\") -- replace , by .\n  val = tonumber(val) -- try to convert string to number\n  return (not val or val == 0) and 0 or val -- if 0, return 0, else return val\nen","completion":""}
{"prompt":"-- Warshall's Algorithm for Shortest Path\n-- Complexity: O(V^3)\n-- It produces the shortest paths between all the vertices.\nlocal function warshall(graph)\n\tlocal dist = graph\n\tfor i = 1, #dist do\n\t\tfor j = 1, #dist do\n\t\t\tfor k = 1, #dist do\n\t\t\t\tdist[j][k] = math.min(dist[j][k], dist[j][i] + dist[i][k])\n\t\t\tend\n\t\tend\n\tend\n\treturn dist\nen","completion":""}
{"prompt":"-- Compute the falling factorial of n to depth k.\n-- >>> falling(6, 3)  # 6 * 5 * 4\n-- 120\n-- >>> falling(4, 3)  # 4 * 3 * 2\n-- 24\n-- >>> falling(4, 1)  # 4\n-- 4\n-- >>> falling(4, 0)\n-- 1\nlocal function falling(n, k)\n  if k == 0 then\n    return 1\n  else\n    return n * falling(n-1, k-1)\n  end\nen","completion":""}
{"prompt":"-- Flatten a list of arbitrary depth. Returns a list with no sub-lists or sub-tuples.\n-- If the input is not a list or a tuple, it will be returned as a one-element list.\nlocal function flatten(x)\n    if type(x) == \"table\" then\n        if #x == 0 then\n            return x\n        else\n            local res = {}\n            for _,v in ipairs(x) do\n                for _,v in ipairs(flatten(v)) do\n                    table.insert(res, v)\n                end\n            end\n            return res\n        end\n    else\n        return {x}\n    end\nen","completion":""}
{"prompt":"-- Find the calculation type by the result.\n-- Examples:\n-- >>> assert calc_type(10, 2, 5) == 'division'\nlocal function calc_type(a, b, res)\n    if a * b == res then\n        return 'multiplication'\n    elseif a \/ b == res then\n        return 'division'\n    elseif a + b == res then\n        return 'addition'\n    elseif a - b == res then\n        return 'subtraction'\n    end\nen","completion":""}
{"prompt":"-- Parameters p4:amp, p5:cps\nlocal function wgpluck(instrument_number, function_number, iplk)\n\t-- TODO: Implement\n\t-- return\n\treturn true\nen","completion":""}
{"prompt":"-- :type A: List[List[int]]\n-- :type B: List[List[int]]\n-- :rtype: List[List[int]]\nlocal function multiply(multiplicand, multiplier)\n  local result = {}\n  for row = 1, #multiplicand do\n    local row_result = {}\n    for col = 1, #multiplier[1] do\n      local element_result = 0\n      for row_factor = 1, #multiplicand[1] do\n        element_result = element_result + multiplicand[row][row_factor] * multiplier[row_factor][col]\n      end\n      row_result[col] = element_result\n    end\n    result[row] = row_result\n  end\n  return result\nen","completion":""}
{"prompt":"-- This function calculates nCr using memoization method.\nlocal function combination_memo(n, r)\n    if n == r then\n        return 1\n    elseif r == 0 then\n        return 1\n    else\n        return combination_memo(n - 1, r - 1) + combination_memo(n - 1, r)\n    end\nen","completion":""}
{"prompt":"-- Functia returneaza, pentru un tip de paranteza inchisa, acelasi tip\n-- de paranteza dar deschisa.\n-- Astfel: ')' => '(', ']' => '['.\nlocal function paranteza_deschisa(paranteza)\n  return paranteza == ')' and '(' or\n         paranteza == ']' and '['\nen","completion":""}
{"prompt":"-- Build a range of years from start to stop, given a specific increment\n-- Args:\n-- start (int): starting year\n-- stop (int): ending year\n-- increment (int): number of years in one time series\n-- Returns:\n-- year_increments (list): list of tuples, each containing one time series\nlocal function build_increments(start, stop, increment)\n    -- check start and stop arguments\n    assert(type(start) == 'number', 'start must be a number')\n    assert(type(stop) == 'number', 'stop must be a number')\n    -- initialize variables\n    local year_increments = {}\n    local current_start = start\n    local current_stop = current_start + increment - 1\n    -- ensure the stop value is not less than the start value\n    if current_stop < current_start then current_stop = current_start end\n    while current_stop <= stop do\n        table.insert(year_increments, {current_start, current_stop})\n        current_start = current_stop + 1\n        current_stop = current_start + increment - 1\n        -- ensure the stop value is not less than the start value\n        if current_stop < current_start then current_stop = current_start end\n    end\n    return year_increments\nen","completion":""}
{"prompt":"-- Returns the max subarray of the given list of numbers.\n-- Returns 0 if  nums is None or an empty list.\n-- Time Complexity: O(n)\n-- Space Complexity: O(1)\nlocal function max_sub_array(nums)\n    if nums == nil or #nums == 0 then\n        return 0\n    end\n    local max_so_far = nums[1]\n    local max_ending_here = nums[1]\n    for i = 2, #nums do\n        max_ending_here = math.max(max_ending_here + nums[i], nums[i])\n        max_so_far = math.max(max_so_far, max_ending_here)\n    end\n    return max_so_far\nen","completion":""}
{"prompt":"-- trick for speed up cartpole training\n-- if done, which means agent died, set negtive reward,\n-- which help agent learn control method faster.\nlocal function trick_for_cartpole(done, reward)\n  if done then\n    return -100\n  end\n  return reward\nen","completion":""}
{"prompt":"-- >>> validate_mapping(None, None, [('episode', 'TV Show'), ('movie', 'Movie')])\n-- [('episode', 'TV Show'), ('movie', 'Movie')]\n-- >>> validate_mapping(None, None, [('wrong', 'TV Show'), ('movie', 'Movie')])  # doctest: +ELLIPSIS\n-- Traceback (most recent call last):\n-- ...\n-- ValueError: mappings must be any of ... and not 'wrong'\nlocal function validate_mapping(_, __, values)\n  return values\nen","completion":""}
{"prompt":"-- assumes x an int >= 0\n-- returns Fibonacci of x\nlocal function fib(x)\n  if x == 0 or x == 1 then\n    return 1\n  end\n  return fib(x-1) + fib(x-2)\nen","completion":""}
{"prompt":"-- Convert C temp to F\n-- param temp: temp in C to convert\n-- return: float\nlocal function _convert_to_F(temp)\n  return (temp * 9) \/ 5 + 32\nen","completion":""}
{"prompt":"-- Return an m-by-n arrayList consisting of all ones.\n-- >>> ones(2,3)\n-- [[1, 1, 1], [1, 1, 1]]\nlocal function ones(m, n)\n    local arr = {}\n    for i = 1, m do\n        local temp = {}\n        for j = 1, n do\n            temp[j] = 1\n        end\n        arr[i] = temp\n    end\n    return arr\nen","completion":""}
{"prompt":"-- Bonferrnoi correction.\n-- en.wikipedia.org\/wiki\/Bonferroni_correction\n-- Parameters\n-- ----------\n-- alpha_orig : float\n-- alpha value before correction\n-- p_values: list[float]\n-- p values resulting from all the tests\n-- Returns\n-- -------\n-- alpha_corrected: float\n-- new critical value (i.e. the corrected alpha)\nlocal function bonferroni(alpha_orig, p_values)\n    local alpha = alpha_orig \/ #p_values\n    return alpha\nen","completion":""}
{"prompt":"-- Returns the launch movement distance for given speed and time in ms.\nlocal function launch_distance(speed, duration)\n    local distance = 0\n    if duration > 0 and speed > 0 then\n        distance = math.sqrt((2 * math.abs(speed) * duration) \/ 9.81)\n    end\n    return distance\nen","completion":""}
{"prompt":"-- Return a\/b rounded up to nearest integer,\n-- equivalent result to int(math.ceil(float(int(a)) \/ float(int(b))), only\n-- without possible floating point accuracy errors.\nlocal function div_roundup(a, b)\n  return math.ceil(a \/ b)\nen","completion":""}
{"prompt":"-- Converts temperature from kelvin to fahrenheit.\n-- Args:\n-- temperature: temperature to be converted.\n-- Returns:\n-- temperature converted from kelvin to fahrenheit.\nlocal function kelvin_to_fahrenheit(temperature)\n  return math.ceil((temperature - 273.15) * (9 \/ 5) + 32)\nen","completion":""}
{"prompt":"-- Fib without recursion.\nlocal function fib(n)\n\tlocal n1, n2 = 1, 1\n\twhile n > 0 do\n\t\tn1, n2 = n2, n1 + n2\n\t\tn = n - 1\n\tend\n\treturn n1\nen","completion":""}
{"prompt":"-- Replace the Latex command \"\\textit{<argument>}\" with just \n-- argument\nlocal function italReplacements(tex)\n  tex = tex:gsub(\"\\\\textit{\", \"\"):gsub(\"}\", \"\")\n  return tex\nen","completion":""}
{"prompt":"-- for unclear reasons, google replaces url escapes with \\x escapes\nlocal function unescape(url)\n    return (url:gsub(\"\\\\x%x\", string.char))\nen","completion":""}
{"prompt":"-- Split a string on separator, ignoring ones escaped by backslashes.\nlocal function split_escaped(string, separator)\n    local escaped = false\n    local escaped_string = \"\"\n    local split_string = {}\n    for i = 1, #string do\n        local c = string:sub(i, i)\n        if escaped then\n            escaped_string = escaped_string .. c\n            escaped = false\n        else\n            if c == \"\\\\\" then\n                escaped = true\n            elseif c == separator then\n                table.insert(split_string, escaped_string)\n                escaped_string = \"\"\n            else\n                escaped_string = escaped_string .. c\n            end\n        end\n    end\n    table.insert(split_string, escaped_string)\n    return split_string\nen","completion":""}
{"prompt":"-- Normalize all occurences of Alef Maksura characters to a Yeh character\n-- in an Arabic string.\n-- Args:\n-- s (:obj:`str`): The string to be normalized.\n-- Returns:\n-- :obj:`str`: The normalized string.\nlocal function normalize_alef_maksura_ar(s)\n  return string.gsub(s, '\\u{0649}', '\\u{064A}')\nen","completion":""}
{"prompt":"-- Total incoming shortwave radiation.\n-- Parameters\n-- ----------\n-- rs : numpy ndarray\n-- Total incoming shortwave solar radiation, in MegaJoules per square meter per day\n-- albedo : numpy ndarray\n-- Shortwave blue-sky albedo, unitless\nlocal function calc_rns(rs, albedo)\n    return rs * (1-albedo)\nen","completion":""}
{"prompt":"-- Wrap all non-list or tuple objects in a list.\n-- Provides a simple way to accept flexible arguments.\nlocal function listify(obj)\n  if obj == nil then return {} end\n  if type(obj) ~= 'table' then return { obj } end\n  return obj\nen","completion":""}
{"prompt":"-- Finding factorial recursively\nlocal function fact_recur(n)\n  if n < 2 then\n    return 1\n  else\n    return n * fact_recur(n - 1)\n  end\nend\nprint(fact_recur(5)) --> 12","completion":""}
{"prompt":"-- (str)-int\n-- return number of vowels in s.\n-- >>> count_vowels('The quick brown fox')\n-- 5\nlocal function count_vowels(s)\n  if not s then return 0 end\n  s = s:lower()\n  local count = 0\n  for c in s:gmatch('%a') do\n    if c == 'a' or c == 'e' or c == 'i' or c == 'o' or c == 'u' then count = count + 1 end\n  end\n  return count\nen","completion":""}
{"prompt":"-- Returns the longest common substring from the beginning of sa and sb\nlocal function common_start(sa, sb)\n  for i = 1, #sa do\n    if i > #sb or sa:sub(i, i) ~= sb:sub(i, i) then\n      return sa:sub(1, i - 1)\n    end\n  end\n  return sa\nen","completion":""}
{"prompt":"-- Elevation gain per km\nlocal function elevation_gain(altitudes, distance, threshold)\n\tlocal gain = 0\n\tlocal threshold = threshold or 20\n\tfor i = 2, #altitudes do\n\t\tlocal diff = altitudes[i] - altitudes[i - 1]\n\t\tif diff > threshold then\n\t\t\tgain = gain + diff\n\t\t\tif i < #altitudes then\n\t\t\t\tgain = gain + elevation_gain({altitudes[i + 1]}, distance \/ 2)\n\t\t\tend\n\t\tend\n\tend\n\treturn gain\nen","completion":""}
{"prompt":"-- :lerp: linear interpolation function for traversing a gradient\n-- :param channel1:     int | the rgb channel for the starting color in the gradient.\n-- :param channel2:     int | the rgb channel for the ending color in the gradient.\n-- :param current_step: int | the current step (block) in the gradient.\n-- :param total_steps:  int | the total number of steps (blocks) in the gradient.\n-- :return:             int | the rgb channel value for the next color in the gradient.\nlocal function lerp(channel1, channel2, current_step, total_steps)\n    return math.floor(channel1 + (channel2 - channel1) * ((current_step) \/ total_steps))\nen","completion":""}
{"prompt":"-- Find the difference between sum of squares and square of sum for the first\n-- `num` natural numbers.\n-- Args:\n-- num (int): First natural numbers.\n-- Returns:\n-- int: Difference.\nlocal function find_difference_sum_of_squares_and_square_of_sum(num)\n  local sum_of_squares = 0\n  local square_of_sum = 0\n  for i = 1, num do\n    sum_of_squares = sum_of_squares + i * i\n    square_of_sum = square_of_sum + i\n  end\n  return square_of_sum * square_of_sum - sum_of_squares\nen","completion":""}
{"prompt":"-- :param budget: float - the amount of your money you are planning to exchange.\n-- :param exchange_rate: float - the unit value of the foreign currency.\n-- :param spread: int - percentage that is taken as an exchange fee.\n-- :param denomination: int - the value of a single bill.\n-- :return: int - maximum value you can get\nlocal function exchangeable_value(budget, exchange_rate, spread, denomination)\n    local value = math.floor((budget \/ exchange_rate) * (1 - (spread \/ 100)))\n    return math.floor(value \/ denomination) * denomination\nen","completion":""}
{"prompt":"-- Return greatest common divisor using Euclid's Algorithm.\nlocal function gcd(num1, num2)\n  return num2 == 0 and num1 or gcd(num2, num1 % num2)\nen","completion":""}
{"prompt":"-- Returns the roots of a linear equation: ax+ b = 0.\n-- INPUTS\n-- =======\n-- a: float, optional, default value is 1\n-- Coefficient of linear term\n-- b: float, optional, default value is 0\n-- Coefficient of constant term\n-- RETURNS\n-- ========\n-- roots: 1-tuple of real floats\n-- Has the form (root) unless a = 0 \n-- in which case a ValueError exception is raised\n-- EXAMPLES\n-- =========\n-- >>> linear_roots(1.0, 2.0)\n-- -2.0\nlocal function linear_roots(a, b)\n  -- Check for inputs\n  if a == nil then a = 1 end\n  if b == nil then b = 0 end\n  -- Special case for when a = 0\n  if a == 0 then\n    raise(ValueError(\"No real roots.\"))\n  else\n    return (-b \/ a)\n  end\nen","completion":""}
{"prompt":"-- a function that takes a simple list of numbers lst as a parameter and returns a list with the min, max, and the median of lst.\nlocal function min_max_median(lst)\n  --[[\n    local min = math.huge\n    local max = -math.huge\n    local sum = 0\n    for i = 1, #lst do\n      sum = sum + lst[i]\n      if lst[i] < min then\n        min = lst[i]\n      end\n      if lst[i] > max then\n        max = lst[i]\n      end\n    end\n    return {min, max, sum\/#lst}\n  ]]\n  local min, max, sum = lst[#lst], lst[1], 0\n  for i = 1, #lst do\n    sum = sum + lst[i]\n    if lst[i] < min then\n      min = lst[i]\n    end\n    if lst[i] > max then\n      max = lst[i]\n    end\n  end\n  table.sort(lst)\n  local median\n  if #lst % 2 == 0 then\n    median = (lst[#lst\/2] + lst[#lst\/2 + 1])\/2\n  else\n    median = lst[(#lst + 1)\/2]\n  end\n  return {min, max, median}\nen","completion":""}
{"prompt":"-- Convert Fahrenheit to Kelvin\nlocal function convert_f_to_k(temperature_f)\n    if temperature_f then\n        return (temperature_f - 32) * (5\/9) + 273.15\n    end\nen","completion":""}
{"prompt":"-- Convert digraph to a graph.\n-- :param digraph: A directed graph in the form\n-- {from:{to:value}}.\n-- :param prime_node_mapping: A mapping from every\n-- node in digraph to a new unique and not in digraph node.\n-- :return: A symmetric graph in the form {from:to:value}} created by\n-- creating edges in the result between every N to M-prime with the\n-- original N-M value and from every N to N-prime with a cost of 0.\n-- No other edges are created.\nlocal function _digraph_to_graph(digraph, prime_node_mapping)\n    local graph = {}\n    for from, to_dict in pairs(digraph) do\n        local from_prime = prime_node_mapping[from]\n        for to, value in pairs(to_dict) do\n            local to_prime = prime_node_mapping[to]\n            if from_prime ~= to_prime then\n                if graph[from_prime] == nil then\n                    graph[from_prime] = {}\n                end\n                graph[from_prime][to_prime] = value\n            end\n        end\n    end\n    for node, to_dict in pairs(graph) do\n        to_dict[node] = 0\n    end\n    return graph\nen","completion":""}
{"prompt":"-- @return Returns midpoint index from \"left side\" or \"left half\" if there's an\n-- even number of elements.\nlocal function quick_calculate_midpoint_index(l, r)\n  return math.floor((l + r) \/ 2)\nen","completion":""}
{"prompt":"-- Adds two 3d vectors.\n-- v1, v2 (3-tuple): 3d vectors\n-- return (3-tuple): 3d vector\nlocal function vect3_add(v1, v2)\n  return {v1[1] + v2[1], v1[2] + v2[2], v1[3] + v2[3]}\nen","completion":""}
{"prompt":"-- Extract 16 bits page id from full usage id (32 bits)\nlocal function get_usage_page_id(full_usage_id)\n  return bit32.band(bit32.rshift(full_usage_id, 16), 0xFFFF)\nen","completion":""}
{"prompt":"-- Returns the max subarray of the given list of numbers.\n-- Returns 0 if  nums is None or an empty list.\n-- Time Complexity: O(n)\n-- Space Complexity: O(1)\nlocal function max_sub_array(nums)\n    -- check if nums is not empty\n    if nums == nil or #nums == 0 then\n        return 0\n    end\n    local current_max = nums[1]\n    local overall_max = current_max\n    for i=2,#nums do\n        local new_num = current_max + nums[i]\n        if new_num > nums[i] then\n            current_max = new_num\n        else\n            current_max = nums[i]\n        end\n        if current_max > overall_max then\n            overall_max = current_max\n        end\n    end\n    return overall_max\nen","completion":""}
{"prompt":"-- >>> greatest_common_divisor(7, 5)\n-- 1\nlocal function greatest_common_divisor(a, b)\n  while b ~= 0 do\n    a, b = b, a % b\n  end\n  return a\nen","completion":""}
{"prompt":"-- Get the array of digits for n\nlocal function get_digits(n)\n    local digits = {}\n    while n ~= 0 do\n        digits[#digits + 1] = n % 10\n        n = math.floor(n \/ 10)\n    end\n    return digits\nen","completion":""}
{"prompt":"-- Check for annotations that do not have the `bbox` property.\n-- Returns:\n-- A list of annotations without bounding boxes.\nlocal function check_for_annotations_without_boxes(dataset, remove_boxes)\n   local empty_annotations = {}\n   local annotations = {}\n   for _, annotation in pairs(dataset.annotations) do\n      if annotation.bbox then\n         table.insert(annotations, annotation)\n      else\n         table.insert(empty_annotations, annotation)\n      end\n   end\n   if remove_boxes then\n      dataset.annotations = annotations\n   end\n   return empty_annotations\nen","completion":""}
{"prompt":"-- Count the number of vowels (aeiou) in the given string.\nlocal function count_vowels(entry)\n    local cnt = 0\n    for i = 1, #entry do\n        local c = string.sub(entry, i, i)\n        if c == \"a\" or c == \"e\" or c == \"i\" or c == \"o\" or c == \"u\" then\n            cnt = cnt + 1\n        end\n    end\n    return cnt\nen","completion":""}
{"prompt":"-- Remove empty lines from a string.\nlocal function remove_empty_lines(s)\n\tlocal lines = {}\n\tfor line in s:gmatch(\"[^\\r\\n]+\") do\n\t\tif line ~= \"\" then\n\t\t\ttable.insert(lines, line)\n\t\tend\n\tend\n\treturn table.concat(lines, \"\\n\")\nen","completion":""}
{"prompt":"-- Returns the value type of data item from MXElectrix data message.\n-- The value type is taken to be everything before opening bracket [.\nlocal function parseValue(formatString)\n    local index = formatString:find(\"%[\")\n    if index then\n        return formatString:sub(1,index-1)\n    else\n        return formatString\n    end\nen","completion":""}
{"prompt":"-- Mensagem privada ou mensagem de grupo\nlocal function msg_origin(msg)\n  local origin = 'private'\n  local chat_type = msg.chat.type\n  if chat_type == 'private' then\n    origin = 'private'\n  elseif chat_type == 'supergroup' or chat_type == 'group' then\n    origin = 'group'\n  end\n  return origin\nen","completion":""}
{"prompt":"-- Prettily format a peername tuple (host, port)\nlocal function pp_peername(peername)\n\treturn (peername[1] or \"nil\") .. \":\" .. (peername[2] or 0)\nen","completion":""}
{"prompt":"-- A simpler (sorta...) method to BeautifulSoup.find_all\n-- :param soup: A BeautifulSoup object\n-- :param first: The first item to search for. Example: div\n-- :param second: the second aspect to search for. The key in the key:value pair. Example: class\n-- :param third: The third aspect, which is the value in the key: value pair. Example: <class-name>\n-- Example:\n-- BeautifulSoup(<url>,<parser>).find_all(\"div\", {\"class\": <\"classname\">})\n-- is simplifed with this method by using:\n-- results = common.find_all(soup_obj, \"div\", \"class\", \"<classname>\")\n-- :return: a list of items found by the search.\nlocal function find_all(soup, first, second, third)\n  if not soup then\n    return\n  end\n  local items = {}\n  for _, item in pairs(soup:find_all(first)) do\n    if item[second] and item[second] == third then\n      table.insert(items, item)\n    end\n  end\n  return items\nen","completion":""}
{"prompt":"-- Passed a TCP flags object (hex) and return 1 if it\n-- contains a TCP SYN and no other flags\nlocal function _is_tcp_syn(tcp_flags)\n    return tcp_flags == 2 and 1 or 0\nen","completion":""}
{"prompt":"-- Returns the result of scaling value from the range\n-- [start_min, start_max] to [end_min, end_max].\nlocal function scale(value, start_min, start_max, end_min, end_max)\n  return end_min + (value - start_min) * (end_max - end_min) \/ (start_max - start_min)\nen","completion":""}
{"prompt":"-- Return the itemsPerPage object from a Google Analytics API request.\n-- :param results: Google Analytics API results set\n-- :return: Number of items per page (default is 1000 if not set, max is 10000)\nlocal function get_items_per_page(results)\n\treturn results['itemsPerPage'] or 1000\nen","completion":""}
{"prompt":"-- Compute the L2 loss function.\n-- Return the square difference between the inputs.\n-- https:\/\/www.bitlog.com\/knowledge-base\/machine-learning\/loss-function\/#l2-error\n-- Parameters\n-- ----------\n-- x : float\n-- The estimate\n-- y : float\n-- The actual value\nlocal function l2_loss(x, y)\n    local squared_difference = x - y\n    return squared_difference * squared_difference\nen","completion":""}
{"prompt":"-- Returns year digits , given year\nlocal function getYearDigits(a_year)\n\treturn tonumber(tostring(a_year):sub(-2))\nen","completion":""}
{"prompt":"-- Compute x to the power of n (with n>=0)\nlocal function power(x, n)\n    if n == 0 then\n        return 1\n    elseif n == 1 then\n        return x\n    else\n        return x * power(x, n-1)\n    end\nen","completion":""}
{"prompt":"-- Given a string |text|, return the word in |text| that comes last\n-- alphabetically (that is, the word that would appear last in a dictionary).\n-- A word is defined by a maximal sequence of characters without whitespaces.\n-- You may assume the input only consists of lowercase letters and whitespaces.\n-- You might find max() and list comprehensions handy here.\nlocal function findAlphabeticallyLastWord(text)\n    -- write your solution here\n    local word_list = {}\n    for word in text:gmatch(\"([^%s]+)\") do\n        table.insert(word_list, word)\n    end\n    table.sort(word_list)\n    return word_list[#word_list]\nen","completion":""}
{"prompt":"-- This code was modified from the fib code in the python3 functools\n-- documentation.\nlocal function real_fib(n)\n\tif (n == 0) then\n\t\treturn 0\n\telseif (n == 1) then\n\t\treturn 1\n\telse\n\t\treturn real_fib(n - 1) + real_fib(n - 2)\n\tend\nen","completion":""}
{"prompt":"-- Convert a character index to word index in the given sentence.\nlocal function char_to_word_index(char_ind, sent)\n  local s = sent:sub(1, char_ind)\n  local wc = 0\n  for i = 1, #s do\n    if s:sub(i, i) == \" \" then\n      wc = wc + 1\n    end\n  end\n  return wc\nen","completion":""}
{"prompt":"-- Use this function to get CPU usage\nlocal function fibonacci(n)\n   if n < 2 then\n      return n\n   else\n      return fibonacci(n-1) + fibonacci(n-2)\n   end\nen","completion":""}
{"prompt":"-- Strip trailing slash if present on link.\n-- Parameters\n-- ----------\n-- link : str\n-- URL from code sharing website\n-- Returns\n-- -------\n-- str\n-- Returns value of `link` without trailing slash.\n-- Example\n-- -------\n-- >>> _clean_link(\"https:\/\/gist.github.com\/randyzwitch\/be8c5e9fb5b8e7b046afebcac12e5087\/\")\n-- 'https:\/\/gist.github.com\/randyzwitch\/be8c5e9fb5b8e7b046afebcac12e5087'\n-- >>> _clean_link(\"https:\/\/gist.github.com\/randyzwitch\/be8c5e9fb5b8e7b046afebcac12e5087\")\n-- 'https:\/\/gist.github.com\/randyzwitch\/be8c5e9fb5b8e7b046afebcac12e5087'\nlocal function _clean_link(link)\n  return string.gsub(link, \"\/$\", \"\")\nen","completion":""}
{"prompt":"-- Doing the math for getting total value of the cart.\n-- :param base_price: Base price of the product\n-- :param artist_markup: Artist markup value from the cart.\n-- :param quantity: Quntity from the cart.\n-- :return: Price of the product\nlocal function calculate(base_price, artist_markup, quantity)\n  local price = base_price\n  price = price * (100 + artist_markup) \/ 100\n  return math.floor(price * quantity)\nen","completion":""}
{"prompt":"-- Return float as int but raise if decimal is dropped.\nlocal function float_to_int(i)\n  local int = math.floor(i)\n  if i ~= int then\n    error(\"decimal lost in conversion to int: \"..i)\n  end\n  return int\nen","completion":""}
{"prompt":"-- Turns a multi-line string into a single.\n-- Some platforms use CR and LF, others use only LF, so we first replace CR and LF together and then LF to avoid\n-- adding multiple spaces.\n-- :param string: The string to convert.\n-- :return: The converted string.\nlocal function single_line(string)\n    string = string:gsub(\"\\r\\n\", \"\\n\")\n    return string:gsub(\"\\n\", \" \")\nen","completion":""}
{"prompt":"-- Given a grid of unnormalized probabilities, computes the\n-- correspond normalized version of that grid.\nlocal function normalize(grid)\n  local sum = 0\n  for i,row in ipairs(grid) do\n    for j,col in ipairs(row) do\n      sum = sum + col\n    end\n  end\n  for i,row in ipairs(grid) do\n    for j,col in ipairs(row) do\n      grid[i][j] = col\/sum\n    end\n  end\n  return grid\nen","completion":""}
{"prompt":"-- Returns the length (number of letters) in the current hand.\n-- hand: dictionary (string-> int)\n-- returns: integer\nlocal function calculateHandlen(hand)\n    local len = 0\n    for _, _ in pairs(hand) do\n        len = len + 1\n    end\n    return len\nen","completion":""}
{"prompt":"-- Evaluate a polynomial in one variable.\nlocal function poly1d(x, coefs)\n   local y = 0\n   for i = #coefs, 1, -1 do\n      y = x * y + coefs[i]\n   end\n   return y\nen","completion":""}
{"prompt":"-- Return the sum of the digits of the specified number squared.\nlocal function square_of_digits(number)\n  local number_string = tostring(number)\n  local squared = 0\n  for i = 1, #number_string do squared = squared + (number_string:sub(i, i) * number_string:sub(i, i)) end\n  return squared\nen","completion":""}
{"prompt":"-- Returns the value of the upper nibble (4 bits) of a byte (i.e. a value in range 0-15)\nlocal function upper_nibble(value)\n\treturn (value & 0xF0) >> 4\nen","completion":""}
{"prompt":"-- Find how many ways to reach.\nlocal function climbing_stairs(n)\n  if n < 3 then\n    return n\n  else\n    return climbing_stairs(n - 1) + climbing_stairs(n - 2)\n  end\nen","completion":""}
{"prompt":"-- Given a transition represented as ((Q,symb),Q'), \n-- return symb.\nlocal function trSymb(transition)\n   return transition[1][2]\nen","completion":""}
{"prompt":"-- This method returns a list of rotations for a string T\nlocal function rotations(T)\n  -- Create a table to store the rotations\n  local r = {}\n  -- Go through all possible rotations\n  for i = 1, #T do\n    -- Push the rotation to the table\n    table.insert(r, T:sub(i, #T) .. T:sub(1, i-1))\n  end\n  -- Return the rotations\n  return r\nen","completion":""}
{"prompt":"-- Returns the final component of a pathname.\nlocal function _Basename(path)\n\tlocal name = string.gsub(path, \"(.*\/)(.*)\", \"%2\")\n\treturn name\nen","completion":""}
{"prompt":"-- Puts value into a list if it's not already one.\n-- Returns an empty list if value is None.\nlocal function to_list(value)\n  if value then\n    if type(value) == \"table\" then\n      return value\n    else\n      return {value}\n    end\n  else\n    return {}\n  end\nen","completion":""}
{"prompt":"-- Formats a float value to be as short as possible.\n-- Trims extraneous trailing zeros and period to give API\n-- args the best possible chance of fitting within 2000 char\n-- URL length restrictions.\n-- For example:\n-- format_float(40) -> \"40\"\n-- format_float(40.0) -> \"40\"\n-- format_float(40.1) -> \"40.1\"\n-- format_float(40.001) -> \"40.001\"\n-- format_float(40.0010) -> \"40.001\"\n-- :param arg: The lat or lng float.\n-- :type arg: float\n-- :rtype: string\nlocal function _format_float(arg)\n  local result = arg\n  if arg then\n    local num = tonumber(arg)\n    if num then\n      if num == num then\n        result = string.format(\"%.6f\", num)\n        result = string.gsub(result, \"%.?0+$\", \"\")\n        result = string.gsub(result, \"%.$\", \"\")\n      end\n    end\n  end\n  return result\nen","completion":""}
{"prompt":"-- returns a string, but as a list, with one\n-- character per index\nlocal function explode(s)\n  local r = {}\n  for i = 1, string.len(s) do\n    r[i] = string.sub(s, i, i)\n  end\n  return r\nen","completion":""}
{"prompt":"-- Escape control characters in regular expressions.\nlocal function esc_control_characters(regex)\n  return regex:gsub('[%c]', '%%%0')\nen","completion":""}
{"prompt":"-- We store (almost) whatever number the user provided but massage it later.\nlocal function sanitise_phone_number(val)\n\tlocal number = tostring(val)\n\tnumber = number:gsub(\"^00\", \"+\")\n\tnumber = number:gsub(\"^0\", \"+44\")\n\treturn number\nen","completion":""}
{"prompt":"-- Linearize sRGB color\nlocal function _from_sRGB(component)\n\tcomponent = math.max(0, math.min(component, 1))\n\tif component < 0.04045 then\n\t\tcomponent = component\/12.92\n\telse\n\t\tcomponent = ((component+0.055)\/1.055)^2.4\n\tend\n\treturn component\nen","completion":""}
{"prompt":"-- Returns the circular distance between two points on a unit circle. The\n-- points `x` and `y` must be given by their angle (in degree) on the unit\n-- circle.\n-- >>> cdist(90.0, 350.0)\n-- 100.0\n-- >>> cdist(90.0, 260.0)\n-- 170.0\n-- >>> cdist(90.0, 280.0)\n-- 170.0\n-- >>> cdist(-20.0, 270.0)\n-- 70.0\nlocal function cdist(x, y)\n    local dx = math.abs(x - y) % 360.0\n    if dx > 180.0 then\n        dx = 360.0 - dx\n    end\n    return dx\nen","completion":""}
{"prompt":"-- Computes Amdal's Law speed-up\n-- :param x: is the speedup of the part of the task that benefits from improved system resources\n-- :param p: is the proportion of execution time that the part benefiting from improved resources originally occupied\n-- :return: the computed speed-up\nlocal function amdahls(x, p)\n\treturn x + (1-x)*(1-p)\nen","completion":""}
{"prompt":"-- Rounds the `value` to the nearest multiple of `multiple`.\n-- Returns the result.\nlocal function roundToMultiple(value, multiple)\n  return math.floor(value \/ multiple + 0.5) * multiple\nen","completion":""}
{"prompt":"-- Dimensionless production rate for a gene regulated by two\n-- repressors with AND logic in the absence of leakage with\n-- single occupancy.\n-- Parameters\n-- ----------\n-- x : float or NumPy array\n-- Concentration of first repressor.\n-- y : float or NumPy array\n-- Concentration of second repressor.\n-- nx : float\n-- Hill coefficient for first repressor.\n-- ny : float\n-- Hill coefficient for second repressor.\n-- Returns\n-- -------\n-- output : NumPy array or float\n-- 1 \/ (1 + x**nx + y**ny)\nlocal function rr_and_single(x, y, nx, ny)\n    return 1. \/ (1. + x^nx + y^ny)\nen","completion":""}
{"prompt":"-- Truncar un numero float\nlocal function dtrunc(x)\n\treturn x>=0 and math.floor(x) or math.ceil(x)\nen","completion":""}
{"prompt":"-- This functions escapes an unescaped HTML string.\n-- Args:\n-- unescaped_html_data: str. Unescaped HTML string to be escaped.\n-- Returns:\n-- str. Escaped HTML string.\nlocal function escape_html(unescaped_html_data)\n  return tostring(unescaped_html_data):gsub('&', '&amp;'):gsub('\"', '&quot;'):gsub(\"'\", '&#39;'):gsub('<', '&lt;'):gsub('>', '&gt;')\nen","completion":""}
{"prompt":"-- Helper to make versionId kwargs.\n-- Not all boto3 methods accept a None \/ empty versionId so dictionary expansion solves\n-- that problem.\nlocal function version_id_kw(version_id)\n  if version_id == nil or version_id == \"\" then\n    return {}\n  end\n  return {VersionId = version_id}\nen","completion":""}
{"prompt":"-- Get the filename from a URL.\n-- Args:\n-- url (str): URL\n-- Returns:\n-- str: Filename of the URL.\nlocal function get_filename_from_url(url)\n  local match = url:match(\"[^\/]*$\")\n  if match then\n    return match\n  else\n    return \"\"\n  end\nen","completion":""}
{"prompt":"-- Produce a function to shift black (base) point.\n-- Return a function that maps all values from [0.0,m] to 0, and maps\n-- the range [m,1.0] into [0.0, 1.0] linearly.\nlocal function blackshift(m)\n  return function(x)\n    if x <= m then\n      return 0.0\n    else\n      return ((x - m) \/ (1.0 - m))\n    end\n  end\nen","completion":""}
{"prompt":"-- Returns the length of the second element of a sequence.\n-- This function is used to sort sentence pairs by the length of the\n-- target sentence.\nlocal function _source_length(sentence_pair)\n  return #sentence_pair[2]\nen","completion":""}
{"prompt":"-- Converts fahrenheit to celsius.\n-- :param fahrenheit: temperature in fahrenheit.\n-- :return: temperature in celsius\nlocal function fahrenheit_to_celsius(fahrenheit)\n  return (fahrenheit - 32) * 5 \/ 9\nen","completion":""}
{"prompt":"-- Converts an array of key\/values seperated by = to dict\nlocal function equals_list2dict(equals_list)\n  local dict = {}\n  if equals_list then\n    for _, entry in pairs(equals_list) do\n      local key, value = string.match(entry, \"(.*)=(.*)\")\n      dict[key] = value\n    end\n  end\n  return dict\nen","completion":""}
{"prompt":"-- API data has duplicate transaction data.  Clean it.\nlocal function _remove_dups(elems)\n  local new_elems = {}\n  local seen_elems = {}\n  for i = 1, #elems do\n    if not seen_elems[elems[i].txhash] then\n      new_elems[#new_elems + 1] = elems[i]\n      seen_elems[elems[i].txhash] = true\n    end\n  end\n  return new_elems\nen","completion":""}
{"prompt":"-- Get variable annotations in a class, inheriting from superclasses.\nlocal function get_class_annotations(cls)\n  local annotations = {}\n  while cls ~= nil do\n    if cls.annotations ~= nil then\n      for name, annotation in pairs(cls.annotations) do\n        annotations[name] = annotation\n      end\n    end\n    cls = cls.super\n  end\n  return annotations\nen","completion":""}
{"prompt":"-- Strips the message name from errors to make them more readable.\nlocal function _adjust_error(error)\n  local error_str = tostring(error)\n  local error_name = string.match(error_str, \"^.-: (.+)$\")\n  if error_name then\n    return error_name\n  end\n  return error_str\nen","completion":""}
{"prompt":"-- Returns the area of a rectangle\nlocal function rectangle_area(base, height)\n  return base * height\nen","completion":""}
{"prompt":"-- Like ReLu, but smoother\n-- Like GeLu, but cheaper\nlocal function relu3(x)\n  return math.min(math.max(0, x), 3)\nen","completion":""}
{"prompt":"-- Return input string as int or float if possible, otherwise return string.\nlocal function num(s)\n\tif s == nil then\n\t\treturn s\n\tend\n\tlocal f = tonumber(s)\n\tif f then\n\t\treturn f\n\tend\n\treturn s\nen","completion":""}
{"prompt":"-- Return the harmonic mean of two numbers.\nlocal function hmean(a, b)\n    return 2 \/ (1\/a + 1\/b)\nen","completion":""}
{"prompt":"-- Ensure the dot separated class name (zinc reported class not found may use '\/' separator)\nlocal function normalize_classname(classname)\n\treturn string.gsub(classname, '\/', '.')\nen","completion":""}
{"prompt":"-- Go to the next upper tap position\nlocal function tap_down(tap, min_tap)\n  if tap > min_tap then\n    return tap - 1\n  else\n    return tap\n  end\nen","completion":""}
{"prompt":"-- 'snake_case_name' -> ['snake', 'case', 'name']\nlocal function split_snake_case_name_to_words(name)\n  local words = {}\n  for word in name:gmatch('(%w+)') do\n    words[#words + 1] = word\n  end\n  return words\nen","completion":""}
{"prompt":"-- Problem 2: Calculates the sum of all even terms in Fibonacci sequence below limit.\n-- Args:\n-- limit (int): The limit below which even numbers are summed.\nlocal function problem_02_fibonacci_sum(limit)\n  local sum = 0\n  local previous_number, current_number = 1, 1\n  while current_number < limit do\n    if current_number % 2 == 0 then\n      sum = sum + current_number\n    end\n    previous_number, current_number = current_number, current_number + previous_number\n  end\n  return sum\nen","completion":""}
{"prompt":"-- Sorts elements by 's'\nlocal function zsort(eles)\n    table.sort(eles, function(a,b) return a.s < b.s end)\n    return eles\nen","completion":""}
{"prompt":"-- Build the Subscription primary key for the given guid and event\nlocal function to_subscription_key(uid, event)\n  return string.format('%s_%s', uid, event)\nen","completion":""}
{"prompt":"-- Validates that a probability is between 0 and 1 inclusively.\n-- Args:\n-- p: The value to validate.\n-- p_str: What to call the probability in error messages.\n-- Returns:\n-- The probability p if the probability if valid.\n-- Raises:\n-- ValueError if the probability is invalid.\nlocal function validate_probability(p, p_str)\n    if p < 0 or p > 1 then\n        error(string.format('Invalid %s: %f, must be between 0 and 1', p_str, p))\n    end\n    return p\nen","completion":""}
{"prompt":"-- Compute the prefactor at the energy escale knowing\n-- the flux and index between emin and emax\nlocal function Prefactor(flux, index, emin, emax, escale)\n    local prefactor = 0\n    if emin <= escale and escale <= emax then\n        prefactor = flux * (escale - emin)^index \/ (emax - emin)^(index + 1)\n    end\n    return prefactor\nen","completion":""}
{"prompt":"-- Get python executable\n-- Args:\n-- py_num(float): Python version X.Y\n-- Returns:\n-- str: python executable\nlocal function get_python_exec(py_num)\n\tlocal py_exec = \"python\"\n\tif py_num >= 3.0 then\n\t\tpy_exec = \"python3\"\n\tend\n\treturn py_exec\nen","completion":""}
{"prompt":"-- Given an original dictionary orig, return a cloned dictionary with `k` set to `v`\nlocal function assoc(k, v, orig)\n  local new = {}\n  for key, value in pairs(orig) do\n    new[key] = value\n  end\n  new[k] = v\n  return new\nen","completion":""}
{"prompt":"-- [Funcion que devuelve el numero mayor de dos numeros]\n-- Args:\n-- n1 ([int]): [Primer numero a comparar]\n-- n2 ([int]): [Segundo numero a comparar]\n-- Returns:\n-- [n_max]: [Numero mayor de los dos]\nlocal function max_dos(n1, n2)\n    if n1 > n2 then\n        n_max = n1\n    else\n        n_max = n2\n    end\n    return n_max\nen","completion":""}
{"prompt":"-- Strip base directory from filename if it starts there.\n-- >>> strip_base_dir('\/path\/to\/base\/relpath\/to\/file',\n-- ...                '\/path\/to\/base\/')\n-- 'relpath\/to\/file'\n-- >>> strip_base_dir('\/path\/to\/somewhere\/else\/relpath\/to\/file',\n-- ...                '\/path\/to\/base\/')\n-- '\/path\/to\/somewhere\/else\/relpath\/to\/file'\nlocal function strip_base_dir(filename, base_dir)\n    if filename:sub(1, #base_dir) == base_dir then\n        return filename:sub(#base_dir + 1)\n    end\n    return filename\nen","completion":""}
{"prompt":"-- Function that checks if the input value (data) is a power of 2\n-- (i.e. 2, 4, 8, 16, 32, ...)\nlocal function power_of_two(number)\n    if number == 2 or number == 4 or number == 8 or number == 16 or number == 32 or number == 64 or number == 128 or number == 256 or number == 512 or number == 1024 or number == 2048 or number == 4096 or number == 8192 or number == 16384 or number == 32768 or number == 65536 or number == 131072 or number == 262144 or number == 524288 or number == 1048576 or number == 2097152 or number == 4194304 or number == 8388608 or number == 16777216 or number == 33554432 or number == 67108864 or number == 134217728 or number == 268435456 or number == 536870912 or number == 1073741824 then\n        return true\n    end\n    return false\nen","completion":""}
{"prompt":"-- Flattens the given documents in nested form to a string representation:\n-- [ #docs\n-- [ #document1\n-- ['word1','word2','word3'], #sentence1\n-- ['word1','word2','word3'], #sentence2\n-- ],\n-- [ #document2\n-- ['word1','word2','word3'], #sentence1\n-- ['word1','word2','word3'], #sentence2\n-- ]\n-- ]\n-- becomes\n-- [ #docs\n-- 's1_word1 s1_word2 s1_word3 s2_word1 s2_word2 s2_word3', #document1\n-- 's1_word1 s1_word2 s1_word3 s2_word1 s2_word2 s2_word3', #document2\n-- ]\nlocal function flatten_documents_to_strings(docs)\n  local result = {}\n  local index = 1\n  for i, document in ipairs(docs) do\n    local document_str = {}\n    for j, sentence in ipairs(document) do\n      for k, word in ipairs(sentence) do\n        table.insert(document_str, word)\n      end\n    end\n    document_str = table.concat(document_str, ' ')\n    table.insert(result, document_str)\n  end\n  return result\nen","completion":""}
{"prompt":"-- Given a number, find the sum of all the unique multiples\n-- of particular numbers up to but not including that number.\n-- If we list all the natural numbers below 20 that are\n-- multiples of 3 or 5, we get 3, 5, 6, 9, 10, 12, 15, and 18.\n-- The sum of these multiples is 78.\n-- :param limit:\n-- :param multiples:\n-- :return:\nlocal function sum_of_multiples(limit, multiples)\n    local sum = 0\n    for i = 1, limit - 1 do\n        local is_multiple = false\n        for _, multiple in pairs(multiples) do\n            if i % multiple == 0 then\n                is_multiple = true\n                break\n            end\n        end\n        if is_multiple then\n            sum = sum + i\n        end\n    end\n    return sum\nen","completion":""}
{"prompt":"-- return the dna string as rna string\nlocal function transcribe(dna)\n    return string.gsub(dna, \"T\", \"U\")\nen","completion":""}
{"prompt":"-- Calculate the rolling speed in a tribological contact based on contact body\n-- velocities.\n-- Parameters\n-- ----------\n-- vel_1: ndarray, scalar\n-- The contact velocity of body 1.\n-- vel_2: ndarray, scalar\n-- The contact velocity of body 2\n-- Returns\n-- -------\n-- vel_roll: ndarray, scalar\n-- The rolling velocity in the tribological contact.\nlocal function vroll(vel_1, vel_2)\n  return (vel_1 + vel_2) \/ 2\nen","completion":""}
{"prompt":"-- creates dictionary for the parameters of interests for the plot\n-- Parameters\n-- ----------\n-- Returns\n-- -------\n-- : dictionary\n-- empty dictionary for the parameters of interest for plots\nlocal function _create_plot_parms_dict()\n    local plot_parms_dict = {}\n    return plot_parms_dict\nen","completion":""}
{"prompt":"-- parse a connection string and return a dictionary of values\nlocal function connection_string_to_dictionary(str)\n  local opts = {}\n  for k,v in str:gmatch(\"(%w+)=([^;]+);?\") do\n    opts[k] = v\n  end\n  return opts\nen","completion":""}
{"prompt":"-- Return the element-wise sum of two mxn arrayLists.\n-- >>> add_([[1, 2, 3]], [[4, 5, 6]])\n-- [[5, 7, 9]]\n-- >>> add_([[1, 2, 3], [4, 5, 6]], [[6, 5, 4], [3, 2, 1]])\n-- [[7, 7, 7], [7, 7, 7]]\n-- >>> add_([[]], [[]])\n-- [[]]\nlocal function add_(arrList1, arrList2)\n    if #arrList1 ~= #arrList2 then\n        error(\"add_: array lengths don't match\")\n    end\n    local arrList3 = {}\n    for i, arr1 in ipairs(arrList1) do\n        local arr2 = arrList2[i]\n        if #arr1 ~= #arr2 then\n            error(\"add_: array lengths don't match\")\n        end\n        local arr3 = {}\n        for j, v1 in ipairs(arr1) do\n            arr3[j] = v1 + arr2[j]\n        end\n        arrList3[i] = arr3\n    end\n    return arrList3\nen","completion":""}
{"prompt":"-- Extracts the port\nlocal function port(location, standard)\n\tlocal _,_,p = location:find(\":(%d+)\")\n\tif p then\n\t\treturn tonumber(p)\n\telse\n\t\treturn standard\n\tend\nen","completion":""}
{"prompt":"-- Get the index, doc_type, and id associated with a document.\n-- Parameters\n-- ----------\n-- result : dict\n-- A document from an Elasticsearch search result.\n-- Returns\n-- -------\n-- dict\n-- A dictionary with keys 'index', 'doc_type', and 'id',\n-- containing the name of the index in which the document resides,\n-- the doc_type of the document, and its id.\nlocal function get_doc_info(result)\n  local info = {}\n  info.index = result._index\n  info.doc_type = result._type\n  info.id = result._id\n  return info\nen","completion":""}
{"prompt":"-- Return ``s`` with a trailing ``\"\/\"`` appended.\n-- If ``s`` already ends with a trailing ``\"\/\"`` it'll be returned unmodified.\nlocal function _append_trailing_slash(s)\n    return s .. (s:sub(-1) == \"\/\" and \"\" or \"\/\")\nen","completion":""}
{"prompt":"-- Encode a string to be used in CSV file\n-- Args:\n-- text:  String to encode\n-- Returns:\n-- Encoded string, including starting and ending double quote\nlocal function encode_csv_string(text)\n    return '\"' .. string.gsub(text, '\"', '\"\"') .. '\"'\nen","completion":""}
{"prompt":"-- Unsigned Bitfield Extract\nlocal function ubfx(value, lsb, width)\n\treturn bit32.band(bit32.rshift(value, lsb), bit32.lshift(2^width-1, 0))\nen","completion":""}
{"prompt":"-- Takes the edge list of a graph and returns the simple graph obtained by removing loops and multiple edges\nlocal function make_multi_simple(edge_list)\n  local simple_edge_list = {}\n  for i = 1, #edge_list do\n    local edge = edge_list[i]\n    if edge[1] ~= edge[2] then\n      local found = false\n      for j = 1, #simple_edge_list do\n        if (edge[1] == simple_edge_list[j][2] and edge[2] == simple_edge_list[j][1]) or (edge[1] == simple_edge_list[j][1] and edge[2] == simple_edge_list[j][2]) then\n          found = true\n          break\n        end\n      end\n      if not found then\n        table.insert(simple_edge_list, {edge[1], edge[2]})\n      end\n    end\n  end\n  return simple_edge_list\nen","completion":""}
{"prompt":"-- from a list of points (x,y pairs)\n-- return the lower-left xy and upper-right xy\nlocal function points_to_bbox(p)\n  local minx, miny = math.huge, math.huge\n  local maxx, maxy = -math.huge, -math.huge\n  for i = 1, #p do\n    local x, y = p[i][1], p[i][2]\n    if x < minx then minx = x end\n    if y < miny then miny = y end\n    if x > maxx then maxx = x end\n    if y > maxy then maxy = y end\n  end\n  return {minx, miny, maxx, maxy}\nen","completion":""}
{"prompt":"-- Returns the k*v1 where k is multiplied by each element in v1.\n-- Args:\n-- k (float): scale factor.\n-- v1 (iterable): a vector in iterable form.\n-- Returns:\n-- iterable: the resultant vector.\nlocal function multiply(k, v1)\n  assert(type(k) == \"number\", \"expecting a number for k\")\n  assert(type(v1) == \"table\", \"expecting a vector for v1\")\n  local v = {}\n  for i, v2 in pairs(v1) do\n    v[i] = k * v2\n  end\n  return v\nen","completion":""}
{"prompt":"-- Convert any text to a list of strings less all surrounding whitespace and\n-- only if it contains some chars\n-- :param text: type str loose text\nlocal function to_lines(text)\n    local lines = {}\n    for line in string.gmatch(text, \"[^\\r\\n]+\") do\n        line = line:gsub(\"^%s*(.-)%s*$\", \"%1\")\n        if line ~= \"\" then\n            lines[#lines + 1] = line\n        end\n    end\n    return lines\nen","completion":""}
{"prompt":"-- Return the first (top) row of a matrix.\n-- Returns a tuple (immutable).\nlocal function top_row(matrix)\n\treturn matrix[1]\nen","completion":""}
{"prompt":"-- Calculate the Greatest Common Divisor of a and b.\n-- Unless b==0, the result will have the same sign as b (so that when\n-- b is divided by it, the result comes out positive).\nlocal function _gcd(a, b)\n\tlocal m\n\tlocal n\n\tlocal r\n\tm = math.abs(a)\n\tn = math.abs(b)\n\twhile n ~= 0 do\n\t\tr = m % n\n\t\tm = n\n\t\tn = r\n\tend\n\treturn m\nen","completion":""}
{"prompt":"-- Creates a list of indexes of * \/ %\n-- :param equation: The equation to work with\n-- :return: List to min()\nlocal function mdm_what_to_min(equation)\n    local result = {}\n    for i = 1, #equation, 1 do\n        if equation:find('\/', i, true) then\n            result[#result + 1] = i\n        end\n    end\n    for i = 1, #equation, 1 do\n        if equation:find('^', i, true) then\n            result[#result + 1] = i\n        end\n    end\n    for i = 1, #equation, 1 do\n        if equation:find('%', i, true) then\n            result[#result + 1] = i\n        end\n    end\n    for i = 1, #equation, 1 do\n        if equation:find('*', i, true) then\n            result[#result + 1] = i\n        end\n    end\n    return result\nen","completion":""}
{"prompt":"-- [A funcao recebe uma frase e devolve uma lista das palavras dentro da frase]\n-- Arguments:\n-- frase {[str]} -- [Uma frase]\n-- Returns:\n-- [lista] -- [Retorna uma lista de palavras dentro da frase recebida]\nlocal function separa_palavras(frase)\n    local lista_palavras = {}\n    --[[\n        A fun\u00e7\u00e3o split separa a frase recebida em palavras separando os caracteres com espa\u00e7o.\n    --]]\n    for palavra in string.gmatch(frase, \"%S+\") do\n        table.insert(lista_palavras, palavra)\n    end\n    --[[\n        A fun\u00e7\u00e3o retorna a lista de palavras separada da frase.\n    --]]\n    return lista_palavras\nen","completion":""}
{"prompt":"-- Returns the ASCII decoded version of the given HTML string. This does\n-- NOT remove normal HTML tags like <p>.\nlocal function html_decode(s)\n\ts = string.gsub(s, \"&amp;\", \"&\")\n\ts = string.gsub(s, \"&lt;\", \"<\")\n\ts = string.gsub(s, \"&gt;\", \">\")\n\ts = string.gsub(s, \"&quot;\", \"\\\"\")\n\ts = string.gsub(s, \"&#(%d+);\", function(n) return string.char(n) end)\n\ts = string.gsub(s, \"&apos;\", \"'\")\n\treturn s\nen","completion":""}
{"prompt":"-- Convert index to base pair\nlocal function idx_to_string(val)\n  if not val then return '' end\n  if val == 0 then return 'A' end\n  if val == 1 then return 'C' end\n  if val == 2 then return 'G' end\n  if val == 3 then return 'T' end\n  return 'N'\nen","completion":""}
{"prompt":"-- Parse string as integer, ignoring all non-numbers.\nlocal function parseInt(string)\n    local number = 0\n    for i = 1, #string do\n        local c = string:sub(i,i)\n        if c >= \"0\" and c <= \"9\" then\n            number = number * 10 + (c - \"0\")\n        end\n    end\n    return number\nen","completion":""}
{"prompt":"-- Computes the binomial coefficient of n and k.\n-- Taken from <https:\/\/en.wikipedia.org\/wiki\/Binomial_coefficient>.\nlocal function binom(n, k)\n    if k < 0 or n < k then\n        return 0\n    elseif k == 0 or k == n then\n        return 1\n    elseif k == 1 or k == n - 1 then\n        return n\n    else\n        k = math.min(k, n - k)\n        return binom(n - 1, k - 1) + binom(n - 1, k)\n    end\nen","completion":""}
{"prompt":"-- Fibonacci numbers solved with binary recursion\nlocal function fiboRecursive(n)\n  if n <= 1 then\n    return 1\n  else\n    return fiboRecursive(n - 1) + fiboRecursive(n - 2)\n  end\nen","completion":""}
{"prompt":"-- Convect string to float.\n-- :param text: (str) String chunk\n-- :return: (float) or original input string.\nlocal function str_to_flt(text)\n    local f = tonumber(text)\n    if f then\n        return f\n    end\n    return text\nen","completion":""}
{"prompt":"-- distance = 1; answer = 1\n-- distance = 2; answer = 3 (distance + 1) * (distance \/ 2)\n-- distance = 3; answer = 6\n-- distance = 4; answer = 10 (distance + 1) * (distance \/ 2)\n-- distance = 5; answer = 15\n-- distance = 6; answer = 21 (distance + 1) * (distance \/ 2)\nlocal function calc_cost(distance)\n\treturn (distance + 1) * (distance \/ 2)\nen","completion":""}
{"prompt":"-- Remove whitespace in provided content.\nlocal function minify(content)\n  content = content:gsub(\"%s*%-%-.*$\", \"\") -- Remove comments.\n  content = content:gsub(\"%s+\", \" \") -- Collapse whitespace.\n  content = content:gsub(\"%s*%-%-.*$\", \"\") -- Remove more comments.\n  return content\nen","completion":""}
{"prompt":"-- Unit symbol of a counter, motor or EPICS record\n-- name: string, name of EPICS process variable or name of Python variable\nlocal function unit(name)\n\tif (not name or name == \"\") then\n\t\treturn \"\"\n\tend\n\tlocal name_lower = string.lower(name)\n\tif (name_lower == \"time\") then\n\t\treturn \"s\"\n\tend\n\tif (name_lower == \"power\" or name_lower == \"energy\") then\n\t\treturn \"W\"\n\tend\n\tif (name_lower == \"temperature\") then\n\t\treturn \"K\"\n\tend\n\tif (name_lower == \"pressure\") then\n\t\treturn \"Pa\"\n\tend\n\tif (name_lower == \"current\" or name_lower == \"voltage\") then\n\t\treturn \"A\"\n\tend\n\tif (name_lower == \"density\" or name_lower == \"charge\" or name_lower == \"mass\" or name_lower == \"length\" or name_lower == \"area\") then\n\t\treturn \"kg\"\n\tend\n\tif (name_lower == \"velocity\") then\n\t\treturn \"m\/s\"\n\tend\n\tif (name_lower == \"time\") then\n\t\treturn \"s\"\n\tend\n\treturn \"\"\nen","completion":""}
{"prompt":"-- Perform Linear interpolation in 1D\nlocal function _lerp(A, B, t)\n\treturn A + t*(B-A)\nen","completion":""}
{"prompt":"-- List available deep learning entities models, ['concat', 'bahdanau', 'luong', 'entity-network', 'attention']\nlocal function available_deep_model()\n  return {\n    'concat',\n    'bahdanau',\n    'luong',\n    'entity-network',\n    'attention'\n  }\nen","completion":""}
{"prompt":"-- Finds the intersection of str1 and str2 where an intersection is\n-- determined by str1[i] == str[i].\n-- >>> intersection(\"bbbaabbb\", \"dddaaddd\")\n-- 'aa'\n-- >>> intersection(\"bbbaabbb\", \"dddaa\")\n-- 'aa'\n-- >>> intersection(\"bbbaabbb\", \"ddd\")\n-- ''\n-- >>> intersection(\"bbbbbbbbb\", \"ababababa\")\n-- 'bbbb'\n-- >>> intersection(\"bbbaabbb\", 1)\n-- Traceback (most recent call last):\n-- ...\n-- AssertionError\n-- # My doctests\n-- >>> intersection('aaabbbccc', 'bbbcccaaa')\n-- ''\n-- >>> intersection('2345', '12358459374ffdhk~!#*')\n-- '5'\n-- >>> intersection('#RELATABLE!', '#relatable!')\n-- '#!'\nlocal function intersection(str1, str2)\n  assert(type(str1) == 'string' and type(str2) == 'string',\n         \"str1 and str2 must be strings\")\n  local str = ''\n  for i = 1, #str1 do\n    if str1:sub(i, i) == str2:sub(i, i) then str = str .. str1:sub(i, i) end\n  end\n  return str\nen","completion":""}
{"prompt":"-- Return parsed keyid string(s) or tuple of.\nlocal function parse_keyids(key)\n  if type(key) == \"string\" then\n    if not key:find(\",\") then\n      return key\n    else\n      local keys = {}\n      for k in key:gmatch(\"%S+\") do keys[#keys+1] = k end\n      return keys\n    end\n  elseif type(key) == \"number\" then\n    return key\n  elseif type(key) == \"table\" then\n    local keys = {}\n    for _, k in ipairs(key) do\n      if k ~= 0 then keys[#keys+1] = k end\n    end\n    return keys\n  end\nen","completion":""}
{"prompt":"-- Get grid with number of rows and columns.\nlocal function get_grid(rows, columns)\n\t-- Initialize grid.\n\tlocal grid = {}\n\tfor row = 1, rows do\n\t\tgrid[row] = {}\n\t\tfor column = 1, columns do\n\t\t\tgrid[row][column] = 0\n\t\tend\n\tend\n\t-- Return grid.\n\treturn grid\nen","completion":""}
{"prompt":"-- Helper function for argument parsing.\nlocal function int_or_str(text)\n  local num = tonumber(text)\n  if num then\n    if num == math.floor(num) then\n      return num\n    end\n  end\n  return text\nen","completion":""}
{"prompt":"-- Get binary representation of input n\n-- :param n: Integer of which to get binary representation\n-- :param N: Length of bitstring\n-- :return: str\nlocal function to_binary(n, N)\n   local result = \"\"\n   while n > 0 do\n      result = (n % 2) .. result\n      n = math.floor(n \/ 2)\n   end\n   return string.rep('0', N - #result) .. result\nen","completion":""}
{"prompt":"-- Then, we define the logic for creating a string of periods\n-- of arbitrary length, using a FOR loop again:\nlocal function get_period_string(num_periods)\n  local periods = \"\"\n  for i=1,num_periods do\n    periods = periods .. \".\"\n  end\n  return periods\nen","completion":""}
{"prompt":"-- Try to stay at a maximum of 1500 tiles per partition; But don't go over 128 partitions.\n-- Also, don't go below the default of 8\nlocal function determine_parllelism(num_tiles)\n  return math.min(math.max(math.ceil(num_tiles \/ 1500), 8), 128)\nen","completion":""}
{"prompt":"-- funcion which takes a string and returns a dictionary, where\n-- each key is a character from string and its value is the number\n-- of occurrences of that char in string.\nlocal function char_histogram(string)\n    local histogram = {}\n    for char in string:gmatch\".\" do\n        histogram[char] = histogram[char] and histogram[char]+1 or 1\n    end\n    return histogram\nen","completion":""}
{"prompt":"-- Given a list, possibly nested to any level, return it flattened.\nlocal function flatten(lis)\n\tlocal newlis = {}\n\tlocal function recurse(l)\n\t\tfor _, v in ipairs(l) do\n\t\t\tif type(v) == \"table\" then\n\t\t\t\trecurse(v)\n\t\t\telse\n\t\t\t\tnewlis[#newlis + 1] = v\n\t\t\tend\n\t\tend\n\tend\n\trecurse(lis)\n\treturn newlis\nen","completion":""}
{"prompt":"-- Takes str s and returns int (preferentially) or float.\nlocal function to_number(s)\n  if s:find('%.') then\n    return tonumber(s) or 0\n  else\n    return math.floor(tonumber(s) or 0)\n  end\nen","completion":""}
{"prompt":"-- Construct parent key.\nlocal function _as_parent_key(parent, key)\n    if not parent then\n        return key\n    elseif parent == '' then\n        return key\n    else\n        return parent .. '.' .. key\n    end\nen","completion":""}
{"prompt":"-- Check whether an object is in the values ['pixel', 'interpixel'].\n-- Parameters\n-- ----------\n-- var\n-- Variable to check\n-- Returns\n-- -------\n-- var\n-- Same value as input\nlocal function centering(var)\n\tif var == 'pixel' or var == 'interpixel' then\n\t\treturn var\n\telse\n\t\treturn 'pixel'\n\tend\nen","completion":""}
{"prompt":"-- Return the time (ns) from distance (mm) and signal velcity (m\/ns).\n-- Attributes:\n-- distance <float>: travel distance (ns) of radio signal;\n-- velocity <float>: travel velocity (m\/ns) of radio signal.\nlocal function mm2ns(distance, velocity)\n\t-- Return the time (ns) from distance (mm) and signal velcity (m\/ns).\n\treturn (distance * 1e-3) \/ velocity\nen","completion":""}
{"prompt":"-- Strip off the T from the datetime string\nlocal function date(string)\n\treturn string:gsub('T', ' ')\nen","completion":""}
{"prompt":"-- a, b, c: numerical values for the coefficients of a quadratic equation\n-- x: numerical value at which to evaluate the quadratic.\nlocal function evalQuadratic(a, b, c, x)\n\treturn (a*x*x + b*x + c)\nen","completion":""}
{"prompt":"-- returns Cos[ArcTan[x]] assuming -pi\/2 < x < pi\/2.\nlocal function tan2cos(tan)\n\treturn ((1+tan*tan)^(1\/2))\/(1+tan)\nen","completion":""}
{"prompt":"-- Make object into a list\nlocal function _to_list(obj)\n  if obj == nil then\n    return {}\n  elseif type(obj) == 'table' then\n    return obj\n  else\n    return {obj}\n  end\nen","completion":""}
{"prompt":"-- Returns the cross product of two vectors\nlocal function cross(a, b)\n    return { a[2] * b[3] - a[3] * b[2],\n             a[3] * b[1] - a[1] * b[3],\n             a[1] * b[2] - a[2] * b[1] }\nen","completion":""}
{"prompt":"-- Return the n-th Fibonacci number\n-- :param n: n-th fibonacci number requested\n-- :return: the n-th Fibonacci number\nlocal function fibonacci(n)\n    return n <= 1 and n or fibonacci(n-1) + fibonacci(n-2)\nen","completion":""}
{"prompt":"-- remove brackets and all white spaces in and around unit string\nlocal function clean_unit(unit_str)\n\treturn string.gsub(unit_str, \"[%[%]]\", \"\"):match(\"^%s*(.-)%s*$\")\nen","completion":""}
{"prompt":"-- Using a dictionary of substitutions ``d`` try and explicitly evaluate as much of ``expr`` as\n-- possible.\n-- :param Expression expr: The expression whose parameters are substituted.\n-- :param Dict[Parameter,Union[int,float]] d: Numerical substitutions for parameters.\n-- :return: A partially simplified Expression or a number.\n-- :rtype: Union[Expression,int,float]\nlocal function substitute(expr, d)\n  if type(expr) == 'number' or type(expr) == 'boolean' then return expr end\n  if expr.op == 'param' then\n    return d[expr] or expr\n  elseif expr.op == 'mul' or expr.op == 'add' then\n    return make_expr(expr.op, substitute(expr.args[1], d), substitute(expr.args[2], d))\n  else\n    return make_expr(expr.op, substitute(expr.args[1], d), substitute(expr.args[2], d),\n                     substitute(expr.args[3], d))\n  end\nen","completion":""}
{"prompt":"-- Wort 'bigness factor' for hop utilization.\n-- Parameters\n-- ----------\n-- wort_gravity : float\n-- Average specific gravity of wort during boil.\n-- Returns\n-- -------\n-- bigness_factor : float\n-- Multiplicative factor for hop utilization based on wort\n-- gravity.\nlocal function bigness_factor(wort_gravity)\n    return 1.65 * wort_gravity ^ (1.0 \/ 6.0)\nen","completion":""}
{"prompt":"-- Returns a flattened array containing all elements of subarrays.\nlocal function flatten(array)\n  local t = {}\n  for _,v in ipairs(array) do\n    if type(v) == \"table\" then\n      for _,v in ipairs(flatten(v)) do\n        table.insert(t, v)\n      end\n    else\n      table.insert(t, v)\n    end\n  end\n  return t\nen","completion":""}
{"prompt":"-- Convert a single intercepted environment variable into dictionary.\nlocal function split_env(line)\n\tlocal key, value = line:match(\"^%s*(.-)=(.*)$\")\n\tif key and value then\n\t\tlocal t = {}\n\t\tt[key] = value\n\t\treturn t\n\telse\n\t\treturn nil\n\tend\nen","completion":""}
{"prompt":"-- Apply the replace method multiple times.\n-- \"inputstring\" is self-explanatory, \"replacements\" is a list of\n-- tuples, the fist item of each tuple the substring to be replaced\n-- and the second the replacement text.\nlocal function multi_replace(inputstring, replacements)\n  local output = inputstring\n  for _, replacement in pairs(replacements) do\n    local pattern = replacement[1]\n    local replacement_text = replacement[2]\n    output = string.gsub(output, pattern, replacement_text)\n  end\n  return output\nen","completion":""}
{"prompt":"-- Performs the Euclidean algorithm and returns the gcd of a and b\nlocal function gcd(a, b)\n\treturn b == 0 and a or gcd(b, a % b)\nen","completion":""}
{"prompt":"-- Calculates the mass of the rocket at time t\n-- Args:\n-- wet_mass (float): The mass of the ship and fuel at time t=0.\n-- mass_flow (float): Amount of fuel expelled per timestep\n-- i (int): Iterator used for Euler's Method\n-- Returns:\n-- mass_ship (float): The new mass of the ship at timestep i.\nlocal function Mass_of_spaceship(wet_mass, mass_flow, dry_mass, i)\n    local mass_ship = wet_mass - mass_flow*i + dry_mass\n    return mass_ship\nen","completion":""}
{"prompt":"-- Merge command state with keyword arguments.\n-- Command state takes precedence over any keyword argument.\n-- :param state: The current command state. Can be ``None``.\n-- :param kwargs: The base keyword arguments.\n-- :returns: A dictionary containing all of ``kwargs``, with any values\n-- provided in ``state`` overriding the base ``kwargs`` values.\nlocal function full_kwargs(state, kwargs)\n   if state then\n      if type(state) ~= 'table' then\n         error('Expected a table for state, got ' .. type(state))\n      end\n      for k, v in pairs(state) do\n         kwargs[k] = v\n      end\n   end\n   return kwargs\nen","completion":""}
{"prompt":"-- Inverse of quaternion q\n-- Args:\n-- q: (qw, qx, qy, qz)\nlocal function quaternion_inv(q)\n\tlocal qw = q[1]\n\tlocal qx = q[2]\n\tlocal qy = q[3]\n\tlocal qz = q[4]\n\tlocal q2 = qw*qw + qx*qx + qy*qy + qz*qz\n\tif q2 > 0.0 then\n\t\treturn {qw\/q2, -qx\/q2, -qy\/q2, -qz\/q2}\n\telse\n\t\treturn {0.0, 0.0, 0.0, 0.0}\n\tend\nen","completion":""}
{"prompt":"-- x: class object\n-- Return value: list of  strings\nlocal function members(x)\n\tlocal result = {}\n\tlocal mt = getmetatable(x)\n\tif mt ~= nil and mt.__index ~= nil then\n\t\tfor key in pairs(mt.__index) do\n\t\t\ttable.insert(result, key)\n\t\tend\n\tend\n\treturn result\nen","completion":""}
{"prompt":"-- Return UTF-8 `str` from unicode @ustr\n-- This is to use the same error handling etc everywhere\n-- if ustr is `str`, just return it\nlocal function toutf8(ustr)\n\tif type(ustr) == \"string\" then\n\t\treturn ustr\n\tend\n\treturn ustr:toutf8()\nen","completion":""}
{"prompt":"-- (string) -> string\n-- >>> first_letters('this is a test')\n-- This Is A Test\nlocal function first_letters(text)\n    text = text or \"\"\n    return text:gsub(\"([%w_']+)\",\n        function(a) return a:sub(1,1):upper() .. a:sub(2):lower() end)\nen","completion":""}
{"prompt":"-- Convert s to float or raise a ValueError.\nlocal function validate_float(s)\n  local float = tonumber(s)\n  if float == nil then\n    error(s .. \" is not a float\")\n  end\n  return float\nen","completion":""}
{"prompt":"-- Callback to fill the marketing example value.\nlocal function twice_x(x)\n\treturn 2 * x\nen","completion":""}
{"prompt":"-- >>> factors_of_a_number(1)\n-- [1]\n-- >>> factors_of_a_number(5)\n-- [1, 5]\n-- >>> factors_of_a_number(24)\n-- [1, 2, 3, 4, 6, 8, 12, 24]\n-- >>> factors_of_a_number(-24)\n-- []\nlocal function factors_of_a_number(num)\n    if num < 0 then\n        return {}\n    end\n    local result = {}\n    for i=1,num do\n        if num % i == 0 then\n            table.insert(result, i)\n        end\n    end\n    return result\nen","completion":""}
{"prompt":"-- decide the season that date belongs to\n-- :param month:\n-- :return:\nlocal function seasons(month)\n  if month >= 3 and month <= 5 then\n    return 'spring'\n  elseif month >= 6 and month <= 8 then\n    return 'summer'\n  elseif month >= 9 and month <= 11 then\n    return 'autumn'\n  else\n    return 'winter'\n  end\nen","completion":""}
{"prompt":"-- Return the last component of a dotted name\nlocal function undotted_name(name)\n\treturn name:match('^.*%.(.*)$') or name\nen","completion":""}
{"prompt":"-- Accepts degrees Celsius (celsius argument)\n-- Returns degrees Fahrenheit\nlocal function to_fahrenheit(celsius)\n\treturn ((9\/5) * celsius + 32)\nen","completion":""}
{"prompt":"-- Escape generated text.\n-- Args:\n-- raw_text: text potentially containing double quotes\n-- Returns:\n-- text with escaped double quotes\nlocal function escape_text(raw_text)\n    return raw_text:gsub('\"', '\"\"')\nen","completion":""}
{"prompt":"-- Using Newton's Method\nlocal function sqrt(n)\n  local z = n\n  for i = 0, 10 do\n    z = z - (z * z - n) \/ (2 * z)\n  end\n  return z\nen","completion":""}
{"prompt":"-- Check if a valid dewpoint temperature is \n-- greater than a valid air temperature\n-- :param invaltd: the input value for dewpoint temperature\n-- :param invalt: the input value for air temperature\n-- :type invaltd: float\n-- :type invalt: float\n-- :return: 1 if the input values are invalid\/None\n-- :return: 1 if the dewpoint temperature is greater than the air temperarture \n-- :return: 0 otherwise\n-- :return type: integer\nlocal function supersat_check(invaltd, invalt)\n\tlocal ret = 0\n\t\n\tif invaltd == nil or invalt == nil then\n\t\treturn 1\n\tend\n\t\n\tif invaltd > invalt then\n\t\tret = 1\n\tend\n\t\n\treturn ret\nen","completion":""}
{"prompt":"-- Determine the number of leading b's in vector x.\n-- Parameters\n-- ----------\n-- b: int\n-- Integer for counting at head of vector.\n-- x: array\n-- Vector of integers.\n-- Returns\n-- -------\n-- head: int\n-- Number of leading b's in x.\nlocal function head(_b, _x)\n  local _sum = 0\n  for i, x in ipairs(_x) do\n    if x == _b then\n      _sum = _sum + 1\n    else\n      break\n    end\n  end\n  return _sum\nen","completion":""}
{"prompt":"-- Assumes n an int > 0\n-- Returns n!\nlocal function fact_rec(n)\n\tif n == 0 then\n\t\treturn 1\n\telse\n\t\treturn n * fact_rec(n - 1)\n\tend\nen","completion":""}
{"prompt":"-- Return the largest value in line, which is a whitespace-delimited string\n-- of integers that each end with a '.'.\n-- >>> find_largest('1. 3. 2. 5. 2.')\n-- 5\nlocal function find_largest(line)\n  local largest = 0\n  for number in line:gmatch(\"%d+\") do\n    largest = math.max(largest, tonumber(number))\n  end\n  return largest\nen","completion":""}
{"prompt":"-- Normalises a url to have an ending slash, and only one.\nlocal function with_end_slash(url)\n  return url:gsub(\"\/+$\", \"\") .. \"\/\"\nen","completion":""}
{"prompt":"-- Convert old-style camel-case method names to new-style names with\n-- underscores.\n-- ::\n-- >>> camelcase_to_underscore('assertEqual')\n-- ... 'assert_equal'\n-- >>> camelcase_to_underscore('assertNotEqual')\n-- ... 'assert_not_equal'\n-- >>> camelcase_to_underscore('assert_equal')\n-- ... 'assert_equal'\n-- >>> camelcase_to_underscore('assert_not_equal')\n-- ... 'assert_not_equal'\nlocal function camelcase_to_underscore(name)\n    if not name:find('_') then\n        local parts = {}\n        for part in name:gmatch('([A-Z]?[^A-Z]*)') do\n            table.insert(parts, part:lower())\n        end\n        name = table.concat(parts, '_')\n    end\n    return name\nen","completion":""}
{"prompt":"-- Helper function to convert month number to short name\n-- Args:\n-- num (int): the month number to convert\n-- Returns:\n-- (str): The three letter short name of the corresponding month\nlocal function _num_to_month(num)\n  local names = {\n    \"Jan\",\n    \"Feb\",\n    \"Mar\",\n    \"Apr\",\n    \"May\",\n    \"Jun\",\n    \"Jul\",\n    \"Aug\",\n    \"Sep\",\n    \"Oct\",\n    \"Nov\",\n    \"Dec\",\n  }\n  return names[num]\nen","completion":""}
{"prompt":"-- Find the difference between two colors. This is part of `closest_color_parallel`\n-- below, but multiprocessing cannot pickle nested functions.\n-- Parameters\n-- ----------\n-- pair : (rgb, pixel)\n-- Check how close `rgb` is to `pixel`.\n-- Returns\n-- -------\n-- int\n-- The difference between `rgb` and `pixel`.\nlocal function color_diff_par(pair)\n  local rgb = pair[1]\n  local pixel = pair[2]\n  local d = 0\n  for i = 1, 3 do\n    d = d + (rgb[i] - pixel[i]) ^ 2\n  end\n  return d\nen","completion":""}
{"prompt":"-- A one dimensional straight line function.\n-- Args:\n-- abscissa (:py:attr:`array_like`): The abscissa data.\n-- gradient (:py:attr:`float`): The slope of the line.\n-- intercept (:py:attr:`float`): The y-intercept of the line.\n-- Returns:\n-- :py:attr:`array_like`: The resulting ordinate.\nlocal function straight_line(abscissa, gradient, intercept)\n  return gradient * abscissa + intercept\nen","completion":""}
{"prompt":"-- Get a list of all amino acid sequences encoded by an RNA sequence.\n-- All three reading frames of `rna_sequence` are scanned from 'left' to\n-- 'right', and the generation of a sequence of amino acids is started\n-- whenever the start codon 'AUG' is found. The `rna_sequence` is assumed to\n-- be in the correct orientation (i.e., no reverse and\/or complement of the\n-- sequence is explored).\n-- The function returns a list of all possible amino acid sequences that\n-- are encoded by `rna_sequence`.\n-- If no amino acids can be translated from `rna_sequence`, an empty list is\n-- returned.\nlocal function get_all_translations(rna_sequence, genetic_code)\n  local aa_sequences = {}\n  local function find_translation(rna_seq, frame, frame_aa_seq, aa_seq)\n    if rna_seq:len() < frame then return aa_seq end\n    local codon = rna_seq:sub(frame, frame + 2)\n    if codon == 'AUG' then\n      local new_aa_seq = frame_aa_seq .. genetic_code.translate(codon)\n      aa_sequences[#aa_sequences+1] = new_aa_seq\n      return find_translation(rna_seq, frame+3, new_aa_seq, aa_seq)\n    else\n      return find_translation(rna_seq, frame+3, frame_aa_seq, aa_seq)\n    end\n  end\n  find_translation(rna_sequence, 1, '', '')\n  return aa_sequences\nen","completion":""}
{"prompt":"-- Convert a two-tuple (x, y) coordinate into an (x, y, 0) coordinate.\nlocal function to_xyz(xy)\n\treturn { xy[1], xy[2], 0 }\nen","completion":""}
{"prompt":"-- Take a list of a list of element node indexes and increment the\n-- node index by one.\nlocal function _makeElementsOneBased(elements_list)\n    local new_list = {}\n    for _,elements in pairs(elements_list) do\n        local new_elements = {}\n        for _,element_index in pairs(elements) do\n            new_elements[#new_elements + 1] = element_index + 1\n        end\n        new_list[#new_list + 1] = new_elements\n    end\n    return new_list\nen","completion":""}
{"prompt":"-- Return ordinal english suffix to number of a day.\nlocal function ordinal_suffix(day)\n    local mod = day % 10\n    if mod == 1 and day ~= 11 then return 'st'\n    elseif mod == 2 and day ~= 12 then return 'nd'\n    elseif mod == 3 and day ~= 13 then return 'rd'\n    else return 'th' end\nen","completion":""}
{"prompt":"-- >>> ordinal(5)\n-- '5th'\n-- >>> ordinal(151)\n-- '151st'\nlocal function ordinal(number)\n  -- Get the last two characters\n  local suffix = number % 100\n  -- Only handle values where we could get a suffix\n  if (suffix == 11 or suffix == 12 or suffix == 13) then\n    return number .. \"th\"\n  elseif (suffix % 10 == 1) then\n    return number .. \"st\"\n  elseif (suffix % 10 == 2) then\n    return number .. \"nd\"\n  elseif (suffix % 10 == 3) then\n    return number .. \"rd\"\n  else\n    return number .. \"th\"\n  end\nen","completion":""}
{"prompt":"-- Remove non alphanumeric\/whitespace characers from restaurant address \n-- but allows for commas\nlocal function format_address(address)\n  address = string.gsub(address, \"%p\", \"\") -- remove all non alphanumeric characters\n  address = string.gsub(address, \"%s+\", \" \") -- replace multiple whitespace characters with a single space\n  address = string.gsub(address, \"%s?(,)\", \", \") -- replace whitespace characters followed by a comma with a comma and space\n  return address\nen","completion":""}
{"prompt":"-- Print out the hailstone sequence starting at n, and return the\n-- number of elements in the sequence.\n-- >>> a = hailstone(10)\n-- 10\n-- 5\n-- 16\n-- 8\n-- 4\n-- 2\n-- 1\n-- >>> a\n-- 7\nlocal function hailstone(n)\n  io.write(n, '\\n')\n  local t = 1\n  while n ~= 1 do\n    io.write(n, '\\n')\n    if n % 2 == 0 then\n      n = n \/ 2\n    else\n      n = 3 * n + 1\n    end\n    t = t + 1\n  end\n  return t\nen","completion":""}
{"prompt":"-- Converts a list of AWS tag dicts to a single dict with corresponding keys and values\nlocal function tag2dict(tags)\n  local result = {}\n  for _, tag in ipairs(tags or {}) do\n    result[tag.Key] = tag.Value\n  end\n  return result\nen","completion":""}
{"prompt":"-- For RGB_to_HSL and RGB_to_HSV, the Hue (H) component is calculated in\n-- the same way.\nlocal function __RGB_to_Hue(var_R, var_G, var_B, var_min, var_max)\n\tif (var_max == var_min) then\n\t\treturn 0\n\telseif (var_max == var_R) then\n\t\treturn 60 * (((var_G - var_B) \/ (var_max - var_min)) % 6)\n\telseif (var_max == var_G) then\n\t\treturn 60 * (((var_B - var_R) \/ (var_max - var_min)) + 2)\n\telseif (var_max == var_B) then\n\t\treturn 60 * (((var_R - var_G) \/ (var_max - var_min)) + 4)\n\tend\nen","completion":""}
{"prompt":"-- Convert any non list to a singleton list\nlocal function to_list(v)\n    if type(v) == 'table' then\n        return v\n    else\n        return { v }\n    end\nen","completion":""}
{"prompt":"-- The resources having one of the specified Tags\n-- If tags is the empty list all resources are returned\n-- Arguments:\n-- resources {[type]} -- A list of Resources\n-- tags {[type]} -- A list of Tags\n-- Returns:\n-- [type] -- A list of Resources\nlocal function filter_by_tags(resources, tags)\n    local filtered_resources = {}\n    for _, resource in pairs(resources) do\n        if resource.tags ~= nil then\n            local resource_has_tag = false\n            for _, resource_tag in pairs(resource.tags) do\n                for _, filter_tag in pairs(tags) do\n                    if resource_tag == filter_tag then\n                        resource_has_tag = true\n                    end\n                end\n            end\n            if resource_has_tag then\n                table.insert(filtered_resources, resource)\n            end\n        end\n    end\n    return filtered_resources\nen","completion":""}
{"prompt":"-- Check if any row or column is completely marked\n-- Returns:\n-- bool: True if any row or column is completely marked\nlocal function check_bingo(matrix)\n  for i = 1, #matrix do\n    local row_marked = true\n    local column_marked = true\n    for j = 1, #matrix[1] do\n      row_marked = row_marked and matrix[i][j]\n      column_marked = column_marked and matrix[j][i]\n    end\n    if row_marked or column_marked then\n      return true\n    end\n  end\n  return false\nen","completion":""}
{"prompt":"-- Casts a value to float if possible.\n-- Args:\n-- v: The value to cast.\n-- Returns:\n-- A float, or the original value if a cast was not possible.\nlocal function maybe_float(v)\n  local f = tonumber(v)\n  return (type(f) == \"number\" and f) and f or v\nen","completion":""}
{"prompt":"-- ecursive function that return the nth Fibonacci number in the sequence\n-- Parameters\n-- ----------\n-- n : int\n-- The element of the Fibonacci sequence that is desired.\n-- Raises\n-- ------\n-- ValueError\n-- If n <= 0.\n-- Returns\n-- -------\n-- int\n-- The value of the nth element of the Fibonacci sequence.\nlocal function fibonacci(n)\n  if n < 1 then\n    error(\"n must be an int > 0\")\n  end\n  if n == 1 then\n    return 0\n  elseif n == 2 then\n    return 1\n  end\n  return fibonacci(n-2) + fibonacci(n-1)\nen","completion":""}
{"prompt":"-- >>> rescale(0, 0, 1, 0, 1)\n-- 0.0\n-- >>> rescale(1, 0, 1, 0, 1)\n-- 1.0\n-- >>> rescale(0, -.5, .5, 0, 1)\n-- 0.5\n-- >>> rescale(0.0, -1, 1, 1, 10)\n-- 5.5\nlocal function rescale(X, lo, hi, new_lo, new_hi)\n   if X == lo then\n      return new_lo\n   elseif X == hi then\n      return new_hi\n   else\n      local range = hi - lo\n      local new_range = new_hi - new_lo\n      local new_range_2 = new_range \/ range\n      local X_2 = X - lo\n      return new_lo + new_range_2 * X_2\n   end\nen","completion":""}
{"prompt":"-- Returns admin version of a given vCD url.\n-- This function is idempotent, which also means that if input href is already\n-- an admin href no further action would be taken.\n-- :param str href: the href whose admin version we need.\n-- :return: admin version of the href.\n-- :rtype: str\nlocal function get_admin_href(href)\n    if href:find(\"\/admin\/\", 1, true) then\n        return href\n    else\n        return href:gsub(\"\/api\/\", \"\/api\/admin\/\")\n    end\nen","completion":""}
{"prompt":"-- Convert a string to a float number\n-- :param value: (str)\n-- :return: (float)\n-- Example:\n-- >>> get_float('3.0')\n-- 3.0\nlocal function get_float(value)\n\treturn tonumber(value)\nen","completion":""}
{"prompt":"-- Converts a nested json string into a flat dict\nlocal function normalize_json(item_y)\n    if type(item_y) == \"table\" then\n        local new_item = {}\n        for k,v in pairs(item_y) do\n            if type(k) ~= \"number\" then\n                k = k:gsub(\"_\",\"-\")\n            end\n            if type(v) == \"table\" then\n                for k1,v1 in pairs(normalize_json(v)) do\n                    new_item[k..\"_\"..k1] = v1\n                end\n            else\n                new_item[k] = v\n            end\n        end\n        return new_item\n    else\n        return {value = item_y}\n    end\nen","completion":""}
{"prompt":"-- Decelerating to zero velocity.\nlocal function quadratic_ease_out(t, b, c, d)\n    t = t \/ d\n    return -c * t * (t - 2) + b\nen","completion":""}
{"prompt":"-- Supply legacy expectation on Python 3.5\nlocal function adapt_glob(regex)\n  return regex:gsub(\"([^\/]+)\", {\n    \".-$1\";\n    \".-$1\";\n    \".-$1\";\n    \".-$1\";\n    \".-$1\";\n    \".-$1\";\n    \".-$1\";\n    \".-$1\";\n    \".-$1\";\n  });\nen","completion":""}
{"prompt":"-- Heaviside function. Returns 1 if x>0, and 0 otherwise.\n-- Examples\n-- --------\n-- >>> heaviside(2)\n-- 1\n-- >>> heaviside(-1)\n-- 0\nlocal function heaviside(x)\n  if x > 0 then\n    return 1\n  else\n    return 0\n  end\nen","completion":""}
{"prompt":"-- aaa = [[116, 105, 114,  97, 115],\n-- [ 97, 110, 110,   0,   0],\n-- [101, 108,   0,   0,   0]]\n-- ans -> [5, 3, 2]\nlocal function count_non_zero_length(aaa)\n   local ans = {}\n   for i = 1, #aaa do\n      local n = 0\n      for j = 1, #aaa[i] do\n         if aaa[i][j] ~= 0 then\n            n = n + 1\n         end\n      end\n      ans[#ans + 1] = n\n   end\n   return ans\nen","completion":""}
{"prompt":"-- Convert a literal comma separated string to a string list.\nlocal function str_list(value)\n  if not value or value == \"\" then return {} end\n  if type(value) == \"string\" then\n    local result = {}\n    for token in string.gmatch(value, \"[^,]+\") do\n      table.insert(result, token)\n    end\n    return result\n  else\n    return value\n  end\nen","completion":""}
{"prompt":"-- :param budget: float - the amount of money you are planning to exchange.\n-- :param denomination: int - the value of a single bill.\n-- :return: int - number of bills after exchanging all your money\nlocal function get_number_of_bills(budget, denomination)\n    -- Get the number of bills after exchanging all your money\n    local number_of_bills = 0\n    while budget >= denomination do\n        number_of_bills = number_of_bills + math.floor(budget\/denomination)\n        budget = budget - denomination * math.floor(budget\/denomination)\n    end\n    return number_of_bills\nen","completion":""}
{"prompt":"-- Retorna o MDC entre a e b.\nlocal function mdc_recursivo(a, b)\n    return (b ~= 0) and mdc_recursivo(b, a % b) or a\nen","completion":""}
{"prompt":"-- Return the singular `wordSingular` or the plural form `wordPlural` of a\n-- noun, depending of the value of `count`.\n-- If `wordPlural` is `None`, it equals to `wordSingular` with an appended\n-- 's'.\n-- >>> numerus(1, 'car')\n-- 'car'\n-- >>> numerus(2, 'car')\n-- 'cars'\nlocal function numerus(count, wordSingular, wordPlural)\n  if count == 1 then\n    return wordSingular\n  else\n    if wordPlural == None then\n      return wordSingular .. 's'\n    else\n      return wordPlural\n    end\n  end\nen","completion":""}
{"prompt":"-- Returns fibonnaci number n.\n-- See http:\/\/en.wikipedia.org\/wiki\/Fibonacci_number.\n-- >>> print(fibonacci.cache)\n-- {}\n-- >>> fibonacci(1)\n-- 1\n-- >>> fibonacci(2)\n-- 1\n-- >>> fibonacci(10)\n-- 55\n-- >>> fibonacci.cache[10]\n-- 55\n-- >>> fibonacci(40)\n-- 102334155\nlocal function fibonacci(n)\n  assert(type(n) == 'number', \"fibonacci: argument must be number\")\n  local function fib_iter(a, b, counter)\n    if counter == n then return a end\n    return fib_iter(b, a+b, counter+1)\n  end\n  return fib_iter(0, 1, 0)\nen","completion":""}
{"prompt":"-- Convert `\"True\"` and `\"False\"` to their boolean counterparts.\nlocal function strToBool(string)\n\tlocal val = string.lower(string)\n\tif val == \"true\" then\n\t\treturn true\n\telseif val == \"false\" then\n\t\treturn false\n\telse\n\t\treturn nil\n\tend\nen","completion":""}
{"prompt":"-- checks that the given number is a prime number.\n-- >>> check_prime(1)\n-- False\n-- >>> check_prime(5)\n-- True\n-- >>> check_prime(7)\n-- True\n-- >>> check_prime(11)\n-- True\n-- >>> check_prime(8)\n-- False\nlocal function check_prime(number)\n  if number == 2 or number == 3 or number == 5 or number == 7 then\n    return true\n  end\n  if number < 2 or number%2 == 0 then\n    return false\n  end\n  local limit = math.sqrt(number)\n  for i = 3, limit+1, 2 do\n    if number%i == 0 then\n      return false\n    end\n  end\n  return true\nen","completion":""}
{"prompt":"-- Return bottom, right corner of the rect containing the given points.\nlocal function pmax(a, b)\n    return {math.max(a[1], b[1]), math.max(a[2], b[2])}\nen","completion":""}
{"prompt":"-- convert #RRGGBB to an (R, G, B) tuple\nlocal function HTMLColorToRGB(colorstring)\n  colorstring = colorstring:gsub(\"#\",\"\")\n  return {tonumber(\"0x\"..colorstring:sub(1,2)), tonumber(\"0x\"..colorstring:sub(3,4)), tonumber(\"0x\"..colorstring:sub(5,6))}\nen","completion":""}
{"prompt":"-- Return the singular or plural word.\nlocal function plural(quantity, singular, plural)\n  if quantity == 1 then return singular\n  else return plural end\nen","completion":""}
{"prompt":"-- Rounds a number upward to its nearest integer\n-- Arguments\n-- ---------\n-- value: number to be rounded upward\nlocal function ceil(value)\n\treturn math.ceil(value)\nen","completion":""}
{"prompt":"-- Undo normalization step of `encode_2theta_np()`\n-- This converts values from the range (0, 1) to (-1, 1)\n-- by subtracting 0.5 and multiplying by 2.0.\n-- This function does not take any steps to ensure\n-- the input obeys the law:\n-- sin ** 2 + cos ** 2 == 1\n-- Since the values may have been generated by a neural network\n-- it is important to fix this w.r.t. the provided values.\n-- # Arguments\n-- norm_sin2_cos2: normalized sin(2*theta) cos(2*theta)\n-- # Returns\n-- return actual sin(2*theta) cos(2*theta)\nlocal function denorm_sin2_cos2(norm_sin2_cos2)\n    norm_sin2_cos2 = norm_sin2_cos2 - 0.5\n    norm_sin2_cos2 = norm_sin2_cos2 * 2.0\n    return norm_sin2_cos2\nen","completion":""}
{"prompt":"-- Generates the next term of the Collatz sequence, given the previous term x\nlocal function collatz(x)\n  if x % 2 == 0 then\n    return x \/ 2\n  else\n    return 3 * x + 1\n  end\nen","completion":""}
{"prompt":"-- Easing function for animations: Quadratic Ease Out.\nlocal function quadratic_easeout(pos)\n\treturn -pos * (pos - 2)\nen","completion":""}
{"prompt":"-- Given the audio path, it returns the ground truth label.\n-- Define HERE a new dataset to employ this code with other data.\nlocal function path2gt_datasets(path, dataset)\n    if dataset == 'audioset' then\n        return path2gt_audioset(path)\n    elseif dataset == 'maestro' then\n        return path2gt_maestro(path)\n    else\n        print(string.format('%s dataset not available!', dataset))\n        os.exit()\n    end\nen","completion":""}
{"prompt":"-- Bound x between m and M.\n-- Parameters\n-- ----------\n-- x : float\n-- Value.\n-- m : float\n-- Lower bound.\n-- M : float\n-- Upper bound.\nlocal function bound(x, m, M)\n    return math.min(M, math.max(m, x))\nen","completion":""}
{"prompt":"-- Tabulates the total expected cost of given endlcasses from a run.\n-- Parameters\n-- ----------\n-- endclasses : dict\n-- Dictionary of end-state classifications with 'expected cost' attributes\n-- Returns\n-- -------\n-- totalcost : Float\n-- The total expected cost of the scenarios.\nlocal function totalcost(endclasses)\n    local totalcost = 0\n    for i in pairs(endclasses) do\n        totalcost = totalcost + endclasses[i]['expected cost']\n    end\n    return totalcost\nen","completion":""}
{"prompt":"-- Computes the dot product of two vectors u and v, each represented \n-- as a tuple or list of coordinates. Assume the two vectors are the\n-- same length.\nlocal function dot_product(u, v)\n  local sum = 0\n  for i = 1, #u do\n    sum = sum + u[i] * v[i]\n  end\n  return sum\nen","completion":""}
{"prompt":"-- :type n: int\n-- :rtype: int\nlocal function climb_stairs(n)\n    local dp = {}\n    dp[0] = 1\n    dp[1] = 1\n    dp[2] = 2\n    for i = 3, n do\n        dp[i] = dp[i - 1] + dp[i - 2]\n    end\n    return dp[n]\nen","completion":""}
{"prompt":"-- Squared length of a 3d vector.\n-- v (3-tuple): 3d vector\n-- return (float): squared length\nlocal function vect3_length_sqrd(v)\n  return v[1] * v[1] + v[2] * v[2] + v[3] * v[3]\nen","completion":""}
{"prompt":"-- Problem 2\n-- Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:\n-- 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...\n-- By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.\nlocal function p2(max)\n  local a,b = 1,2\n  local sum = 2\n  while a+b < max do\n    local c = a+b\n    a,b = b,c\n    if c % 2 == 0 then sum = sum + c end\n  end\n  return sum\nen","completion":""}
{"prompt":"-- Fancy hello world function. :math:`\\sum_{i=1}^{10} badDocs*BadlyWrittenCode = frustration`\n-- :param some_number: (int) Something to return.\n-- :param mood: (str) A string describing a mood.\n-- :param verbose: (boolean) Where or not to be a gushing hello world program.\n-- :return: (int) some_number\nlocal function hi(some_number, mood, verbose)\n  if verbose then\n    print(\"Verbose!\")\n  end\n  if mood == \"sad\" then\n    print(\"I'm sorry to hear that.\")\n  elseif mood == \"hungry\" then\n    print(\"I'm hungry.\")\n  elseif mood == \"neutral\" then\n    print(\"I'm neutral.\")\n  elseif mood == \"angry\" then\n    print(\"I'm angry.\")\n  else\n    print(\"I'm confused.\")\n  end\n  return some_number\nen","completion":""}
{"prompt":"-- Check for any visits that have been archived\/executed\/scheduled in the\n-- last <dayspan> days, and return a string reporting them to the user.\n-- If nothing has been done lately, returns 0.\nlocal function checkDone(visdict, dayspan)\n    local result = ''\n    for visitdate,visit in pairs(visdict) do\n        if visit.archived or visit.executed or visit.scheduled then\n            if not result then\n                result = string.format('Visits that have been archived\/executed\/scheduled in the last %i days:', dayspan)\n            end\n            local vdate = date.to_string(date.epoch(visitdate), 'dd-mmm-yyyy')\n            local dtime = date.diff(os.time(), visitdate)\n            result = string.format('%s\\n%s (%.1f days ago)', result, vdate, dtime)\n        end\n    end\n    return result\nen","completion":""}
{"prompt":"-- Returns list of numbers produced by truncating consecutive digits of x\nlocal function truncate(x)\n\tlocal num = tonumber(x)\n\tif num < 0 then return \"Please enter a positive number.\" end\n\tlocal str = tostring(x)\n\tlocal ret = {}\n\tfor i=1,string.len(str) do\n\t\ttable.insert(ret, tonumber(string.sub(str,i,i)))\n\tend\n\treturn ret\nen","completion":""}
{"prompt":"-- Wraps ``x`` so m <= x <= M; but unlike ``bound()`` which\n-- truncates, ``wrap()`` wraps x around the coordinate system defined by m,M.\n-- For example, m = -180, M = 180 (degrees), x = 360 --> returns 0.\n-- Args:\n-- x: a scalar\n-- m: minimum possible value in range\n-- M: maximum possible value in range\n-- Returns:\n-- x: a scalar, wrapped\nlocal function wrap(x, m, M)\n  local range = M - m\n  while x < m do\n    x = x + range\n  end\n  while x > M do\n    x = x - range\n  end\n  return x\nen","completion":""}
{"prompt":"-- Generate a header for a count HEAD response.\nlocal function encode_count_header(count)\n\treturn {\n\t\t[\"X-Total-Count\"] = count;\n\t}\nen","completion":""}
{"prompt":"-- Convert a string to a list.\nlocal function to_list(list_str)\n   local result = {}\n   for s in list_str:gmatch(\"%w+\") do\n      result[#result+1] = s\n   end\n   return result\nen","completion":""}
{"prompt":"-- Returns the largest prime factor of n\nlocal function largest_prime_factor(n)\n\tlocal i = 2\n\twhile i * i <= n do\n\t\tif n % i == 0 then\n\t\t\tn = n \/ i\n\t\telse\n\t\t\ti = i + 1\n\t\tend\n\tend\n\treturn n\nen","completion":""}
{"prompt":"-- Check if logging has been started.\nlocal function logging_started()\n\tif logging_started_val then\n\t\treturn true\n\telse\n\t\treturn false\n\tend\nen","completion":""}
{"prompt":"-- :param a:\n-- :param b:\n-- :return:\nlocal function iterative_gcd(a, b)\n  while b ~= 0 do\n    a, b = b, a % b\n  end\n  return a\nen","completion":""}
{"prompt":"-- Prepends \"file:\" to ``url`` if it is likely to refer to a local file\nlocal function as_url(url)\n    if not url or not url:find('^file:') and not url:find('^data:') and not url:find('^%w+:\/\/') then\n        url = 'file:'..url\n    end\n    return url\nen","completion":""}
{"prompt":"-- Take an input title string that was extracted from a filename, and\n-- if there are more periods or underscores than spaces, then replace them\n-- (underscores or periods) with spaces.\nlocal function filter_fname(fname)\n  local periods = fname:gsub('%.', ''):gsub('_', ''):find('%s')\n  local res = fname\n  if periods and periods > fname:find('%s') then\n    res = fname:gsub('%.', ' '):gsub('_', ' ')\n  end\n  return res\nen","completion":""}
{"prompt":"-- Create two new pipeline objects by splitting pipeObj in two directly after pass with index splitIndex.\nlocal function split(pipeObj, splitIndex)\n  local left  = {}\n  local right = {}\n  for i = 1, splitIndex do\n    table.insert(left, pipeObj[i])\n  end\n  for i = splitIndex + 1, #pipeObj do\n    table.insert(right, pipeObj[i])\n  end\n  return {left, right}\nen","completion":""}
{"prompt":"-- Add two numbers\n-- Arguments\n-- ---------\n-- a : float\n-- The first number\n-- b : float\n-- The second number\n-- Returns\n-- -------\n-- c : float\n-- The sum of the two input arguments\nlocal function add(a, b)\n    return a + b\nen","completion":""}
{"prompt":"-- Sieve of Eratosthenes implementation;\n-- Finding prime numbers from 2 to n (inclusive).\nlocal function sieve_of_eratosthenes(n)\n    local is_prime = {}\n    for i = 2, n do\n        is_prime[i] = true\n    end\n    for i = 2, n do\n        if is_prime[i] then\n            for j = 2, n \/ i do\n                is_prime[i * j] = false\n            end\n        end\n    end\n    local primes = {}\n    for i = 2, n do\n        if is_prime[i] then\n            table.insert(primes, i)\n        end\n    end\n    return primes\nen","completion":""}
{"prompt":"-- make_adder\n-- :param n:\n-- :return:\nlocal function make_adder(n)\n    return function (a)\n        a = a + n\n        return a\n    end\nen","completion":""}
{"prompt":"-- Compares two paths to verify whether they're the same.\n-- :param path1: list of nodes.\n-- :param path2: list of nodes.\n-- :return: boolean.\nlocal function same(path1, path2)\n  for i = 1, #path1 do\n    if path1[i] ~= path2[i] then\n      return false\n    end\n  end\n  return true\nen","completion":""}
{"prompt":"-- Return the reference id from a URL\n-- For example:\n-- >>> get_reference_id(\"https:\/\/github.com\/advisories\/GHSA-c9hw-wf7x-jp9j\")\n-- 'GHSA-c9hw-wf7x-jp9j'\nlocal function get_reference_id(url)\n  local reference_id\n  if url:match('^https:\/\/github.com\/advisories\/') then\n    reference_id = url:match('^https:\/\/github.com\/advisories\/([^\/]+)')\n  else\n    reference_id = url:match('^GHSA:([^\/]+)')\n  end\n  return reference_id\nen","completion":""}
{"prompt":"-- swap lsb and msb of a word\nlocal function swap_bytes(word_val)\n\tlocal lsb, msb = bit32.band(word_val, 0xff), bit32.rshift(word_val, 8)\n\treturn lsb * 256 + msb\nen","completion":""}
{"prompt":"-- Return column letter for given column.\nlocal function col_letter(col)\n  local dividend = col\n  local columnName = \"\"\n  local modulo\n  \n  while dividend > 0 do\n    modulo = (dividend - 1) % 26\n    columnName = string.char(65 + modulo) .. columnName\n    dividend = math.floor((dividend - modulo) \/ 26)\n  end\n  \n  return columnName\nen","completion":""}
{"prompt":"-- Return list of `ndim` 1s except at position `dim`, where value is -1.\n-- Parameters\n-- ----------\n-- ndim : int\n-- The number of dimensions of the kernel shape.\n-- dim : int\n-- The axis of the kernel to expand to shape -1.\n-- Returns\n-- -------\n-- shape : list of int\n-- The requested shape.\n-- Examples\n-- --------\n-- >>> _kernel_shape(2, 0)\n-- [-1, 1]\n-- >>> _kernel_shape(3, 1)\n-- [1, -1, 1]\n-- >>> _kernel_shape(4, -1)\n-- [1, 1, 1, -1]\nlocal function _kernel_shape(ndim, dim)\n   if dim < 0 then\n      dim = ndim + dim\n   end\n   local shape = {}\n   for i = 1, ndim do\n      shape[i] = 1\n   end\n   shape[dim + 1] = -1\n   return shape\nen","completion":""}
{"prompt":"-- Splits a collection into slices of the specified length\nlocal function split_every(length, collection)\n\tlocal result = {}\n\tfor i = 1, #collection, length do\n\t\tlocal slice = {}\n\t\tfor j = i, i + length - 1 do\n\t\t\ttable.insert(slice, collection[j])\n\t\tend\n\t\ttable.insert(result, slice)\n\tend\n\treturn result\nen","completion":""}
{"prompt":"-- nPk\n-- >>> permutations(52, 2)\n-- 2652\nlocal function permutations(n, k)\n    local C = 1;\n    for i = 1, k do\n        C = C * n;\n        n = n - 1;\n    end\n    return C\nen","completion":""}
{"prompt":"-- get item by user_click\n-- :param user_click: key userid, value: [itemid1, itemid2]\n-- :return: dict, key itemid value:[userid1, userid2]\nlocal function transfer_user_click(user_click)\n    local item_user = {}\n    for user, item_list in pairs(user_click) do\n        for _, item in pairs(item_list) do\n            local item_set = item_user[item]\n            if not item_set then\n                item_user[item] = {}\n                item_set = item_user[item]\n            end\n            table.insert(item_set, user)\n        end\n    end\n    return item_user\nen","completion":""}
{"prompt":"-- Find the difference between the highest and lowest numbers.\nlocal function programmers(one, two, three)\n    return math.abs(math.max(one, two, three) - math.min(one, two, three))\nen","completion":""}
{"prompt":"-- \"http:\/\/www.website.com#my-anchor\" -> \"http:\/\/www.website.com\"\nlocal function removeAnchor(url)\n\treturn url:gsub(\"#.*$\", \"\")\nen","completion":""}
{"prompt":"-- Get an URL and will return the URL type for display  the true text in the wiki view.\n-- :param url: Ruleset source's URL\n-- :type url: str\n-- :return: A string of URL type (github, patreon or unknown)\nlocal function source_link_type(url)\n  local type = 'unknown'\n  if string.find(url, 'github.com') then\n    type = 'github'\n  elseif string.find(url, 'patreon.com') then\n    type = 'patreon'\n  end\n  return type\nen","completion":""}
{"prompt":"-- Normalize spaces, splits on all kinds of whitespace and rejoins\nlocal function norm_spaces(s)\n\tif s == nil then return nil end\n\treturn string.gsub(string.gsub(string.gsub(s, \"[\\n\\t\\v]\", \" \"), \"%s+\", \" \"), \"%%20\", \" \")\nen","completion":""}
{"prompt":"-- The length of the string after performing the necessary escapes.\n-- Assumes that backslashes and quotes are escaped, and the string is\n-- surrounded with quotes.\nlocal function escaped_length(line)\n\treturn 2 + #line:gsub('\\\\', '\\\\\\\\'):gsub('\"', '\\\\\"')\nen","completion":""}
{"prompt":"-- Wrap the input into a list if it is not already a list.\nlocal function _wrap_into_list(x)\n    if type(x) ~= 'table' then\n        x = {x}\n    end\n    return x\nen","completion":""}
{"prompt":"-- This functions returns geo-coordinates of pixels of image coordinate.\n-- Args:\n-- param geo_matrix: this is a tuple which tells us which image coordinate corresponds\n-- to which geo-coordinates.\n-- type geo_matrix: tuple of 2 list.\n-- param index_pixel: coordinates of our reqired point in image.\n-- type index_pixel: tuple.\n-- Returns: \n-- returns the  geo coodinates of a coordinates of a given pixel in an image\nlocal function get_geoindex(geo_matrix, index_pixel)\n    local geo_row = index_pixel[1] + geo_matrix[1][1]\n    local geo_col = index_pixel[2] + geo_matrix[2][1]\n    return {geo_row, geo_col}\nen","completion":""}
{"prompt":"-- Calculate Greatest Common Divisor (GCD).\n-- >>> greatest_common_divisor(24, 40)\n-- 8\nlocal function greatest_common_divisor(a, b)\n    a, b = math.abs(a), math.abs(b)\n    while b ~= 0 do\n        a, b = b, a % b\n    end\n    return a\nen","completion":""}
{"prompt":"-- Metric as defined on the page\n-- https:\/\/signate.jp\/competitions\/423#evaluation\n-- Args:\n-- low_corr (float): low model spearman\n-- high_corr (float): high model spearman\n-- Returns:\n-- float: final evaluation metric as defined on signate\nlocal function final_metric(low_corr, high_corr)\n    -- low model\n    local low_loss = (1 - low_corr) * (1 - low_corr)\n    -- high model\n    local high_loss = (1 - high_corr) * (1 - high_corr)\n    -- final evaluation metric\n    return low_loss + high_loss\nen","completion":""}
{"prompt":"-- Returns equidistant steps in [a, b] whose number matches num_chunks.\nlocal function linspace(a, b, num_chunks)\n   local step = (b - a) \/ num_chunks\n   local results = {}\n   for i = 0, num_chunks do\n      table.insert(results, a + i * step)\n   end\n   return results\nen","completion":""}
{"prompt":"-- >>> power_level(3, 5, 8)\n-- 4\n-- >>> power_level(122, 79, 57)\n-- -5\n-- >>> power_level(217, 196, 39)\n-- 0\n-- >>> power_level(101, 153, 71)\n-- 4\nlocal function power_level(x, y, num)\n    local rack_id = x + 10\n    return (((rack_id * y + num) * rack_id) % 1000) \/\/ 100 - 5\nen","completion":""}
{"prompt":"-- Convert an iterable of dicts into a big dict indexed by chosen field\n-- I can't think of a better name. 'Tis catchy.\nlocal function mapify_iterable(iter_of_dict, field_name)\n\tlocal ret = {}\n\tfor _,d in pairs(iter_of_dict) do\n\t\tlocal id = d[field_name]\n\t\tret[id] = d\n\tend\n\treturn ret\nen","completion":""}
{"prompt":"-- The cross product of 2 vectors results in a vector orthogonal to both vectors\n-- :param v1: The vector left of the cross symbol\n-- :param v2: The vector right of the cross symbol\n-- :return: The cross between v1 and v2\nlocal function cross(v1, v2)\n    return {\n        v1[2]*v2[3] - v1[3]*v2[2],\n        v1[3]*v2[1] - v1[1]*v2[3],\n        v1[1]*v2[2] - v1[2]*v2[1]\n    }\nen","completion":""}
{"prompt":"-- pulls the ecs instance id from the full arn\nlocal function pull_instance_id(arn)\n    return string.match(arn, \"instance\/(.*)\")\nen","completion":""}
{"prompt":"-- sum\n-- >>> pe6a()\n-- 25164150\nlocal function pe6a(n)\n  local sum = 0\n  local sum1 = 0\n  local sq = 0\n  local sumSq = 0\n  for i=1,n do\n    sq = i*i\n    sumSq = sumSq + sq\n    sum = sum + i\n  end\n  return sum*sum - sumSq\nen","completion":""}
{"prompt":"-- Create character ngrams of the specified length from a string of text\n-- Args:\n-- text_list   (list): Pre-tokenized text token to process.\n-- length      (int):  Length of ngrams to create.\n-- http:\/\/stackoverflow.com\/questions\/18658106\/quick-implementation-of-character-n-grams-using-python\nlocal function create_character_ngrams(text_list, length)\n    local ngrams = {}\n    for i, text in ipairs(text_list) do\n        for j = 1, #text - length + 1 do\n            ngrams[#ngrams + 1] = text:sub(j, j + length - 1)\n        end\n    end\n    return ngrams\nen","completion":""}
{"prompt":"-- Fungsi untuk cek sisa berapa \n-- lagi tebakan yang harus dimasukkan\n-- oleh user\nlocal function cekTebakan(jumlahNyawa, userGuessed, duplicateGuess, display)\n\tif (jumlahNyawa == 0) then\n\t\tdisplay.show(\"Anda kalah! Menang dengan nilai sebanyak \" .. tostring(math.ceil(#userGuessed * 1000)) .. \" kali.\", \"Tebakan anda: \" .. tostring(userGuessed), \"Kembali ke menu\", \"Main Menu\", \"Game Over\")\n\t\tif (duplicateGuess == true) then\n\t\t\treturn 0, {}\n\t\telse\n\t\t\treturn 0, userGuessed\n\t\tend\n\telseif (#userGuessed == 5) then\n\t\tdisplay.show(\"Anda masih punya tebakan. Tidak ada tebakan yang bisa anda lakukan.\", \"Tebakan anda: \" .. tostring(userGuessed), \"Kembali ke menu\", \"Main Menu\", \"Game Over\")\n\t\treturn jumlahNyawa, userGuessed\n\telse\n\t\treturn jumlahNyawa - 1, userGuessed\n\tend\nen","completion":""}
{"prompt":"-- Computes the accuracy of the model based on the number of correctly and incorrectly classified points.\n-- Expresses accuracy as a percentage value.\n-- :param correctly_classified: count of correctly classified data points\n-- :param incorrectly_classified: count of incorrectly classified data points\n-- :return: accuracy score\nlocal function compute_classification_accuracy(correctly_classified, incorrectly_classified)\n   local total_count = correctly_classified + incorrectly_classified\n   return (correctly_classified \/ total_count) * 100\nen","completion":""}
{"prompt":"-- Split string into a list, excluding empty strings\nlocal function _split_csv(string)\n  local list = {}\n  if string and string ~= '' then\n    for word in string.gmatch(string, \"[^,]+\") do\n      word = string.gsub(word, \"%s\", \"\")\n      if word ~= '' then\n        list[#list + 1] = word\n      end\n    end\n  end\n  return list\nen","completion":""}
{"prompt":"-- Determines whether the current line is a valid record in the mutation file that should be processed.\n-- A record is considered invalid if:\n-- - it is a duplicate of the header line\n-- - the line begins with a '#'\n-- - the line is empty\nlocal function is_valid_mutation_record_to_process(raw_header_line, header, line)\n  if raw_header_line == line then\n    -- This is the header line, which we ignore.\n    return false\n  end\n  if string.match(line, \"^#\") then\n    -- This is a comment, which we ignore.\n    return false\n  end\n  if line == \"\" then\n    -- This is an empty line, which we ignore.\n    return false\n  end\n  return true\nen","completion":""}
{"prompt":"-- return a harmonic function\nlocal function dirichlet(x)\n  return 0\nen","completion":""}
{"prompt":"-- A method used to round a number in the way that UsefulUtils rounds.\nlocal function specialRound(number, rounding)\n\tlocal factor = 10 ^ rounding\n\treturn math.floor(number * factor + 0.5) \/ factor\nen","completion":""}
{"prompt":"-- Convert a number into an array of 4 bytes (LSB).\nlocal function convert_uint32_to_array(value)\n  local bytes = {}\n  for i = 4, 1, -1 do\n    table.insert(bytes, bit32.band(value, 0xFF))\n    value = bit32.rshift(value, 8)\n  end\n  return bytes\nen","completion":""}
{"prompt":"-- Attempts to add the given number of people to the list of\n-- existing groups without exceeding the maximum group size.\n-- Modifies the list of existing groups. Returns the number of people\n-- remaining after the attempt.\n-- attempt_to_add_to_existing_groups(int, list(Group), int) -> int\nlocal function add_to_existing_groups(no_people, existing_groups, max_size)\n  local remaining = no_people\n  local no_groups = #existing_groups\n  local group_size = 0\n  for i = 1, no_groups do\n    group_size = group_size + existing_groups[i].no_people\n    if group_size + no_people <= max_size then\n      existing_groups[i].no_people = existing_groups[i].no_people + no_people\n      remaining = 0\n    else\n      existing_groups[i].no_people = max_size - group_size\n      remaining = no_people - (max_size - group_size)\n    end\n    if remaining == 0 then\n      return 0\n    end\n  end\n  return remaining\nen","completion":""}
{"prompt":"-- get file name without extension from a path\nlocal function getNameOnly(filename)\n  return filename:match(\"[^%.]+\") or filename\nen","completion":""}
