{"prompt":"-- Converts minutes to seconds\nlocal function minutes_to_seconds(minutes)\n    return minutes * 60\nen","completion":""}
{"prompt":"-- Return the product of n * (n - 2) * (n - 4) * ...\n-- >>> skip_mul(5) # 5 * 3 * 1\n-- 15\n-- >>> skip_mul(8) # 8 * 6 * 4 * 2\n-- 384\nlocal function skip_mul(n)\n   if n < 2 then\n      return 1\n   end\n   return n * skip_mul(n - 2)\nen","completion":""}
{"prompt":"-- computes res-res pairs included for which to calculate minimum distance features\n-- state num of residues, and nearest neighbour skip e.g. i+3 is nearn=3\nlocal function res_pairs(num_res, nearn)\n    local pairs = {}\n    for i = 1, num_res do\n        for j = i+nearn, num_res do\n            table.insert(pairs, {i, j})\n        end\n    end\n    return pairs\nen","completion":""}
{"prompt":"-- Given a value, force it into a list.\n-- Args:\n-- value:\nlocal function listify(value)\n    local val_type = type(value)\n    if (val_type == \"table\") then\n        return value\n    elseif (val_type == \"number\") then\n        return { value }\n    else\n        return { value }\n    end\nen","completion":""}
{"prompt":"-- Computes the arithmetic mean of a list of numbers.\n-- >>> print(get_value())\n-- [1,2,3]\nlocal function get_value()\n  local data = {1,2,3}\n  local average = {}\n  for i,val in ipairs(data) do\n    average[i] = val\n  end\n  return average\nen","completion":""}
{"prompt":"-- Write an algorithm which computes the number of trailing zeros in\n-- n factorial.\n-- Solution: It's enough to count the power of 5 in the factoring of n!\n-- That is the number of trailing zeros.\nlocal function problem_19_3(n)\n    local count = 0\n    local div_5 = 5\n    while n >= div_5 do\n        count = count + math.floor(n \/ div_5)\n        div_5 = div_5 * 5\n    end\n    return count\nen","completion":""}
{"prompt":"-- Restore the DC values as the DC values are coded as the difference from the previous DC value of the same component\nlocal function restore_dc(data)\n    if not data.dc then return data end\n    for i=1,#data.dc,2 do\n        if data.dc[i] then\n            data.dc[i] = data.dc[i] + data.dc[#data.dc-i+1]\n        end\n    end\n    data.dc = nil\n    return data\nen","completion":""}
{"prompt":"-- Get seat id from row and column.\nlocal function get_seat_id(row, column)\n    return row * 8 + column\nen","completion":""}
{"prompt":"-- check and normalize start argument for rollaxis.\nlocal function _check_start_normalize(start, ndim)\n  start = start or 0\n  if start < 0 then\n    start = start + ndim\n  end\n  return start\nen","completion":""}
{"prompt":"-- \\dir1\\dir2\file.txt -> \/dir1\/dir2\/file.txt\/\n-- \\dir1\\dir2\\         -> \/dir1\/dir2\/\nlocal function no_antislash(path)\n  return path:gsub( \"\\\\\", \"\/\" )\nen","completion":""}
{"prompt":"-- To generate dictinory containing source and target table names.\n-- Args:\n-- table_names(dic):Dictinory with source table name as key and target\n-- table name as value.\n-- Returns:\n-- Returns a dictionary contains source table and target table names\n-- as values for the keys src_table and target_table.\nlocal function get_table_name(table_names)\n  local table_dict = {}\n  for src_table, target_table in pairs(table_names) do\n    table_dict[\"src_table\"] = src_table\n    table_dict[\"target_table\"] = target_table\n  end\n  return table_dict\nen","completion":""}
{"prompt":"-- Format value for directory name.\n-- :param value: value\n-- :type value: float\n-- :return: str\n-- :rtype: str\nlocal function gformat(value)\n    return string.format(\"%.0f\", value)\nen","completion":""}
{"prompt":"-- Returns celsius temperatur that corresponds to fahrenhite temperature input\nlocal function fahrenhite_to_celsius(fahrenhite)\n\tlocal celsius = ((fahrenhite - 32) \/ 9) * 5\n\treturn celsius\nen","completion":""}
{"prompt":"-- Calculates the angular kinetic energy\n-- of an object with moment of inertia 'I'\n-- and angular velocity 'w'\n-- Parameters\n-- ----------\n-- i : float\n-- w: float \n-- Returns\n-- -------\n-- float\nlocal function angular_kinetic_energy(i, w)\n    return 1\/2 * i * w ^ 2\nen","completion":""}
{"prompt":"-- Sum all numbers from 0 to N, recursively.\nlocal function sum_of_n(n)\n    if n == 0 then\n        return 0\n    else\n        return n + sum_of_n(n-1)\n    end\nen","completion":""}
{"prompt":"-- Count instances of testchar at end of teststr.\nlocal function count_end(teststr, testchar)\n\tif not teststr or not testchar then return end\n\tlocal count = 0\n\tfor i = #teststr, 1, -1 do\n\t\tif teststr:sub(i, i) == testchar then\n\t\t\tcount = count + 1\n\t\telse\n\t\t\tbreak\n\t\tend\n\tend\n\treturn count\nen","completion":""}
{"prompt":"-- convert a number from one range (ex 40-119) to another\n-- range (ex 0-30) while keeping the ratio.\nlocal function convert_number(old_max, old_min, new_max, new_min, old_value)\n    return ((new_max - new_min) * (old_value - old_min) \/ (old_max - old_min)) + new_min\nen","completion":""}
{"prompt":"-- Some comments\nlocal function add_two_numbers(A, B)\n\treturn A + B\nen","completion":""}
{"prompt":"-- Returns a list consisting of the elements in the list of lists.\n-- e.g. [[1,2,3],[3,4],[5,6]] -> [1,2,3,3,4,5,6]\nlocal function flatten(list_of_lists)\n    local flat_list = {}\n    for _, list in ipairs(list_of_lists) do\n        for _, element in ipairs(list) do\n            flat_list[#flat_list+1] = element\n        end\n    end\n    return flat_list\nen","completion":""}
{"prompt":"-- Takes bounding boxes that are almost square and makes them exactly square\n-- to deal with rounding errors.\n-- Parameters\n-- ----------\n-- boxes : list of tuple of tuple of int\n-- The bounding boxes to be squared.\n-- Returns\n-- -------\n-- boxes : list of tuple of tuple of int\n-- The squared version of the boxes.\nlocal function square_boxes(boxes)\n  for i = 1, #boxes do\n    local box = boxes[i]\n    local left = box[1][1]\n    local top = box[1][2]\n    local right = box[2][1]\n    local bottom = box[2][2]\n    if left ~= right and top ~= bottom then\n      -- The box is not square, so make it so.\n      if left > right then\n        -- Swap left and right coordinates.\n        local temp = left\n        left = right\n        right = temp\n      end\n      if top > bottom then\n        -- Swap top and bottom coordinates.\n        local temp = top\n        top = bottom\n        bottom = temp\n      end\n      boxes[i] = { { left, top }, { right, bottom } }\n    end\n  end\n  return boxes\nen","completion":""}
{"prompt":"-- Calculate fibonacci\n-- Arguments:\n-- n {integer} -- Index Fibonacci\n-- Returns:\n-- integer -- Calculate number fibonacci\nlocal function fib(n)\n    if n <= 2 then\n        return 1\n    else\n        return fib(n-2) + fib(n-1)\n    end\nen","completion":""}
{"prompt":"-- \"\n-- Scale the signal by the given factor: signal * factor\nlocal function scaled(signal, factor)\n  return signal * factor\nen","completion":""}
{"prompt":"-- Convert database path into API-style path.\nlocal function to_api_path(db_path)\n  return db_path:gsub(\"\/+\", \"\/\"):gsub(\"^\/+\", \"\"):gsub(\"\/+$\", \"\")\nen","completion":""}
{"prompt":"-- Clamps x to [0.0, 1.0]\nlocal function clamp(x) return math.min(1.0, math.max(0.0, x)) en","completion":""}
{"prompt":"-- Truncate a string s to length length, by cutting off the last \n-- (length-4) characters and replacing them with ' ...'\nlocal function trunc(s, length)\n\tif s == nil then\n\t\treturn \"\"\n\tend\n\tif type(s) ~= \"string\" then\n\t\treturn tostring(s)\n\tend\n\tif length == nil or length == 0 then\n\t\treturn \"\"\n\tend\n\tif length >= #s then\n\t\treturn s\n\tend\n\treturn string.sub(s, 1, length - 4) .. \" ...\"\nen","completion":""}
{"prompt":"-- Resturn slope.\n-- Parameters\n-- ----------\n-- Returns\n-- -------\nlocal function slope_i(y0, y1, deltaX)\n    return (y1 - y0) \/ deltaX\nen","completion":""}
{"prompt":"-- Prepend underscores with backslashes.\nlocal function md_escape_underscores(text)\n\treturn text:gsub(\"_\", \"\\\\_\")\nen","completion":""}
{"prompt":"-- Clips (limits) the value to the given limits.\n-- The output is at least `min`, at most `max` and `value` if that value\n-- is between the `min` and `max`.\n-- Args:\n-- value: to be limited to [min, max]\n-- min: smallest acceptable value\n-- max: greatest acceptable value\n-- Returns:\n-- the given value if within [min, max] or min if value is smaller than\n-- min or max if value is greater than max.\nlocal function clip(value, min, max)\n    return math.max(math.min(max, value), min)\nen","completion":""}
{"prompt":"-- Generates a message link from the given Ids\n-- >>> message_link(1, 2, 3)\n-- 'https:\/\/discordapp.com\/channels\/1\/2\/3'\nlocal function message_link(guild_id, channel_id, message_id)\n\treturn string.format(\"https:\/\/discordapp.com\/channels\/%s\/%s\/%s\", guild_id, channel_id, message_id)\nen","completion":""}
{"prompt":"-- file contents into a string\nlocal function file_to_string(filename)\n\tif not filename then return \"\" end\n\tlocal f = io.open(filename, \"r\")\n\tif not f then return \"\" end\n\tlocal s = f:read(\"*all\")\n\tf:close()\n\treturn s\nen","completion":""}
{"prompt":"-- Prints the Usage() statement for this method\nlocal function remTeamBranchUsage(err)\n\tprint(\"Usage: \", SCRIPT_NAME, \"remTeamBranch <team> <branch>\")\n\tprint(\"    where <team> is the name of the team\")\n\tprint(\"          <branch> is the name of the branch\")\n\tif (err ~= nil) then\n\t\tprint(\"    Error: \", err)\n\tend\n\tos.exit()\nen","completion":""}
{"prompt":"-- Is there a one-liner for this?\nlocal function list_on_key(dict_list, key)\n    local ret = {}\n    for _, dict in pairs(dict_list) do\n        local item = dict[key]\n        if item then table.insert(ret, item) end\n    end\n    return ret\nen","completion":""}
{"prompt":"-- Returns a formated list of pars.\n-- Args:\n-- pars (list): A list of PAR objects.\n-- Returns:\n-- The formated list as string\nlocal function format_pars_listing(pars)\n  local formated_pars = \"\"\n  for _, par in ipairs(pars) do\n    formated_pars = formated_pars .. \"    \" .. par:get_name() .. \" - \" .. par:get_description() .. \"\\n\"\n  end\n  return formated_pars\nen","completion":""}
{"prompt":"-- Converts hours to minutes\nlocal function hours_to_minutes(hours)\n\treturn hours * 60\nen","completion":""}
{"prompt":"-- \"Subtracts one from `value`.\n-- Args:\n-- value (int): A number.\n-- Returns:\n-- int: `value` minus one.\nlocal function sub(value)\n    return value - 1\nen","completion":""}
{"prompt":"-- With functools.lru_cache\nlocal function rfib2(n)\n\tif n < 3 then return 1 end\n\treturn rfib2(n-2) + rfib2(n-1)\nen","completion":""}
{"prompt":"-- Find the n-th fibonacci number by naive recursion\nlocal function fib_recursive(n)\n  if n < 2 then\n    return n\n  else\n    return fib_recursive(n - 1) + fib_recursive(n - 2)\n  end\nen","completion":""}
{"prompt":"-- Uses built in math library to get squere root\nlocal function built_sqrt(x)\n\treturn math.sqrt(x)\nen","completion":""}
{"prompt":"-- insert L1 in L in the first places with -1 in L, and return L\nlocal function insert(L1, L)\n   local L2 = {}\n   for i = 1, #L do\n      L2[i] = L[i]\n   end\n   for i = 1, #L1 do\n      L2[i] = L1[i]\n   end\n   return L2\nen","completion":""}
{"prompt":"-- This function mimics the behaviour of underscore js unescape function\n-- The html unescape by jinja is not compatible for underscore escape\n-- function\n-- :param text: input html text\n-- :return: unescaped text\nlocal function underscore_unescape(text)\n    text = string.gsub(text, '%%(%x%x)', function(h) return string.char(tonumber(h, 16)) end)\n    text = string.gsub(text, '%%(%x)', function(h) return string.char(tonumber(h, 16)) end)\n    text = string.gsub(text, '&quot;', '\"')\n    text = string.gsub(text, '&#(%d+);', function(h) return string.char(h) end)\n    text = string.gsub(text, '&#x(%d+);', function(h) return string.char(tonumber(h, 16)) end)\n    text = string.gsub(text, '&amp;', '&')\n    text = string.gsub(text, '&gt;', '>')\n    text = string.gsub(text, '&lt;', '<')\n    return text\nen","completion":""}
{"prompt":"-- Take a string and reverse all words 5+ characters.\nlocal function spin_words(sentence)\n  local words = {}\n  for word in sentence:gmatch(\"%w+\") do\n    if #word >= 5 then\n      table.insert(words, word:reverse())\n    else\n      table.insert(words, word)\n    end\n  end\n  return table.concat(words, \" \")\nen","completion":""}
{"prompt":"-- >>> limit_sub_bbox((0, 1, 10, 11), (-1, -1, 9, 8))\n-- (0, 1, 9, 8)\n-- >>> limit_sub_bbox((0, 0, 10, 10), (5, 2, 18, 18))\n-- (5, 2, 10, 10)\nlocal function limit_sub_bbox(bbox, sub_bbox)\n    if sub_bbox[1] < bbox[1] then\n        sub_bbox[1] = bbox[1]\n    end\n    if sub_bbox[2] < bbox[2] then\n        sub_bbox[2] = bbox[2]\n    end\n    if sub_bbox[3] > bbox[3] then\n        sub_bbox[3] = bbox[3]\n    end\n    if sub_bbox[4] > bbox[4] then\n        sub_bbox[4] = bbox[4]\n    end\n    return sub_bbox\nen","completion":""}
{"prompt":"-- Replaces '\"root\/' with '\"path_to_root\/' and 'root\/' with \n-- '\"path_to_root\"\/.\nlocal function replace_root_with_path(run_command, path)\n\tpath = path:gsub('\\\\', '\/')\n\treturn string.gsub(run_command, '\"root\/', '\"' .. path .. '\/')\nen","completion":""}
{"prompt":"-- Limit value to symmetric range.\n-- Args:\n-- val: Value to be adjusted.\n-- limit: Absolute value of return value will not be greater than this.\n-- Returns:\n-- The input value limited to the range [-limit,+limit].\nlocal function clamp(val, limit)\n  return math.max(-limit, math.min(limit, val))\nen","completion":""}
{"prompt":"-- Build a list of flags from given pairs (option, is_enabled).\n-- Each option is prefixed with a single '-'.\n-- Include only options for which is_enabled=True.\nlocal function _build_command_options(options)\n  local result = {}\n  for _, option in ipairs(options) do\n    local option_name = option[1]\n    local option_enabled = option[2]\n    if option_enabled then\n      result[#result + 1] = '-' .. option_name\n    end\n  end\n  return result\nen","completion":""}
{"prompt":"-- Args:\n-- diagnostic_freq: A dictionary with key = diagnostic and value = frequency\n-- Returns:\n-- The clarity of the diagnostic, defined at the frequency of the \n-- most likely disease.\nlocal function diagnostic_clarity(diagnostic_freq)\n    local highest_disease = nil\n    for disease, freq in pairs(diagnostic_freq) do\n        if (highest_disease == nil) or (freq > diagnostic_freq[highest_disease]) then\n            highest_disease = disease\n        end\n    end\n    return diagnostic_freq[highest_disease]\nen","completion":""}
{"prompt":"-- Assuming the given name adheres to the naming convention of crab this\n-- will extract the counter element of the name.\n-- :param given_name: Name to extract from\n-- :type given_name: str or pm.nt.DependNode\n-- :return: int\nlocal function get_counter(given_name)\n  local name = given_name\n  if type(given_name) == \"userdata\" then\n    name = given_name.name()\n  end\n  local counter_string = string.match(name, \"crab_%d+\")\n  return tonumber(string.sub(counter_string, string.len(\"crab_\") + 1))\nen","completion":""}
{"prompt":"-- Calculate the difference between the best score and the current score, as a percentage\n-- relative to the best score.\n-- A negative result indicates that the current score is higher than the best score\n-- Parameters\n-- ----------\n-- curr_score : float\n-- The current score\n-- best_score : float\n-- The best score\n-- Returns\n-- -------\n-- float\n-- The relative score in percent\nlocal function calculate_relative_metric(curr_score, best_score)\n    if curr_score == best_score then\n        return 0\n    else\n        return 100 * (best_score - curr_score) \/ best_score\n    end\nen","completion":""}
{"prompt":"-- Calculates the percentage along a line from **MinValue** to\n-- **MaxValue** that value is.\n-- :param MinValue: Minimum Value\n-- :param MaxValue: Maximum Value\n-- :param Value: Input value\n-- :returns: The percentage (from 0.0 to 1.0) betwen the two values where\n-- input value is\nlocal function GetRangePct(MinValue, MaxValue, Value)\n  local Range = MaxValue - MinValue\n  if Range == 0 then\n    return 0.5\n  end\n  return (Value - MinValue) \/ Range\nen","completion":""}
{"prompt":"-- Search through a list of dictionary for particular key value pair.\n-- :param list dict_list: list of dictionaries\n-- :param str search_key: the key to search for\n-- :param search_value: the value to look for\n-- :return: a list of matching dictionaries\n-- :rtype: list\nlocal function search_dictionary_list(dict_list, search_key, search_value)\n    if not dict_list or not search_key or not search_value then\n        return nil, \"bad arguments\"\n    end\n    local results = {}\n    for _, v in pairs(dict_list) do\n        if v[search_key] == search_value then\n            table.insert(results, v)\n        end\n    end\n    return results\nen","completion":""}
{"prompt":"-- Return a*a + b*b, where a and b are the two smallest members of the\n-- positive numbers x, y, and z.\n-- >>> two_of_three(1, 2, 3)\n-- 5\n-- >>> two_of_three(5, 3, 1)\n-- 10\n-- >>> two_of_three(10, 2, 8)\n-- 68\n-- >>> two_of_three(5, 5, 5)\n-- 50\nlocal function two_of_three(x, y, z)\n  local a = x\n  local b = y\n  if x > y then a = y; b = x end\n  if z < b then b = z end\n  return a * a + b * b\nen","completion":""}
{"prompt":"-- Transforms samples `u` drawn from the unit cube to samples to those\n-- from our uniform prior within [-10., 10.) for each variable.\nlocal function ptform(u)\n  -- Transform to have mean zero and std 1.\n  u = u * 20. - 10.\n  return u\nen","completion":""}
{"prompt":"-- Returns the *value* limited between *minimum* and *maximum*\n-- whereby the *maximum* wins over the *minimum*.\n-- Example:\n-- >>> clamp(64, 0, 255)\n-- 64\n-- >>> clamp(-128, 0, 255)\n-- 0\n-- >>> clamp(0, 127, -128)\n-- -128\nlocal function clamp(value, minimum, maximum)\n    return math.min(maximum, math.max(minimum, value))\nen","completion":""}
{"prompt":"-- Zagotovimo da je vrednost med 0(min) in 100(max)\nlocal function porezi(val, min, max)\n    if (val < min) then\n        val = min\n    elseif (val > max) then\n        val = max\n    end\n    return val\nen","completion":""}
{"prompt":"-- year -> 1 if leap year, else 0.\nlocal function _is_leap(year)\n    if (year % 4 == 0 and year % 100 ~= 0) or year % 400 == 0 then\n        return 1\n    else\n        return 0\n    end\nen","completion":""}
{"prompt":"-- Calculate the power level for the specified cell.\nlocal function power_level(x, y, serial_number)\n\tlocal rack_id = x + 10\n\tlocal start = rack_id * y\n\tlocal power = ((start + serial_number) * rack_id)\n\tpower = math.floor(power \/ 100) % 10 - 5\n\treturn power\nen","completion":""}
{"prompt":"-- Assuming you have a symetric nxn matrix M and take the entries of the upper triangular including the\n-- diagonal and then ravel it to transform it into a list. This function will transform a matrix location\n-- given row i and column j into the proper list index.\n-- :param i: row index of the matrix M\n-- :param j: column index of matrix M\n-- :param n: total number of rows \/ colums of n\n-- :return: The correct index of the lost\nlocal function ij_to_list_index(i, j, n)\n    return (i * n + j) - ((i * (i + 1)) \/ 2);\nen","completion":""}
{"prompt":"-- Parse and validate a given team number.\nlocal function valid_team_number(x, min_team_num, max_team_num)\n\tmin_team_num = min_team_num or 0\n\tmax_team_num = max_team_num or 255\n\tif x == \"\" then\n\t\treturn \"\"\n\tend\n\tlocal ok, err = pcall(tonumber, x)\n\tif ok then\n\t\tlocal x = math.floor(x)\n\t\tif x >= min_team_num and x <= max_team_num then\n\t\t\treturn x\n\t\tend\n\tend\n\treturn nil, err\nen","completion":""}
{"prompt":"-- @param      none        if True and all values are empty, return None\n-- @return                 the list of types recognized by guess_type_value\nlocal function guess_type_value_type(none)\n    local types = {}\n    if not none then\n        if guess_type_value_str_type ~= '' then\n            types[#types + 1] = guess_type_value_str_type\n        end\n        if guess_type_value_int_type ~= '' then\n            types[#types + 1] = guess_type_value_int_type\n        end\n        if guess_type_value_num_type ~= '' then\n            types[#types + 1] = guess_type_value_num_type\n        end\n        if guess_type_value_bool_type ~= '' then\n            types[#types + 1] = guess_type_value_bool_type\n        end\n        if guess_type_value_time_type ~= '' then\n            types[#types + 1] = guess_type_value_time_type\n        end\n        if guess_type_value_date_type ~= '' then\n            types[#types + 1] = guess_type_value_date_type\n        end\n    end\n    return types\nen","completion":""}
{"prompt":"-- Converts a int to an array of 2 bytes (little endian)\n-- :param int value: int value to convert to list\n-- :return list[int]: list with 2 bytes\nlocal function convert_uint16_to_array(value)\n    return { value % 256, math.floor(value \/ 256) }\nen","completion":""}
{"prompt":"-- For the single progenitor models (for progenitor cells only)\nlocal function mean_clone_size_fit(times, rlam)\n  return rlam * times + 1\nen","completion":""}
{"prompt":"-- Map r, g, b values to a hex string.\nlocal function rgb_to_hex(r, g, b)\n  return string.format(\"%02x%02x%02x\", r, g, b)\nen","completion":""}
{"prompt":"-- Identifies the list of candidate neurons in the destination cortical area that based on the rules defined by\n-- source cortical area are suitable fit for synapse creation.\n-- Args:\n-- src_cortical_area:\n-- src_neuron_id:\n-- dst_cortical_area:\n-- Returns:\n-- List of candidate Neurons\nlocal function neighbor_candidate_generator(src_cortical_area, src_neuron_id, dst_cortical_area)\n\t-- TODO: Identify the set of neurons in the destination cortical area that based on the rules defined by\n\t-- source cortical area are suitable fit for synapse creation.\n\treturn {}\nen","completion":""}
{"prompt":"-- The state dicts prefixes don't match (ours is bert.xyz,\n-- their's is model.model.xyz. This function alters the\n-- naming in their state_dict to match\nlocal function modify_authors_state_dict(state_dict)\n    local new_state_dict = {}\n    for k, v in pairs(state_dict) do\n        -- print(k)\n        local new_key = string.gsub(k, \"model.model\", \"bert\")\n        new_state_dict[new_key] = v\n    end\n    return new_state_dict\nen","completion":""}
{"prompt":"-- Overlaps to dictionaries with each other. This method does apply changes\n-- to the given dictionary instances.\n-- Examples:\n-- >>> overlap_branches(\n-- ...     {\"a\": 1, \"b\": {\"de\": \"ep\"}},\n-- ...     {\"b\": {\"de\": {\"eper\": 2}}}\n-- ... )\n-- {'a': 1, 'b': {'de': {'eper': 2}}}\n-- >>> overlap_branches(\n-- ...     {},\n-- ...     {\"ne\": {\"st\": \"ed\"}}\n-- ... )\n-- {'ne': {'st': 'ed'}}\n-- >>> overlap_branches(\n-- ...     {\"ne\": {\"st\": \"ed\"}},\n-- ...     {}\n-- ... )\n-- {'ne': {'st': 'ed'}}\n-- >>> overlap_branches(\n-- ...     {\"ne\": {\"st\": \"ed\"}},\n-- ...     {\"ne\": {\"st\": \"ed\"}}\n-- ... )\n-- {'ne': {'st': 'ed'}}\n-- Args:\n-- targetbranch(dict):\n-- Root where the new branch should be put.\n-- sourcebranch(dict):\n-- New data to be put into the sourcebranch.\nlocal function overlap_branches(targetbranch, sourcebranch)\n    for key, value in pairs(sourcebranch) do\n        if type(value) == \"table\" then\n            if type(targetbranch[key]) == \"table\" then\n                overlap_branches(targetbranch[key], value)\n            else\n                targetbranch[key] = value\n            end\n        else\n            targetbranch[key] = value\n        end\n    end\n    return targetbranch\nen","completion":""}
{"prompt":"-- Convert a string with a number to a number by removing common mistakes\n-- in Excel.\n-- Converts ',' to '.'\n-- Removes leading \"'\"\n-- If resulting string can be converted to an int, it is returned as an int,\n-- if not, it is returned as a float. If it can not be converted to a float,\n-- it throws a ValueError.\n-- Parameters\n-- ---------\n-- num: object\n-- The number to be converted.\n-- If it is an int or float, nothing is done with it.\n-- Needs to be convertible into a string.\n-- Returns\n-- ---------\n-- out: int or float\n-- The resulting int or float.\nlocal function format_num(num)\n  if type(num) == \"number\" then\n    return num\n  end\n  local numstr = tostring(num)\n  numstr = numstr:gsub(\",\", \".\")\n  numstr = numstr:gsub(\"^'\", \"\")\n  numstr = numstr:gsub(\"'\", \"\")\n  numstr = numstr:gsub(\"^-\", \"-\")\n  numstr = numstr:gsub(\"^%s+\", \"\")\n  numstr = numstr:gsub(\"%s+$\", \"\")\n  local out = tonumber(numstr)\n  if out then\n    return out\n  else\n    out = tonumber(numstr .. \".0\")\n    if out then\n      return out\n    else\n      error(\"Could not convert '\" .. numstr .. \"' to a number\")\n    end\n  end\nen","completion":""}
{"prompt":"-- returns transit depth in ppm\nlocal function get_transit_depth(Prad, rstar_solar)\n\treturn 1000000 * (Prad\/(4*math.pi*rstar_solar))^2\nen","completion":""}
{"prompt":"-- Uncomment once a commented line\nlocal function unesc(line)\n  local i, j, n, t = 1, 1, #line, {}\n  while j <= n do\n    local c = line:sub(j, j)\n    if c == '\\\\' then\n      c = line:sub(j+1, j+1)\n      if c == '\\\\' then\n        j = j + 1\n      elseif c == 'n' then\n        c = '\\n'\n      elseif c == 't' then\n        c = '\\t'\n      else\n        print('unesc: illegal escape sequence: '..line:sub(j, j+1))\n        os.exit()\n      end\n    end\n    t[#t+1] = c\n    j = j + 1\n  end\n  return table.concat(t)\nen","completion":""}
{"prompt":"-- Computes a to the power of b using recursion\nlocal function power(a, b)\n    if b < 0 then\n        return 1.0 \/ power(a, -b)\n    elseif b == 0 then\n        return 1.0\n    else\n        return a * power(a, b - 1)\n    end\nen","completion":""}
{"prompt":"-- returns Sin[ArcTan[x]] assuming -pi\/2 < x < pi\/2.\nlocal function tan2sin(tan)\n    if tan > 1 then tan = 1 elseif tan < -1 then tan = -1 end\n    local a = math.atan(tan)\n    local s = math.sin(a)\n    return s\nen","completion":""}
{"prompt":"-- Returns the reference to set in sphinx for a given file name\n-- Parameters\n-- ----------\n-- headername : string\n-- name of the input file (full path)\n-- srcdir : part of the name to remove from ref (usually CMAKE_SOURCE_DIR)\nlocal function sphinxref4headername(headername, srcdir)\n    local name = headername\n    if srcdir then\n        name = name:gsub(srcdir, \"\")\n    end\n    return name\nen","completion":""}
{"prompt":"-- Find (and return) all instances of tags in the given tlv structure (as\n-- returned by unpack).  If num_results is specified then at most that many\n-- results will be returned.\nlocal function tlv_find_tags(tlv_data, tags, num_results)\n  local results = {}\n  local cur_result = 1\n  for _, tag in ipairs(tags) do\n    for _, data in ipairs(tlv_data) do\n      if data[1] == tag then\n        results[cur_result] = data\n        if num_results and cur_result == num_results then\n          return results\n        end\n        cur_result = cur_result + 1\n      end\n    end\n  end\n  return results\nen","completion":""}
{"prompt":"-- Convert the IPv4 address string to the IPv4 address integer.\n-- :param str strIPv4Addr: IPv4 address string.\n-- :return: IPv4 address integer.\n-- :rtype: int\n-- Example::\n-- strIPv4Addr    Return\n-- -------------------------\n-- '192.0.2.1' -> 3221225985\n-- Test:\n-- >>> print(_toIPv4AddrInteger('192.0.2.1'))\n-- 3221225985\nlocal function _toIPv4AddrInteger(strIPv4Addr)\n   local n1, n2, n3, n4 = strIPv4Addr:match(\"^(%d+)%.(%d+)%.(%d+)%.(%d+)$\")\n   if n1 and n2 and n3 and n4 then\n      return tonumber(n1) * 16777216 + tonumber(n2) * 65536 + tonumber(n3) * 256 + tonumber(n4)\n   else\n      error(\"Bad IPv4 address string\", 2)\n   end\nen","completion":""}
{"prompt":"-- Converts celsius to fahrenheit.\n-- :param celsius: temperature in celsius.\n-- :return: temperature in fahrenheit\nlocal function celsius_to_fahrenheit(celsius)\n    return celsius * (9 \/ 5) + 32\nen","completion":""}
{"prompt":"-- Calculates the GC-content percentage of the input sequence\n-- Returns the percentage as an integer out of 100\nlocal function gc_content_percent(sequence)\n    -- Gets the total number of A and C nucleotides in the input\n    local total_c, total_a = 0, 0\n    for nucleotide in sequence:gmatch(\"[AC]\") do\n        if nucleotide == \"A\" then total_a = total_a + 1 end\n        if nucleotide == \"C\" then total_c = total_c + 1 end\n    end\n    -- Total number of nucleotides\n    local total = total_c + total_a\n    -- Gets the percentage of C nucleotides and multiply it by 100\n    local c_content_percent = math.ceil(total_c \/ total * 100)\n    -- Gets the percentage of A nucleotides and subtract the percentage of C nucleotides from it, then multiply it by 100\n    local a_content_percent = math.ceil((total_a - total_c) \/ total * 100)\n    -- Sums the two percentages and returns it as an integer out of 100\n    return c_content_percent + a_content_percent\nen","completion":""}
{"prompt":"-- Virtual Temperature\n-- INPUTS:\n-- tempk: Temperature (K)\n-- mixr: Mixing Ratio (kg\/kg)\n-- OUTPUTS:\n-- tempv: Virtual temperature (K)\n-- SOURCE: hmmmm (Wikipedia). This is an approximation\n-- based on a m\nlocal function VirtualTempFromMixR(tempk, mixr)\n\treturn tempk \/ (1 + (mixr * 0.622))\nen","completion":""}
{"prompt":"-- Returns the ASCII decoded version of the given HTML string. This does\n-- NOT remove normal HTML tags like <p>.\nlocal function html_decode(s)\n  s = string.gsub(s, \"&gt;\", \">\")\n  s = string.gsub(s, \"&lt;\", \"<\")\n  s = string.gsub(s, \"&quot;\", \"\\\"\")\n  s = string.gsub(s, \"&#(%d+);\", function(n) return string.char(n) end)\n  s = string.gsub(s, \"&#x(%x+);\", function(n) return string.char(tonumber(n, 16)) end)\n  s = string.gsub(s, \"&amp;\", \"&\")\n  return s\nen","completion":""}
{"prompt":"-- v + w\nlocal function vaddw(v, w)\n    local s = {}\n    for i=1, #v do\n        s[i] = v[i] + w[i]\n    end\n    return s\nen","completion":""}
{"prompt":"-- One coordinate must be zero\nlocal function iatan2(y, x)\n\treturn math.deg(math.atan2(y, x))\nen","completion":""}
{"prompt":"-- Compute number of permutations with specified number of descents\nlocal function permutations(numbers, descents)\n\tlocal result = 1\n\tfor i = 1, descents do\n\t\tresult = result * numbers[i]\n\tend\n\treturn result\nen","completion":""}
{"prompt":"-- Highlight some slot values in the utterance.\n-- Args:\n-- turn(dict): A dictionary of the dialogue turn.\n-- Returns:\n-- highlight_text(str): The dialogue utterance after highlighting.\nlocal function schema_highlight(turn)\n    local highlight_text = turn.text\n    -- Highlight the first slot value.\n    if turn.slot_values then\n        local first_value = next(turn.slot_values)\n        highlight_text = string.gsub(highlight_text, first_value, '<span class=\"highlight\">' .. first_value .. '<\/span>')\n    end\n    return highlight_text\nen","completion":""}
{"prompt":"-- Returns the class methods of agiven class object\n-- :param class_item: Class item to introspect\n-- :type class_item: object\n-- :returns: list -- Class methods\nlocal function get_class_methods(class_item)\n    local method_list = {}\n    if type(class_item) == \"table\" then\n        if class_item.__index then\n            for k,v in pairs(class_item.__index) do\n                if type(k) == \"string\" and type(v) == \"function\" then\n                    table.insert(method_list, k)\n                end\n            end\n        end\n        if class_item.__class then\n            for k,v in pairs(class_item.__class) do\n                if type(k) == \"string\" and type(v) == \"function\" then\n                    table.insert(method_list, k)\n                end\n            end\n        end\n        for k,v in pairs(class_item) do\n            if type(k) == \"string\" and type(v) == \"function\" then\n                table.insert(method_list, k)\n            end\n        end\n    end\n    return method_list\nen","completion":""}
{"prompt":"-- Convert an integer into a string formatted with thousand separators.\n-- Parameters\n-- ----------\n-- integer : int\n-- The integer.\n-- Returns\n-- -------\n-- str\n-- The integer turned into a string.\nlocal function _stringify_int(integer)\n  local integer = tonumber(integer)\n  if integer == nil or integer == 0 then\n    return \"0\"\n  else\n    local sign = \"\"\n    if integer < 0 then\n      sign = \"-\"\n      integer = -integer\n    end\n    local left,num,right = string.match(integer,\"^([^%d]*%d)(%d*)(.-)$\")\n    return sign..(left:gsub(\",\",\"\")..(num:reverse():gsub(\"(%d%d%d)\",'%1,'):reverse())..right)\n  end\nen","completion":""}
{"prompt":"-- Unnormalize numpy array or torch tensor from given norm\n-- range [norm_min, norm_max] to RGB range.\nlocal function unnormalize(img, norm_min, norm_max)\n  if norm_min == norm_max then\n    return img\n  elseif norm_min == 0 and norm_max == 255 then\n    return img\n  else\n    return (img - norm_min) * 255.0 \/ (norm_max - norm_min)\n  end\nen","completion":""}
{"prompt":"-- Convert signed number to 8bit (unsigned)\nlocal function num_to_s8(num)\n  return bit32.band(num, 255)\nen","completion":""}
{"prompt":"-- Assumes t1 and t2 are tuples\n-- Returns a tuple containing elements that are in\n-- both t1 and t2\nlocal function intersect(t1, t2)\n  local temp = {}\n  for _, v1 in pairs(t1) do\n    for _, v2 in pairs(t2) do\n      if v1 == v2 then table.insert(temp, v1) end\n    end\n  end\n  return temp\nen","completion":""}
{"prompt":"-- A fast way to calculate binomial coefficients by Andrew Dalke (contrib).\nlocal function choose(n, k)\n  if k > n or k < 0 then return 0 end\n  if k == 0 or k == n then return 1 end\n  if k == 1 or k == n-1 then return n end\n  local r,d = 1,1\n  for i = 1, k do\n    r = (r * (n-i+1))\/\/i\n    d = (d * i)\/\/i\n  end\n  return r\/\/d\nen","completion":""}
{"prompt":"-- Obtains remote origin URL, if possible. Otherwise it returns empty str.\n-- Args:\n-- None\n-- Returns:\n-- str: The remote origin url or \"\".\nlocal function get_remote_url(repo)\n    if repo == nil then\n        return \"\"\n    end\n    local remote = repo:remotes()[1]\n    if remote == nil then\n        return \"\"\n    end\n    local url = remote:fetch()[1]\n    if url == nil then\n        return \"\"\n    end\n    local url_str = tostring(url)\n    if url_str == nil then\n        return \"\"\n    end\n    return url_str\nen","completion":""}
{"prompt":"-- If the object is not a list already, it converts it to one\n-- Examples:\n-- [1, 2, 3] -> [1, 2, 3]\n-- [1] -> [1]\n-- 1 -> [1]\nlocal function make_list(v)\n  if v == nil then\n    return {}\n  elseif type(v) == 'table' then\n    if #v > 0 then\n      return v\n    else\n      return {v}\n    end\n  else\n    return {v}\n  end\nen","completion":""}
{"prompt":"-- ZigZag-Encodes a number:\n-- -1 = 1\n-- -2 = 3\n-- 0 = 0\n-- 1 = 2\n-- 2 = 4\nlocal function numberToZigZag(n)\n  local result = n << 1;\n  if n < 0 then\n    result = ~result;\n  end\n  return result;\nen","completion":""}
{"prompt":"-- Return the lowerCamelCase variant of an upper camel case string.\nlocal function LowerCamelCase(upperCamelCaseStr)\n\treturn upperCamelCaseStr:sub(1, 1):lower() .. upperCamelCaseStr:sub(2)\nen","completion":""}
{"prompt":"-- given a frame number and a starting pt offset, compute the expected pt for the frame.\n-- Frame is assumed to be an index (0-based)\nlocal function frame_index_to_pts(frame, start_pt, diff_per_frame)\n  return start_pt + frame * diff_per_frame\nen","completion":""}
{"prompt":"-- We need to hEsc the markdown text.\n-- But markdown does an extra layer of escaping `&` inside `href` attributes.\n-- We have to unescape doubly escaped `&`.\nlocal function sanitize(text)\n\treturn (text:gsub(\"&amp;amp;\", \"&amp;\"))\nen","completion":""}
{"prompt":"-- Flip a pattern horizontally\nlocal function hflip_pattern(pattern)\n  local hflip_pattern = {}\n  for i = 1, #pattern do\n    hflip_pattern[#hflip_pattern + 1] = string.reverse(pattern[i])\n  end\n  return hflip_pattern\nen","completion":""}
{"prompt":"-- Remove all spaces, newlines and tabs.\nlocal function remove_all_white_space(string)\n  string = string:gsub(\"%s\", \"\")\n  return string\nen","completion":""}
{"prompt":"-- num: int\n-- size: int\n-- Takes in a number and returns it's binary equivalent.\n-- Adds trailing zeroes at the beginning to make the\n-- length of binary equivalent equal to size.\nlocal function binary(num, size)\n    local bin = \"\"\n    while num > 0 do\n        bin = (num % 2) .. bin\n        num = math.floor(num \/ 2)\n    end\n    while #bin < size do\n        bin = '0' .. bin\n    end\n    return bin\nen","completion":""}
{"prompt":"-- Notices can refer to multiple regulations (CFR parts). If the\n-- CFR part changes, empty out the context that we carry forward.\nlocal function switch_part_context(token_list, carried_context)\n    local new_context = carried_context or {\n        regulation = {},\n        cfr_parts = {},\n        is_amendatory = {},\n        title = {},\n    }\n    local is_amendatory, regulation, cfr_parts, title = token_list[1].is_amendatory, token_list[1].regulation, token_list[1].cfr_parts, token_list[1].title\n    if is_amendatory then\n        table.insert(new_context.is_amendatory, token_list[1].text)\n    end\n    if regulation then\n        table.insert(new_context.regulation, token_list[1].text)\n    end\n    if cfr_parts then\n        table.insert(new_context.cfr_parts, token_list[1].text)\n    end\n    if title then\n        table.insert(new_context.title, token_list[1].text)\n    end\n    return new_context\nen","completion":""}
{"prompt":"-- replaces chars unsuitable for a python name with '_'\nlocal function replace_invalid_chars(s)\n  local s = string.gsub(s, '[^a-zA-Z0-9_]', '_')\n  return s\nen","completion":""}
{"prompt":"-- Input:\n-- i,j elements of {1,2,3,4}\n-- returns the only element of (1,2,3,4) not in the SET {i,j}\nlocal function complement(i, j, k)\n  local t = {}\n  for m = 1, 4 do\n    if m ~= i and m ~= j and m ~= k then\n      table.insert(t, m)\n    end\n  end\n  return t[1]\nen","completion":""}
{"prompt":"-- Replace all using dictionary of find:replace\nlocal function replace_all(text, dict)\n    for i, j in pairs(dict) do\n        text = text:gsub(i, j)\n    end\n    return text\nen","completion":""}
{"prompt":"-- 1-indexed, k-skips, Josephus problem, recursively.\nlocal function josephus_problem_recur(n, k)\n\tif n == 1 then\n\t\treturn 1\n\tend\n\treturn (josephus_problem_recur(n - 1, k) + k - 1) % n + 1\nen","completion":""}
{"prompt":"-- This function parses the Django database configuration in settings.py and\n-- returns a string DSN (https:\/\/en.wikipedia.org\/wiki\/Data_source_name) for\n-- a PostgreSQL database\nlocal function build_dsn_string(db_settings)\n  local dsn = 'postgres:\/\/'\n  if db_settings.USER then dsn = dsn .. db_settings.USER .. ':'\n  else error('Invalid user name for database') end\n  if db_settings.PASSWORD then dsn = dsn .. db_settings.PASSWORD .. '@' end\n  dsn = dsn .. db_settings.HOST .. ':' .. db_settings.PORT .. '\/'\n  if db_settings.NAME then dsn = dsn .. db_settings.NAME end\n  return dsn\nen","completion":""}
{"prompt":"-- returns scaled value from the ranges of the left to right\nlocal function translate(value, left_min, left_max, right_min, right_max)\n\tlocal left_range = left_max - left_min\n\tlocal right_range = right_max - right_min\n\tlocal value_scaled = (value - left_min) \/ left_range\n\tlocal translated_value = right_min + (value_scaled * right_range)\n\treturn translated_value\nen","completion":""}
{"prompt":"-- Transforms a comma-delimited string into a list of strings\nlocal function commalist(commastr)\n\tlocal t = {}\n\tif commastr then\n\t\tfor p in string.gmatch(commastr, \"[^,]+\") do\n\t\t\ttable.insert(t, p)\n\t\tend\n\tend\n\treturn t\nen","completion":""}
{"prompt":"-- Return True if the row has an indel.\n-- Parameters\n-- ----------\n-- r : pandas.Series\n-- VCF row.\n-- Returns\n-- -------\n-- bool\n-- True if the row has an indel.\n-- Examples\n-- --------\n-- >>> from fuc import pyvcf\n-- >>> data = {\n-- ...     'CHROM': ['chr1', 'chr1', 'chr1', 'chr1'],\n-- ...     'POS': [100, 101, 102, 103],\n-- ...     'ID': ['.', '.', '.', '.'],\n-- ...     'REF': ['G', 'CT', 'A', 'C'],\n-- ...     'ALT': ['A', 'C', 'C,AT', 'A'],\n-- ...     'QUAL': ['.', '.', '.', '.'],\n-- ...     'FILTER': ['.', '.', '.', '.'],\n-- ...     'INFO': ['.', '.', '.', '.'],\n-- ...     'FORMAT': ['GT', 'GT', 'GT', 'GT'],\n-- ...     'Steven': ['0\/1', '0\/1', '1\/2', '0\/1'],\n-- ... }\n-- >>> vf = pyvcf.VcfFrame.from_dict([], data)\n-- >>> vf.df\n-- CHROM  POS ID REF   ALT QUAL FILTER INFO FORMAT Steven\n-- 0  chr1  100  .   G     A    .      .    .     GT    0\/1\n-- 1  chr1  101  .  CT     C    .      .    .     GT    0\/1\n-- 2  chr1  102  .   A  C,AT    .      .    .     GT    1\/2\n-- 3  chr1  103  .   C     A    .      .    .     GT    0\/1\n-- >>> vf.df.apply(pyvcf.row_hasindel, axis=1)\n-- 0    False\n-- 1     True\n-- 2     True\n-- 3    False\n-- dtype: bool\nlocal function row_hasindel(r)\n  return #r['REF'] ~= #r['ALT']\nen","completion":""}
{"prompt":"-- Substitute (replace) `x` with `y` in `sexp`, i.e. returns `sexp[y\/x]`\nlocal function subInSexp(sexp, x, y)\n\tif type(sexp) == 'table' then\n\t\tlocal newSexp = {}\n\t\tfor i, v in ipairs(sexp) do\n\t\t\ttable.insert(newSexp, subInSexp(v, x, y))\n\t\tend\n\t\treturn newSexp\n\telseif sexp == x then\n\t\treturn y\n\telse\n\t\treturn sexp\n\tend\nen","completion":""}
{"prompt":"-- Assumes v1 and v2 are equal-length arrays of numbers\n-- Returns Minkowski distance of order p between v1 and v2\nlocal function minkowskiDist(v1, v2, p)\n    local sum = 0\n    for i, _ in ipairs(v1) do\n        sum = sum + (math.abs(v1[i] - v2[i]) ^ p)\n    end\n    return (sum ^ (1 \/ p))\nen","completion":""}
{"prompt":"-- Extract the type from a full tile name (in name:type) format\nlocal function type_from_fullname(tile)\n   local _,_,name,type_ = string.find(tile, \"([^:]*)%:([^:]*)\")\n   if type_ then\n      return type_\n   else\n      return \"default\"\n   end\nen","completion":""}
{"prompt":"-- The vertex form of quadratic function\n-- :reference:https:\/\/en.wikipedia.org\/wiki\/Quadratic_function\n-- :param x: independent variable\n-- :param a: coefficient {a} of quadratic function\n-- :param b: the x coordinates of the vertex\n-- :param c: the y coordinates of the vertex\n-- :return: a * (x - b) ** 2 + c\nlocal function quadratic_vertex(x, a, b, c)\n  return a * (x - b) * (x - b) + c\nen","completion":""}
{"prompt":"-- Input:\n-- :int year\n-- :int month\n-- Output: \n-- :int :number of days in a month\nlocal function days_in_month(year, month)\n    if month == 2 then\n        if (year % 4) ~= 0 then\n            return 28\n        else\n            if (year % 100) ~= 0 then\n                return 29\n            else\n                if (year % 400) ~= 0 then\n                    return 28\n                else\n                    return 29\n                end\n            end\n        end\n    elseif month == 4 or month == 6 or month == 9 or month == 11 then\n        return 30\n    else\n        return 31\n    end\nen","completion":""}
{"prompt":"-- If a string has single or double quotes around it, remove them.\n-- Make sure the pair of quotes match.\n-- If a matching pair of quotes is not found, return the string unchanged.\nlocal function dequote(s)\n  if not s then return s end\n  if string.match(s, '^\\\".*\\\"$') then\n    return string.sub(s, 2, string.len(s) - 1)\n  elseif string.match(s, \"^'.*'$\") then\n    return string.sub(s, 2, string.len(s) - 1)\n  end\n  return s\nen","completion":""}
{"prompt":"-- Multiplies two quaternions.\n-- Parameters\n-- ----------\n-- r : list\n-- Quaternion as a list of four real values ``[rw, rx, ry, rz]``.\n-- q : list\n-- Quaternion as a list of four real values ``[qw, qx, qy, qz]``.\n-- Returns\n-- -------\n-- list\n-- Quaternion :math:`p = rq` as a list of four real values ``[pw, px, py, pz]``.\n-- Notes\n-- -----\n-- Multiplication of two quaternions :math:`p = rq` can be interpreted as applying rotation :math:`r` to an orientation :math:`q`,\n-- provided that both :math:`r` and :math:`q` are unit-length.\n-- The result is also unit-length.\n-- Multiplication of quaternions is not commutative!\n-- References\n-- ----------\n-- .. _mathworld quaternion: http:\/\/mathworld.wolfram.com\/Quaternion.html\nlocal function quaternion_multiply(r, q)\n    return {\n        r[1] * q[1] - r[2] * q[2] - r[3] * q[3] - r[4] * q[4],\n        r[1] * q[2] + r[2] * q[1] + r[3] * q[4] - r[4] * q[3],\n        r[1] * q[3] + r[3] * q[1] + r[4] * q[2] - r[2] * q[4],\n        r[1] * q[4] + r[4] * q[1] + r[2] * q[3] - r[3] * q[2]\n    }\nen","completion":""}
{"prompt":"-- convert something to a list if necessary\n-- :param thing: Maybe a list?\n-- :type thing: str or list\n-- :return: listified thing\n-- :rtype: list\nlocal function to_list(thing)\n  if thing == nil then return {}\n  elseif type(thing) == 'table' then return thing\n  else return {thing} end\nen","completion":""}
{"prompt":"-- Merge an arbitrary number of lists into a single list and dedupe it\n-- Args:\n-- *args: Two or more lists\n-- Returns:\n-- A deduped merged list of all the provided lists as a single list\nlocal function merge_lists()\n  local result = {}\n  for _, l in ipairs(arg) do\n    for _, v in ipairs(l) do\n      if not contains_value(result, v) then\n        table.insert(result, v)\n      end\n    end\n  end\n  return result\nen","completion":""}
{"prompt":"-- Returns `snake_case_str` (e.g. `some_str`) in CamelCase (e.g. `SomeStr`).\n-- :param snake_case_str: A string in `snake_case`\n-- :return: The string in `CamelCase`\nlocal function to_camel_case(snake_case_str)\n  local components = {}\n  for component in snake_case_str:gmatch(\"([^_]+)\") do\n    if #component > 0 then\n      table.insert(components, component:sub(1, 1):upper() .. component:sub(2))\n    end\n  end\n  return table.concat(components)\nen","completion":""}
{"prompt":"-- Returns all text objects present inside a bounding box.\n-- Parameters\n-- ----------\n-- bbox : tuple\n-- Tuple (x1, y1, x2, y2) representing a bounding box where\n-- (x1, y1) -> lb and (x2, y2) -> rt in PDFMiner coordinate\n-- space.\n-- text : List of PDFMiner text objects.\n-- Returns\n-- -------\n-- t_bbox : list\n-- List of PDFMiner text objects that lie inside table.\nlocal function text_in_bbox(bbox, text)\n    bbox = bbox or {}\n    local t_bbox = {}\n    if not text or text == {} then\n        return t_bbox\n    end\n    for _, t in ipairs(text) do\n        if inside(bbox, t.bbox) then\n            table.insert(t_bbox, t)\n        end\n    end\n    return t_bbox\nen","completion":""}
{"prompt":"-- Remove the left most spaces for markdown\n-- >>> trim('remove right ')\n-- 'remove right'\n-- >>> trim(' remove left')\n-- 'remove left'\n-- >>> print(trim(' remove spaces\\n    from block\\n    of text'))\n-- remove spaces\n-- from block\n-- of text\n-- >>> print(\n-- ...     trim(\n-- ...     '    \\n'\n-- ...     '    remove spaces\\n'\n-- ...     '        from block\\n'\n-- ...     '        of text\\n'\n-- ...     '    \\n'\n-- ...     '\\n'\n-- ...     )\n-- ... )\n-- <BLANKLINE>\n-- remove spaces\n-- from block\n-- of text\n-- <BLANKLINE>\n-- <BLANKLINE>\n-- >>> print(trim('    remove spaces\\n  from block\\n  of text\\n    '))\n-- remove spaces\n-- from block\n-- of text\n-- <BLANKLINE>\n-- >>> print(trim('    remove spaces\\n  from block\\n  of text'))\n-- remove spaces\n-- from block\n-- of text\n-- >>> print(trim('\\n  remove spaces\\n    from block\\n  of text'))\n-- <BLANKLINE>\n-- remove spaces\n-- from block\n-- of text\n-- >>> text = '\\nremove spaces  \\n    from block\\nof text'\n-- >>> print('\\n'.join(repr(t) for t in trim(text).splitlines()))\n-- 'remove spaces  '\n-- '    from block'\n-- 'of text'\n-- >>> text = (\n-- ...     '\\nremove spaces'\n-- ...     '\\n    from block'\n-- ... )\n-- >>> print(trim(text))\n-- remove spaces\n-- from block\nlocal function trim(text)\n    text = text:gsub('^%s+','')\n    return text:gsub('%s+$','')\nen","completion":""}
{"prompt":"-- Map value v from original scale [p1, p2] onto standard scale [s1, s2].\n-- Parameters\n-- ----------\n-- p1, p2 : number\n-- Minimum and maximum percentile scores.\n-- s1, s2 : number\n-- Minimum and maximum intensities on the standard scale.\n-- v : number\n-- Value to map.\n-- Returns\n-- -------\n-- r : float\n-- Mapped value.\nlocal function map_onto_scale(p1, p2, s1, s2, v)\n  return (v - p1) \/ (p2 - p1) * (s2 - s1) + s1\nen","completion":""}
{"prompt":"-- solve linear equation\n-- cf. http:\/\/www.slideshare.net\/tmaehara\/ss-18244588\n-- complexity: O(n^3)\n-- used in kupc2012_C\nlocal function givens(A, b)\n  local i, j, n = 1, 2, #A\n  while i < n do\n    if j <= n and A[i][j] ~= 0 then\n      if j == i + 1 then\n        A[i][j], A[i + 1][j] = A[i + 1][j], A[i][j]\n        b[i], b[i + 1] = b[i + 1], b[i]\n      end\n      local c = (A[i][j] < 0) and -A[i][j] or A[i][j]\n      local s = (A[i][j] < 0) and -A[j][j] or A[j][j]\n      local a, b = A[i], A[j]\n      local c2 = math.sqrt(c * c + s * s)\n      c, s = c \/ c2, s \/ c2\n      for k = j + 1, n do\n        local t = a[k] * c + b[k] * s\n        b[k] = b[k] * c - a[k] * s\n        a[k] = t\n      end\n      A[i], A[j] = a, b\n      b[i] = b[i] \/ c\n      for k = 1, n do\n        local t = A[k][j] * c - b[k]\n        b[k] = A[k][j] * s + b[k]\n        A[k][j] = t\n      end\n    end\n    i = i + 1\n    j = j + 1\n  end\n  return b\nen","completion":""}
{"prompt":"-- The canonical definition of the SAM format.\n-- http:\/\/samtools.github.io\/hts-specs\/SAMv1.pdf\n-- FLAG definitions:\n-- 0x1 template having multiple segments in sequencing\n-- 0x2 each segment properly aligned according to the aligner\n-- 0x4 segment unmapped\n-- 0x8 next segment in the template unmapped\n-- 0x10 SEQ being reverse complemented\n-- 0x20 SEQ of the next segment in the template being reversed\n-- 0x40 the first segment in the template\n-- 0x80 the last segment in the template\n-- 0x100 secondary alignment\n-- 0x200 not passing quality controls\n-- 0x400 PCR or optical duplicate\n-- 0x800 supplementary alignment\n-- CIGAR string:\n-- Op BAM Description\n-- M 0 alignment match (can be a sequence match or mismatch)\n-- I 1 insertion to the reference\n-- D 2 deletion from the reference\n-- N 3 skipped region from the reference\n-- S 4 soft clipping (clipped sequences present in SEQ)\n-- H 5 hard clipping (clipped sequences NOT present in SEQ)\n-- P 6 padding (silent deletion from padded reference)\n-- = 7 sequence match\n-- X 8 sequence mismatch\n-- 'name' is the name of the field.\n-- 'type' is a function that should be applied to convert it to the expected type when parsing.\nlocal function sam_format()\n  return {\n    {name=\"QNAME\", type=decode_string},\n    {name=\"FLAG\", type=decode_int},\n    {name=\"RNAME\", type=decode_string},\n    {name=\"POS\", type=decode_int},\n    {name=\"MAPQ\", type=decode_int},\n    {name=\"CIGAR\", type=decode_string},\n    {name=\"RNEXT\", type=decode_string},\n    {name=\"PNEXT\", type=decode_int},\n    {name=\"TLEN\", type=decode_int},\n    {name=\"SEQ\", type=decode_string},\n    {name=\"QUAL\", type=decode_string},\n  }\nen","completion":""}
{"prompt":"-- Summarize the bounces, complaints, delivery attempts and rejects from a\n-- list of datapoints.\nlocal function sum_stats(stats_data)\n  local bounces = 0\n  local complaints = 0\n  local delivery_attempts = 0\n  local rejects = 0\n  for i, stat in ipairs(stats_data) do\n    bounces = bounces + stat.Bounces\n    complaints = complaints + stat.Complaints\n    delivery_attempts = delivery_attempts + stat.DeliveryAttempts\n    rejects = rejects + stat.Rejects\n  end\n  return { Bounces = bounces, Complaints = complaints,\n           DeliveryAttempts = delivery_attempts, Rejects = rejects }\nen","completion":""}
{"prompt":"-- Returns the area of a regular polygon\nlocal function regular_polygon_area(perimeter, apothem)\n    return 0.5 * perimeter * apothem\nen","completion":""}
{"prompt":"-- takes in date from javascript\/flask, and sets the variable hour to\n-- what the hour is\n-- >>> get_hour(\"Tue Apr 23 2019 23:19:57 GMT-0400 (Eastern Daylight Time)\")\n-- '23'\n-- >>> get_hour(\"Wed Apr 24 2019 06:59:38 GMT+0300 (Asia Qatar Standard Time)\")\n-- '06'\nlocal function get_hour(date)\n  local hour = date:match(\".* (%d+):\")\n  return hour\nen","completion":""}
{"prompt":"-- returns a function that can use\nlocal function calculate_Delta_Fixed(delta)\n  return function (m_fixed, m_moving)\n    if m_moving == 0 then\n      return 0\n    end\n    return delta\n  end\nen","completion":""}
{"prompt":"-- This function is used for filter tuple of coordiante. True is returned if abscissa is upper than a given value\n-- In : tuple of float (X,Y) :  tuple of coordinate\n-- In : x : float : limit value\n-- Out : bool :\nlocal function _filter2(tuple, x)\n\treturn tuple[1] > x\nen","completion":""}
{"prompt":"-- Function to convert to Binary number of a Decimal number\n-- args:\n-- num: number in Decimal format to be converted in Binary format\nlocal function binary(num)\n    local bin = \"\"\n    repeat\n        local remainder = num % 2\n        num = math.floor(num\/2)\n        bin = remainder .. bin\n    until num == 0\n    return bin\nen","completion":""}
{"prompt":"-- Return the variance of a list.\nlocal function variance(xl)\n  local x, n = 0, 0\n  for _, xi in ipairs(xl) do\n    n = n + 1\n    x = x + xi\n  end\n  local mean = x \/ n\n  local sum = 0\n  for _, xi in ipairs(xl) do\n    sum = sum + (xi - mean) ^ 2\n  end\n  return sum \/ (n - 1)\nen","completion":""}
{"prompt":"-- \"\n-- Evaluate recall\nlocal function recall_at_position_k_in_10(sort_data, k)\n  local recall_counter = 0\n  for i = 1, #sort_data do\n    if sort_data[i][1] <= k then\n      recall_counter = recall_counter + 1\n    end\n  end\n  local recall = recall_counter \/ #sort_data\n  return recall\nen","completion":""}
{"prompt":"-- SUMMARY:  searches for a tool's ID number using a user-supplied tool name string\n-- INPUT:  1) a tool name (str), and 2) a list of AxiomTool objects\n-- OUTPUT:  a tool ID value (int) or -1 if no match is found\nlocal function resolve_tool_id(potential_tool, tools)\n    if not potential_tool or type(potential_tool) ~= \"string\" then\n        return -1\n    end\n    if not tools or type(tools) ~= \"table\" or not next(tools) then\n        return -1\n    end\n    potential_tool = string.lower(potential_tool)\n    for _, tool in pairs(tools) do\n        if tool.tool_name and string.lower(tool.tool_name) == potential_tool then\n            return tool.tool_id\n        end\n    end\n    return -1\nen","completion":""}
{"prompt":"-- Given a time in seconds, this\n-- function calculates the hours, minutes and seconds\n-- and returns it as a string formatted accordingly.\nlocal function calculate_length(seconds)\n\tlocal result = \"\"\n\tif seconds >= 3600 then\n\t\tlocal hours = math.floor(seconds\/3600)\n\t\tlocal minutes = math.floor(seconds\/60) - hours*60\n\t\tseconds = seconds - (hours*3600 + minutes*60)\n\t\tresult = string.format(\"%02d:%02d:%02d\", hours, minutes, seconds)\n\telse\n\t\tresult = string.format(\"%02d:%02d\", math.floor(seconds\/60), seconds%60)\n\tend\n\treturn result\nen","completion":""}
{"prompt":"-- Quickly checks if a document_id is likely to be valid. Return True \/ False depending on result\nlocal function check_doc_id(txt)\n  return type(txt) == \"string\" and #txt == 24 and (string.match(txt, \"^[a-z0-9]+$\") ~= nil)\nen","completion":""}
{"prompt":"-- Remove URL query string the lazy way\nlocal function remove_qs(url)\n\treturn url:gsub(\"[%?].*$\", \"\")\nen","completion":""}
{"prompt":"-- Returns the union of two rectangles\nlocal function merge_rect(a, b)\n    local top = math.min(a[1], b[1])\n    local left = math.min(a[2], b[2])\n    local bottom = math.max(a[1] + a[3], b[1] + b[3])\n    local right = math.max(a[2] + a[4], b[2] + b[4])\n    return {top, left, bottom - top, right - left}\nen","completion":""}
{"prompt":"-- Counts amount of stars in the given board.\n-- >>> stars_amount_counter([\"**** ****\", \"***1 ****\", \"**  3****\", \"* 4 1****\",    \"7    9 5 \", \" 6  83  *\", \"3   2  **\", \"  8  2***\", \"  2 9****\"])\n-- 36\nlocal function stars_amount_counter(board)\n  local result = 0\n  for i = 1, #board do\n    for j = 1, #board[i] do\n      if board[i]:sub(j, j) == '*' then\n        result = result + 1\n      end\n    end\n  end\n  return result\nen","completion":""}
{"prompt":"-- >>> _as_stac_instruments('TM')\n-- ['tm']\n-- >>> _as_stac_instruments('OLI')\n-- ['oli']\n-- >>> _as_stac_instruments('ETM+')\n-- ['etm']\n-- >>> _as_stac_instruments('OLI_TIRS')\n-- ['oli', 'tirs']\nlocal function _as_stac_instruments(value)\n  if string.upper(value) == 'TM' then\n    return {'tm'}\n  elseif string.upper(value) == 'OLI' then\n    return {'oli'}\n  elseif string.upper(value) == 'ETM+' then\n    return {'etm'}\n  elseif string.upper(value) == 'OLI_TIRS' then\n    return {'oli', 'tirs'}\n  elseif string.upper(value) == 'OLI-TIRS' then\n    return {'oli', 'tirs'}\n  elseif string.upper(value) == 'L7' then\n    return {'landsat-7'}\n  elseif string.upper(value) == 'L8' then\n    return {'landsat-8'}\n  elseif string.upper(value) == 'PHOENIX' then\n    return {'phoenix'}\n  elseif string.upper(value) == 'OLI\/TIRS' then\n    return {'oli', 'tirs'}\n  elseif string.upper(value) == 'OLI-TIRS' then\n    return {'oli', 'tirs'}\n  elseif string.upper(value) == 'ETM' then\n    return {'etm'}\n  elseif string.upper(value) == 'ETM+' then\n    return {'etm'}\n  else\n    return {value}\n  end\nen","completion":""}
{"prompt":"-- Return either \"1 element\" or \"N elements\" depending on the argument.\nlocal function num_elements(num)\n  return (num == 1) and \"1 element\" or (\"%d elements\"):format(num)\nen","completion":""}
{"prompt":"-- Revert escaped characters back to their special version.\n-- For example, \\n => newline and \\t => tab\nlocal function unescape(s)\n    -- Don't unescape a string unless it's escaped.\n    if not s:match(\"\\\\\") then\n        return s\n    end\n    return s:gsub(\"\\\\n\", \"\\n\"):gsub(\"\\\\t\", \"\\t\"):gsub(\"\\\\r\", \"\\r\")\nen","completion":""}
{"prompt":"-- return type of given list\nlocal function get_list_type(param_type)\n\tif param_type == \"nil\" then\n\t\treturn \"nil\"\n\telseif param_type == \"number\" or param_type == \"integer\" then\n\t\treturn \"integer\"\n\telseif param_type == \"string\" then\n\t\treturn \"string\"\n\telseif param_type == \"table\" then\n\t\treturn \"table\"\n\telseif param_type == \"boolean\" then\n\t\treturn \"boolean\"\n\telseif param_type == \"userdata\" then\n\t\treturn \"userdata\"\n\tend\nen","completion":""}
{"prompt":"-- Creates a string with a pleasant style to display ip address\/hostnames\n-- in the Jira issue description=.\n-- :param hosts: a list of dictionaries\n-- :return: string\nlocal function create_host_string(hosts)\n    local host_string = ''\n    if hosts ~= nil and next(hosts) ~= nil then\n        local last_host = nil\n        for i, host in ipairs(hosts) do\n            if last_host == nil then\n                host_string = host.name\n            else\n                host_string = host_string .. ', ' .. host.name\n            end\n            last_host = host\n        end\n    end\n    return host_string\nen","completion":""}
{"prompt":"-- calculate celcius to farenheit\nlocal function celcius_to_farenheit(x)\n    return (x * 9\/5) + 32\nen","completion":""}
{"prompt":"-- Extracts an int from a string.\n-- Returns a 0 if None or an empty string was passed.\nlocal function _number(string)\n  return tonumber(string) or 0\nen","completion":""}
{"prompt":"-- Returns the area of a rhombus\nlocal function rhombus_area(diagonal_1, diagonal_2)\n\treturn diagonal_1 * diagonal_2 \/ 2\nen","completion":""}
{"prompt":"-- Check no non-alphanumerics and convert to lowercase.\nlocal function fix_wg_name(wgname)\n\treturn (wgname:gsub(\"[^%w]\", \" \"):gsub(\"^%s*(.-)%s*$\", \"%1\"):gsub(\"%s+\", \" \"):lower())\nen","completion":""}
{"prompt":"-- Creates a number string with at most 8 leading zeros.\n-- :param number: integer\n-- :return: number string with leading zeros\nlocal function zfill_int(number)\n    local str = tostring(number)\n    if str:len() < 8 then\n        return string.format('%08d', number)\n    end\n    return str\nen","completion":""}
{"prompt":"-- Return manhattan distance between a and b\nlocal function manhat_dist(a, b)\n\tlocal ret = 0\n\tfor i, v in ipairs(a) do\n\t\tret = ret + math.abs(v-b[i])\n\tend\n\treturn ret\nen","completion":""}
{"prompt":"-- Parse a string and strip the extra characters.\nlocal function to_str(s)\n  return string.gsub(s, \"^%s*(.-)%s*$\", \"%1\")\nen","completion":""}
{"prompt":"-- Return the argument quoted, suitable for a quoted-string\nlocal function quote_it(s)\n\ts = s:gsub(\"\\\\\", \"\\\\\\\\\"):gsub(\"\\\"\", \"\\\\\\\"\")\n\treturn \"\\\"\" .. s .. \"\\\"\"\nen","completion":""}
{"prompt":"-- Select correct ordinal suffix\nlocal function get_grade_suffix(grade)\n\tif grade % 10 == 1 and grade % 100 ~= 11 then\n\t\treturn \"st\"\n\telseif grade % 10 == 2 and grade % 100 ~= 12 then\n\t\treturn \"nd\"\n\telseif grade % 10 == 3 and grade % 100 ~= 13 then\n\t\treturn \"rd\"\n\telse\n\t\treturn \"th\"\n\tend\nen","completion":""}
{"prompt":"-- Get the normalized list of words from a message string.\n-- This function should split a message into words, normalize them, and return\n-- the resulting list. For splitting, you should split on spaces. For normalization,\n-- you should convert everything to lowercase.\n-- Args:\n-- message: A string containing an SMS message\n-- Returns:\n-- The list of normalized words from the message.\nlocal function get_words(message)\n  local message_words = {}\n  \n  -- TODO: Implement this function!\n  for word in message:gmatch(\"%S+\") do\n    message_words[#message_words + 1] = word:lower()\n  end\n  return message_words\nen","completion":""}
{"prompt":"-- Convert a 4-tuple 'help_options' list as found in various command\n-- classes to the 3-tuple form required by FancyGetopt.\nlocal function fix_help_options(options)\n    local fixed_options = {}\n    for _, opt in ipairs(options) do\n        table.insert(fixed_options, {opt[1], opt[2], opt[3]})\n    end\n    return fixed_options\nen","completion":""}
{"prompt":"-- Defining utility function. \n-- Args:\n-- z(float): parameter \n-- theta(float): parameter\n-- Returns:\n-- Utility of assets\nlocal function u(z, theta)\n  if theta == 0 then\n    return z\n  else\n    return z^theta\n  end\nen","completion":""}
{"prompt":"-- rotates the direction clockwise\nlocal function right(direction)\n\treturn (direction + 1) % 4\nen","completion":""}
{"prompt":"-- Return the Postgres or MySQL function call to get the current DB\n-- server time\n-- :param element:  The element being construct\n-- :param compiler:  The compiler for postgresql\n-- :param kw:  Any additional argument\n-- :return: Postgres or MySQL function name for generating current timestamp\nlocal function postgres_current_timestamp(element, compiler)\n    return \"CURRENT_TIMESTAMP\"\nen","completion":""}
{"prompt":"-- Clean up a multiline description.\nlocal function cleanup_description(desc)\n  desc = desc:gsub( \"\\r\\n\", \" \" ):gsub( \"\\n\", \" \" ):gsub( \"\\r\", \" \" )\n  desc = desc:gsub( \"[%s]+\", \" \" ):gsub( \"^%s*(.-)%s*$\", \"%1\" )\n  desc = desc:gsub( \"^(.-)%s+$\", \"%1\" ):gsub( \"%s+\", \" \" )\n  desc = desc:gsub( \"^(.-) (%d+%d+)$\", \"%1 %2\" )\n  return desc\nen","completion":""}
{"prompt":"-- Splits \"foo, bar, baz\" into [\"foo\", \"bar\", \"baz\"]\nlocal function split_scopes(scopes)\n    local ret = {}\n    for scope in string.gmatch(scopes, \"[^,]+\") do\n        scope = scope:match(\"^%s*(.-)%s*$\")\n        table.insert(ret, scope)\n    end\n    return ret\nen","completion":""}
{"prompt":"-- Find number of points in a downsampled N-vector given a rate conversion new_rate:old_rate\n-- Parameters\n-- ----------\n-- N: int\n-- Original vector length\n-- rate_change: int\n-- The old-rate:new-rate ratio (must be an integer > 1)\n-- Returns\n-- -------\n-- P: int\n-- Downsampled vector length\nlocal function calc_new_samples(N, rate_change)\n\tassert(type(N) == \"number\", \"Invalid input: N must be a number\")\n\tassert(type(rate_change) == \"number\", \"Invalid input: rate_change must be a number\")\n\tassert(rate_change > 1, \"Invalid input: rate_change must be greater than 1\")\n\treturn math.ceil((N \/ rate_change))\nen","completion":""}
{"prompt":"-- clean out initials in authorship names\nlocal function clean_names(messyname)\n\tlocal messyname = messyname or \"?\"\n\tlocal name = string.match(messyname, \"^%s*([^%s]+)%s*$\")\n\tif name then\n\t\tname = string.gsub(name, \"^(%S+)%s(%S+)$\", \"%1%2\")\n\t\tname = string.gsub(name, \"^(%S+)%s%(%S+%)$\", \"%1\")\n\t\tname = string.gsub(name, \"^%s*(%S+)%s*$\", \"%1\")\n\t\treturn name\n\telse\n\t\treturn messyname\n\tend\nen","completion":""}
{"prompt":"-- Cityscapes class names for external use.\nlocal function cityscapes_classes()\n  return {\n    'road',\n    'sidewalk',\n    'building',\n    'wall',\n    'fence',\n    'pole',\n    'traffic light',\n    'traffic sign',\n    'vegetation',\n    'terrain',\n    'sky',\n    'person',\n    'rider',\n    'car',\n    'truck',\n    'bus',\n    'train',\n    'motorcycle',\n    'bicycle',\n  }\nen","completion":""}
{"prompt":"-- Return a path with quotes added if it contains spaces.\nlocal function quote(path)\n\treturn path:match(\" \") and ('\"%s\"'):format(path) or path\nen","completion":""}
{"prompt":"-- The event-related de\/sync formula. Output is in percents.\n-- If result is < 0, than what we have is ERD. Positive numbers denote ERS.\nlocal function erd(active, rest)\n\treturn (active - rest) \/ rest * 100\nen","completion":""}
{"prompt":"-- Return 0 if it's below threshold, otherwise difference.\n-- :param float value:\n-- :param float threshold:\nlocal function rectify(value, threshold)\n  if value < threshold then\n    return 0\n  end\n  return value - threshold\nen","completion":""}
{"prompt":"-- Make sure n is between minn and maxn\n-- Args:\n-- n (number): Number to clamp\n-- minn (number): minimum number allowed\n-- maxn (number): maximum number allowed\nlocal function clamp(n, minn, maxn)\n\treturn math.max(minn, math.min(n, maxn))\nen","completion":""}
{"prompt":"-- Convert a frequency in the units of the data into normalised frequency.\n-- Useful for computing input arguments in {high|low}Pass()\n-- Inputs:\n-- f           (float) Frequency in, e.g, Hz\n-- timespace   (float) Range of data in , eg, seconds. This is the time\n-- interval between the last and first data points in your\n-- set.\nlocal function normaliseFrequency(f, timespan)\n  local freq = f\/timespan\n  return freq\nen","completion":""}
{"prompt":"-- Convert the input str to an int if possible\n-- :param _str: input string\n-- :return: integer if text is a digit, else string\nlocal function _str_to_int(_str)\n    if string.match(_str, \"^%d+$\") then\n        return tonumber(_str)\n    else\n        return _str\n    end\nen","completion":""}
{"prompt":"-- convert nmea angle (dddmm.mm) to degree\nlocal function nmea2deg(nmea)\n  nmea = tonumber(nmea)\n  return math.floor(nmea\/100) + tonumber(string.format(\"%05.2f\", nmea%100))\/60\nen","completion":""}
{"prompt":"-- Converts a generalized mac address to one for the API.\n-- Takes any standard mac (case-insensitive, with or without colons) and\n-- formats it to uppercase and removes colons.  This is the format for\n-- the API.\n-- :param mac: The input mac.\n-- :returns: The sanitized mac.\nlocal function sanitize_mac_for_api(mac)\n  return string.upper(string.gsub(mac, ':', ''))\nen","completion":""}
{"prompt":"-- Implementation of ramda from_pairs Converts a list of pairs or tuples of pairs to a dict\n-- :param pairs:\n-- :return:\nlocal function from_pairs(pairs)\n  local result = {}\n  for i = 1, #pairs, 1 do\n    local key = pairs[i][1]\n    local value = pairs[i][2]\n    result[key] = value\n  end\n  return result\nen","completion":""}
{"prompt":"-- English language tokenizer.\nlocal function tokenize_english(sentence)\n  -- Tokenize by space.\n  local tokens = {}\n  for token in string.gmatch(sentence, \"%S+\") do\n    table.insert(tokens, token)\n  end\n  return tokens\nen","completion":""}
{"prompt":"-- Method to clamp a value between a certain range.\n-- Args:\n-- value(float): Value to clamp.\n-- min_value(float): Minimum limit to clamp the value with.\n-- max_value(float): Upper limit to clamp the value with.\n-- Returns:\n-- value(float): Value clamped between the maximum and minimum values.\nlocal function clamp(value, min_value, max_value)\n    return math.max(min_value, math.min(max_value, value))\nen","completion":""}
{"prompt":"-- this function returns the int needed to be added to number to make it divisable by divisor\nlocal function add_to_divide(number, divisor)\n  return ((divisor - (number % divisor)) % divisor)\nen","completion":""}
{"prompt":"-- Convert boolean value to 'enabled' or 'disabled'.\nlocal function enabled_disabled(b)\n\treturn b and 'enabled' or 'disabled'\nen","completion":""}
{"prompt":"-- Creates empty score grid for use in mc_move\nlocal function score_grid(dim)\n  local grid = {}\n  for i=1,dim do\n    grid[i] = {}\n    for j=1,dim do\n      grid[i][j] = 0\n    end\n  end\n  return grid\nen","completion":""}
{"prompt":"-- assumes num_list is a dictionary whose values are numerics\n-- returns a list of numerics, of the values over 1000 of num_dict minus 1000\nlocal function over1000minus1000(num_dict)\n  local num_list = {}\n  for key, value in pairs(num_dict) do\n    if value > 1000 then\n      table.insert(num_list, value-1000)\n    end\n  end\n  return num_list\nen","completion":""}
{"prompt":"-- Convert an 8-digit hexadecimal RGBA number to an RGBA tuple.\n-- Args:\n-- rgba (:obj:`int`): 8-digit hex number to convert to a tuple.\n-- Returns:\n-- Tuple[ :obj:`int` ]: RGBA tuple.\nlocal function hex_to_rgba(rgba)\n    return {\n        bit32.band(bit32.rshift(rgba, 24), 0xff),\n        bit32.band(bit32.rshift(rgba, 16), 0xff),\n        bit32.band(bit32.rshift(rgba, 8), 0xff),\n        bit32.band(rgba, 0xff)\n    }\nen","completion":""}
{"prompt":"-- Returns max length of a given attribute from a list of dict items.\nlocal function max_len_list_dict_item(list_dict, attr)\n   local max_len = 0\n   for _, item in ipairs(list_dict) do\n      if #tostring(item[attr]) > max_len then\n         max_len = #tostring(item[attr])\n      end\n   end\n   return max_len\nen","completion":""}
{"prompt":"-- Given a list of open ports, get the next open one from a starting location.\nlocal function getNextPort(ports, num)\n  for i = 0, #ports do\n    local port = num + i\n    if ports[port] == nil then\n      return port\n    end\n  end\nen","completion":""}
{"prompt":"-- Gets the part of the given `content` around the given `index`.\n-- Parameters\n-- ----------\n-- content : `str`\n-- The content, around what the part will be cut out.\n-- index : `str`\n-- The index of around where the part will be cut out.\nlocal function get_part_around(content, index)\n  local start_index = index - 50\n  if start_index < 0 then\n    start_index = 0\n  end\n  local end_index = index + 50\n  if end_index > #content then\n    end_index = #content\n  end\n  return string.sub(content, start_index + 1, end_index)\nen","completion":""}
{"prompt":"-- Recursively replaces all strings in the given object.\n-- This function is specifically meant to help with saving and loading\n-- of config dictionaries and should not be considered a general tool.\nlocal function _replace_strings(obj, old, new, inplace)\n\tif type(obj) == 'table' then\n\t\tfor key, value in pairs(obj) do\n\t\t\tif type(value) == 'string' then\n\t\t\t\tobj[key] = string.gsub(value, old, new)\n\t\t\telseif type(value) == 'table' then\n\t\t\t\t_replace_strings(value, old, new, inplace)\n\t\t\tend\n\t\tend\n\tend\n\treturn obj\nen","completion":""}
{"prompt":"-- Converts ipv4 string representation to local number format\nlocal function ip2num(ipStr)\n  local a, b, c, d = ipStr:match(\"(%d+).(%d+).(%d+).(%d+)\")\n  return a*256*256*256 + b*256*256 + c*256 + d\nen","completion":""}
{"prompt":"-- Fit function for epsilon dependence of NSPT results.\n-- By construction the Runge-Kutta used in the calculations the\n-- part linear in epsilon is cancelled.\n-- Parameters\n-- ----------\n-- epsilon : float\n-- NSPT time step epsilon\n-- a : float\n-- Fit parameter for quadratic term\n-- b : float\n-- Fit parameter for constant term\n-- Returns\n-- -------\n-- a*epsilon**2+b : float\nlocal function fitfunc_e2(epsilon, a, b)\n    return a*epsilon*epsilon+b\nen","completion":""}
{"prompt":"-- rotates hilbert curve path by 90 degrees for each new block (quadrant)\nlocal function hilbert_rotatequadrant(slen, xcart, ycart, rxcart, rycart)\n  if slen > 1 then\n    local newlen = slen \/ 2\n    return hilbert_rotatequadrant(newlen, xcart, ycart, 1-rycart, rxcart),\n        hilbert_rotatequadrant(newlen, xcart+rxcart*newlen, ycart+rycart*newlen, 1-rxcart, 1-rycart),\n        hilbert_rotatequadrant(newlen, xcart+rxcart*newlen, ycart+rycart*newlen, rxcart, 1-rxcart),\n        hilbert_rotatequadrant(newlen, xcart, ycart, rycart, 1-rxcart)\n  else\n    return {xcart, ycart}\n  end\nen","completion":""}
{"prompt":"-- This is the original function, it will be used to compare execution times.\nlocal function fibonacci(n)\n   if n < 2 then\n      return n\n   end\n   return fibonacci(n-1) + fibonacci(n-2)\nen","completion":""}
{"prompt":"-- Turn gconf path into name.\nlocal function gconfname(path)\n    local name = string.gsub(path, \".*\/\", \"\")\n    return name\nen","completion":""}
{"prompt":"-- Get a value from the Fibonacci sequence.\n-- :param int num:\nlocal function fib(num)\n    if num <= 1 then\n        return 1\n    end\n    return fib(num - 1) + fib(num - 2)\nen","completion":""}
{"prompt":"-- Create new matrix with quiet zone and copy matrix into it\nlocal function get_matrix_with_quiet_zone(matrix, quiet_zone_size)\n  local new_matrix = {}\n  for i = 1, #matrix do\n    new_matrix[i] = {}\n    for j = 1, #matrix[i] do\n      new_matrix[i][j] = false\n    end\n  end\n  local quiet_zone_size = (quiet_zone_size or 4) * 2\n  -- Fill quiet zone with false\n  for i = 1, quiet_zone_size do\n    for j = 1, quiet_zone_size do\n      new_matrix[i][j] = false\n    end\n  end\n  -- Copy matrix into the new matrix\n  for i = 1, #matrix do\n    for j = 1, #matrix[i] do\n      new_matrix[i + quiet_zone_size][j + quiet_zone_size] = matrix[i][j]\n    end\n  end\n  return new_matrix\nen","completion":""}
{"prompt":"-- Words not 'the'\n-- Given a sentence, produce a list of the lengths of each word in the sentence, but only if the word is not 'the'.\n-- >>> words_not_the('the quick brown fox jumps over the lazy dog')\n-- [5, 5, 3, 5, 4, 4, 3]\nlocal function words_not_the(sentence)\n    local words = {}\n    for word in sentence:gmatch(\"[^%s]+\") do\n        if word ~= \"the\" then\n            table.insert(words, #word)\n        end\n    end\n    return words\nen","completion":""}
{"prompt":"-- <payment_scene>.<vas_name>$<info>.<vas_name>$<info>\nlocal function get_pure_payment_scene(payment_scene)\n    local _, _, vas_name = string.find(payment_scene, \"^([^.]+)%.(.+)$\")\n    if not vas_name then\n        return payment_scene\n    end\n    return vas_name\nen","completion":""}
{"prompt":"-- Converts a value from GWEI to ETH\n-- by dividing by 1000000000000000000\n-- Args:\n-- gwei (float): Gwei value\n-- Returns:\n-- float: Eth value\nlocal function from_gwei(gwei)\n  return gwei \/ 1000000000000000000\nen","completion":""}
{"prompt":"-- Check and convert a value to an integer\nlocal function toint(v)\n\tif not v then\n\t\treturn v\n\telseif type(v) == 'number' then\n\t\treturn math.floor(v)\n\telse\n\t\tlocal x = tonumber(v)\n\t\tif x then\n\t\t\treturn math.floor(x)\n\t\tend\n\tend\n\treturn v\nen","completion":""}
{"prompt":"-- get cross-product for 3D vectors\nlocal function cross_product(vector1, vector2)\n  return {\n    vector1[2] * vector2[3] - vector1[3] * vector2[2],\n    vector1[3] * vector2[1] - vector1[1] * vector2[3],\n    vector1[1] * vector2[2] - vector1[2] * vector2[1]\n  }\nen","completion":""}
{"prompt":"-- Linear rampup\nlocal function linear_rampup(current, rampup_length)\n    if current >= rampup_length then\n        return 1.0\n    else\n        return current \/ rampup_length\n    end\nen","completion":""}
{"prompt":"-- Returns the direction for the given longitude degrees.\n-- :param longitude_degrees: The degrees (not minutes) as an integer.\n-- :return: String containing the possible latitude directions (W, E).\nlocal function get_longitude_direction(longitude_degrees)\n    local longitude_direction = \"\"\n    if longitude_degrees < 0 then\n        longitude_direction = \"W\"\n    elseif longitude_degrees > 0 then\n        longitude_direction = \"E\"\n    end\n    return longitude_direction\nen","completion":""}
{"prompt":"-- Are we running in a virtual machine?\n-- If we are running inside a VM, then linux will put 'hypervisor' in cpuinfo. This function looks for the presence\n-- of that.\n-- :return: boolean.\nlocal function is_virtual_machine()\n  local f = io.open(\"\/proc\/cpuinfo\")\n  if f == nil then return false end\n  local cpuinfo = f:read(\"*a\")\n  f:close()\n  return cpuinfo:find(\"hypervisor\") ~= nil\nen","completion":""}
{"prompt":"-- Checks the number valiaty for the Bahia state\nlocal function start(st_reg_number)\n\tlocal st_reg_number = st_reg_number or ''\n\tif st_reg_number == '' then\n\t\treturn false\n\tend\n\tif not string.find(st_reg_number, '^[0-9]{3}[A-Z]$') then\n\t\treturn false\n\tend\n\tif not string.find(st_reg_number, '^[0-9]{3}[A-Z]$', 1, true) then\n\t\treturn false\n\tend\n\treturn true\nen","completion":""}
{"prompt":"-- usage example {{ your_dict| from_json:your_key }}\nlocal function get_value_from_json(dict_data, key)\n  local value\n  if dict_data and dict_data[key] and dict_data[key] ~= '' then\n    value = dict_data[key]\n  else\n    value = nil\n  end\n  return value\nen","completion":""}
{"prompt":"-- Get a calling function's arguments.\n-- Returns:\n-- args : dict\n-- The calling function's  arguments.\nlocal function get_arguments(omit)\n    local i = 1\n    local args = {}\n    local function get_arg(omit)\n        if i >= #arg or arg[i] == nil then\n            error(format(\"Missing argument #%d to %s\", i, get_calling_function()))\n        end\n        i = i + 1\n        local arg = arg[i]\n        if omit ~= nil and omit == arg then\n            return get_arg(omit)\n        else\n            return arg\n        end\n    end\n    while i <= #arg do\n        local arg = get_arg(omit)\n        args[#args + 1] = arg\n    end\n    return args\nen","completion":""}
{"prompt":"-- Returns an 's' if plural\n-- Useful in print statements to avoid something like 'point(s)'\nlocal function plural(x)\n  return x > 1 and 's' or ''\nen","completion":""}
{"prompt":"-- Sum(x, n) = 1+x+x^2+...+x^n = ( x^(n+1) - 1 ) \/ ( x -1 )\n-- return 0 if Sum(x, n) == target\n-- return 1 if Sum(x, n) > target\n-- return -1 if Sum(x, n) < target\nlocal function compare(n, x, target)\n    local t = (x ^ (n + 1) - 1) \/ (x - 1)\n    return t > target and 1 or t < target and -1 or 0\nen","completion":""}
{"prompt":"-- Returns the factorial of a given positive, non-zero integer\n-- using recursion.\nlocal function fact_recursion(n)\n  if n == 0 then\n    return 1\n  else\n    return n * fact_recursion(n - 1)\n  end\nen","completion":""}
{"prompt":"-- Given a positive integer N,\n-- return the largest integer k\n-- such that 3^k < N.\n-- :param N:\n-- :return:\nlocal function largestPower(N)\n    local i = 1\n    while 3^i < N do\n        i = i + 1\n    end\n    return i - 1\nen","completion":""}
{"prompt":"-- Taxa in time and space.\nlocal function occurrences(resp_json, return_obj, options)\n\treturn return_obj\nen","completion":""}
{"prompt":"-- Parse an int, interpreting an empty string as 0.\nlocal function parse_int(value)\n\tlocal n = tonumber(value)\n\tif n == nil then return 0 end\n\treturn n\nen","completion":""}
{"prompt":"-- Returns the max subarray of the given list of numbers.\n-- Returns 0 if  nums is None or an empty list.\n-- Time Complexity: O(n)\n-- Space Complexity: O(1)\nlocal function max_sub_array(nums)\n    if nums == nil or #nums == 0 then return 0 end\n    local max_ending_here = 0\n    local max_so_far = nums[1]\n    for i = 1, #nums do\n        max_ending_here = max_ending_here + nums[i]\n        if max_so_far < max_ending_here then\n            max_so_far = max_ending_here\n        end\n        if max_ending_here < 0 then\n            max_ending_here = 0\n        end\n    end\n    return max_so_far\nen","completion":""}
{"prompt":"-- Linear function with offset\nlocal function linear_function(x, a, b)\n    return a*x+b\nen","completion":""}
{"prompt":"-- Accepts a comma delimited list of values as a string,\n-- and returns a list of the string elements.\nlocal function split_cdl(cdl_string)\n  local result = {}\n  for item in cdl_string:gmatch(\"[^,]+\") do\n    result[#result + 1] = item:match(\"^%s*(.-)%s*$\")\n  end\n  return result\nen","completion":""}
{"prompt":"-- If the 'extent' is negative, the function checks the preceding lines\nlocal function empty_lines(lines, index, extent)\n  if extent >= 0 then\n    for i = index + 1, index + extent do\n      if lines[i] ~= \"\" then return false end\n    end\n    return true\n  else\n    for i = index + 1, math.max(index + extent, 1) do\n      if lines[i] ~= \"\" then return false end\n    end\n    return true\n  end\nen","completion":""}
{"prompt":"-- simple sliding average calculation\nlocal function addToAverage(totalCount, totalValue, newValue)\n    totalCount = totalCount + 1\n    local newAverage = totalValue + (newValue - totalValue) \/ totalCount\n    return newAverage, totalCount\nen","completion":""}
{"prompt":"-- format and return given subscription response into dictionary\nlocal function format_sub_response(sub_response)\n    local dict = {}\n    for k, v in pairs(sub_response) do\n        dict[k] = v\n    end\n    return dict\nen","completion":""}
{"prompt":"-- Returns `value` or one of the min\/max bounds if `value` is not between them.\nlocal function minmax(value, min_value, max_value)\n    return math.min(max_value, math.max(min_value, value))\nen","completion":""}
{"prompt":"-- Clamp coord to lay between lower and upper.\nlocal function clamp(coord, lower, upper)\n\tcoord = coord or 0\n\tif coord > upper then\n\t\tcoord = upper\n\telseif coord < lower then\n\t\tcoord = lower\n\tend\n\treturn coord\nen","completion":""}
{"prompt":"-- Leave only those fields which keys are present in `fields`.\n-- :param dct: Source dictionary\n-- :type dct: dict\n-- :param fields: List of fields to keep\n-- :type fields: list\n-- :return: Resulting dictionary containing whitelisted fields only\n-- :rtype: dict\nlocal function whitelist(dct, fields)\n  local ret = {}\n  for _, f in ipairs(fields) do\n    if dct[f] ~= nil then\n      ret[f] = dct[f]\n    end\n  end\n  return ret\nen","completion":""}
{"prompt":"-- FATE's learning rate decay equation \n-- Args:\n-- initial_lr  (float): Initial learning rate specified\n-- lr_decay    (float): Scaling factor for Learning rate \n-- epochs        (int): No. of epochs that have passed\n-- Returns:\n-- Scaled learning rate (float)\nlocal function fate_lr_decay(initial_lr, lr_decay, epochs)\n    return initial_lr * (math.exp(-lr_decay * epochs))\nen","completion":""}
{"prompt":"-- Prepends chromosome with 'chr' if not present.\n-- Users are strongly discouraged from using this function. Adding a\n-- 'chr' prefix results in a name that is not consistent\n-- with authoritative assembly records.\n-- Args:\n-- chr (str): The chromosome.\n-- Returns:    \n-- str: The chromosome with 'chr' prepended.\n-- Examples:\n-- >>> prepend_chr('22')\n-- 'chr22'\n-- >>> prepend_chr('chr22')\n-- 'chr22'\nlocal function prepend_chr(chr)\n  if string.sub(chr, 1, 3) == 'chr' then\n    return chr\n  else\n    return \"chr\" .. chr\n  end\nen","completion":""}
{"prompt":"-- >>> format_identifier('apple_pay')\n-- 'Apple Pay'\nlocal function format_identifier(s)\n  local title = s:gsub(\"_\", \" \")\n  return title:gsub(\"(%a)([%w']*)\", function(first, rest)\n    if rest ~= \"\" then\n      return first:upper() .. rest:lower()\n    else\n      return first:upper()\n    end\n  end)\nen","completion":""}
{"prompt":"-- http:\/\/stackoverflow.com\/questions\/952914\/making-a-flat-list-out-of-list-of-lists-in-python\nlocal function flatten(l)\n\tlocal function aux(l,acc)\n\t\tfor i=1,#l do\n\t\t\tif type(l[i]) == \"table\" then\n\t\t\t\taux(l[i], acc)\n\t\t\telse\n\t\t\t\ttable.insert(acc, l[i])\n\t\t\tend\n\t\tend\n\t\treturn acc\n\tend\n\treturn aux(l, {})\nen","completion":""}
{"prompt":"-- :return A string in the format [n1 \/ n2], where \"n1\" and \"n2\" are the passed integers padded to the same length\nlocal function _out_of_str(n1, n2)\n\tn1 = tostring(n1)\n\tn2 = tostring(n2)\n\tlocal len_n1 = #n1\n\tlocal len_n2 = #n2\n\tlocal len = math.max(len_n1, len_n2)\n\tif len_n1 < len then\n\t\tn1 = string.rep(\" \", len - len_n1) .. n1\n\tend\n\tif len_n2 < len then\n\t\tn2 = string.rep(\" \", len - len_n2) .. n2\n\tend\n\treturn \"[\" .. n1 .. \" \/ \" .. n2 .. \"]\"\nen","completion":""}
{"prompt":"-- Count the number of appearances\n-- Parameters :\n-- -----------\n-- value : int\n-- Cluster label \n-- values : ndarray of shape (n_samples, )\n-- Sample labels\n-- Return :\n-- -------\n-- count : int\n-- Number of times 'value' appear in 'values'\nlocal function count_value(value, values)\n    local count = 0\n    for i=1, #values do\n        if values[i] == value then\n            count = count + 1\n        end\n    end\n    return count\nen","completion":""}
{"prompt":"-- Calculate total Fluorine\n-- Riley, J. P., Deep-Sea Research 12:219-220, 1965:\n-- this is .000068.*Sali.\/35. = .00000195.*Sali\nlocal function calc_TF(Sal)\n\treturn Sal*0.00000195\nen","completion":""}
{"prompt":"-- Searches for the correct file and returns True or False depending on success or failure.\n-- Parameters\n-- ----------\n-- title: str\n-- The name of the file as instructed by the current date.\n-- Returns\n-- ---------- \n-- Boolean\nlocal function read_sequence(title)\n\tif title == nil then\n\t\treturn false\n\tend\n\t\n\tlocal file = io.open(\"Sequence.txt\", \"r\")\n\tif file then\n\t\tlocal count = 0\n\t\tfor line in file:lines() do\n\t\t\tif string.find(line, title) then\n\t\t\t\tcount = count + 1\n\t\t\tend\n\t\tend\n\t\tfile:close()\n\t\tif count == 0 then\n\t\t\treturn false\n\t\tend\n\telse\n\t\treturn false\n\tend\n\t\n\treturn true\nen","completion":""}
{"prompt":"-- Return shorthand hexadecimal code, ex: cc3300 -> c30\nlocal function short_hex(x)\n    return x:sub(1, 1) .. x:sub(3, 3) .. x:sub(5, 5)\nen","completion":""}
{"prompt":"-- converts from scale factor to  redshift\nlocal function a2z(a)\n\treturn (1\/a) - 1\nen","completion":""}
{"prompt":"-- Cast a value to a type, if appropriate.\n-- Parameters\n-- ----------\n-- x : object\n-- A value.\n-- dtype : tpye\n-- Data type, such as `float`, `int`, or `str`.\n-- Returns\n-- -------\n-- values : object\n-- If appropriate, the returned value is ``x`` cast to the given type\n-- ``dtype``. If the cast cannot be performed the original value of\n-- ``x`` is returned.\nlocal function _autocast(x, dtype)\n    if x ~= nil and dtype ~= nil and _DTYPE_MAP[dtype] ~= nil then\n        local dtype_map = _DTYPE_MAP[dtype]\n        local dtype_x = _get_dtype(x)\n        if dtype_map[dtype_x] ~= nil then\n            return _cast_helper(x, dtype_map[dtype_x], dtype)\n        end\n    end\n    return x\nen","completion":""}
{"prompt":"-- Multiplies a matrix to a scalar\n-- NOTE: Does not validates any matrix sizes or 0 scalar\n-- Parameters\n-- ----------\n-- scalar(int) : Number scalar to multiply\n-- matrix(list) : Matrix to be multiplied\n-- Returns\n-- -------\n-- list : multiplied matrix\nlocal function mulsca(scalar, matrix)\n  local newmat = {}\n  for i, row in ipairs(matrix) do\n    local newrow = {}\n    for j, value in ipairs(row) do\n      newrow[j] = scalar * value\n    end\n    newmat[i] = newrow\n  end\n  return newmat\nen","completion":""}
{"prompt":"-- Convenience function to compute an interpolated linear value between\n-- two points.\n-- Parameters\n-- ----------\n-- x_target : float\n-- x0 : float\n-- x1 : float\n-- y0 : float\n-- y1 : float\n-- Returns\n-- -------\n-- float\n-- Interpolated value.\nlocal function linear_interp_pt(x_target, x0, x1, y0, y1)\n    local frac = (x_target - x0) \/ (x1 - x0)\n    return (1 - frac) * y0 + frac * y1\nen","completion":""}
{"prompt":"-- Reduces family accession to everything prior to '.'.\nlocal function mod_family_accession(family_accession)\n   local acc = family_accession\n   if acc:find('.') then\n      acc = acc:match('(.-)%.')\n   end\n   return acc\nen","completion":""}
{"prompt":"-- Count # of times non-None target exists in linked list, n.\nlocal function count(n, target)\n    if n == nil then\n        return 0\n    end\n    if n.value == target then\n        return 1 + count(n.next, target)\n    else\n        return count(n.next, target)\n    end\nen","completion":""}
{"prompt":"-- Average between linearity and consistency\nlocal function get_song_stereotypy(sequence_linearity, sequence_consistency)\n  local stereotypic_factor = 0.5 * (sequence_linearity + sequence_consistency)\n  return stereotypic_factor\nen","completion":""}
{"prompt":"-- Multipy two matrices\n-- :param a: list of list of floats\n-- :param b: list of list of floats\n-- :return: resulting matrix\nlocal function matmul(a, b)\n   local n_a, n_b = #a, #b\n   assert(n_a > 0 and n_b > 0, \"empty matrix\")\n   local n_i, n_j = #a[1], #b[1]\n   assert(n_i == n_b, \"dimension mismatch\")\n   local res = {}\n   for i = 1, n_a do\n      res[i] = {}\n      for j = 1, n_j do\n         res[i][j] = 0\n         for k = 1, n_i do\n            res[i][j] = res[i][j] + a[i][k] * b[k][j]\n         end\n      end\n   end\n   return res\nen","completion":""}
{"prompt":"-- turn value to integer\nlocal function val_to_freq(word_value, scalar)\n  local ret = {}\n  for word,val in pairs(word_value) do\n    val = math.floor(val*scalar)\n    ret[word] = val\n  end\n  return ret\nen","completion":""}
{"prompt":"-- Overview of fibonacci\nlocal function fibonacci(n)\n    if n == 0 then\n        return 0\n    elseif n == 1 then\n        return 1\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2)\n    end\nen","completion":""}
{"prompt":"-- Enclose s in <String>...<\/String>.\nlocal function _make_xml_string(s)\n    return string.format(\"<String>%s<\/String>\", s)\nen","completion":""}
{"prompt":"-- logical and of a and b\nlocal function AND(a, b)\n\tlocal a = type(a) == \"table\" and a.val or a\n\tlocal b = type(b) == \"table\" and b.val or b\n\tif type(a) == \"number\" and type(b) == \"number\" then\n\t\treturn a * b\n\telseif type(a) == \"number\" then\n\t\treturn a * b.val\n\telseif type(b) == \"number\" then\n\t\treturn a.val * b\n\telse\n\t\treturn a * b.val\n\tend\nen","completion":""}
{"prompt":"-- Converts fully-qualified names to a list of namespaces.\n-- namespaces(['clojure.core\/map']) => ['clojure.core']\nlocal function namespaces(labels)\n   local names = {}\n   for i, label in ipairs(labels) do\n      local name = label\n      for i = #name, 1, -1 do\n         if name:sub(i, i) == '\/' then\n            name = name:sub(1, i - 1)\n            break\n         end\n      end\n      table.insert(names, name)\n   end\n   return names\nen","completion":""}
{"prompt":"-- Converts a right ascension to an hour angle.\nlocal function _ra2ha(ra, lst)\n  lst = lst or os.date(\"*t\").hour\n  return (lst - ra \/ 15) % 24\nen","completion":""}
{"prompt":"-- >>> percent(512, 4096)\n-- 12.5\n-- >>> percent(811, 700)\n-- 100\n-- >>> percent(-7, 91)\n-- 0\nlocal function percent(amount, total)\n    return total > 0 and (amount\/total) * 100 or 0\nen","completion":""}
{"prompt":"-- Simplified Bezier cubic curve.\n-- Return 4 terms in list ()\nlocal function bezier_cubic_terms(t)\n\tlocal terms = {}\n\tlocal t2 = t * t\n\tlocal t3 = t2 * t\n\tlocal mt = 1 - t\n\tlocal mt2 = mt * mt\n\tlocal mt3 = mt2 * mt\n\tterms[1] = mt3\n\tterms[2] = 3 * mt2 * t\n\tterms[3] = 3 * mt * t2\n\tterms[4] = t3\n\treturn terms\nen","completion":""}
{"prompt":"-- Convenience method for converting\n-- (python boolean value) -> (javascript boolean string)\nlocal function get_js_boolean(bool_val)\n   if bool_val == true then\n      return \"true\"\n   end\n   return \"false\"\nen","completion":""}
{"prompt":"-- txt = txt[::-1]     \n-- new_string = \"\"\n-- for i in txt:\n-- if i == \" \":\n-- new_string += i\n-- if i.isupper():\n-- new_string += i.lower()\n-- continue\n-- if i.islower():\n-- new_string += i.upper()\n-- continue\n-- else:\n-- pass\n-- return new_string\nlocal function csOppositeReverse(txt)\n  local new_string = \"\"\n  local len = string.len(txt)\n  for i = len, 1, -1 do\n    if txt:sub(i, i) == \" \" then\n      new_string = new_string .. txt:sub(i, i)\n    elseif txt:sub(i, i):upper() == txt:sub(i, i) then\n      new_string = new_string .. txt:sub(i, i):lower()\n    elseif txt:sub(i, i):lower() == txt:sub(i, i) then\n      new_string = new_string .. txt:sub(i, i):upper()\n    end\n  end\n  return new_string\nen","completion":""}
{"prompt":"-- Convert an integer to a single character, where 0 equals A.\n-- Note: This method will return an uppercase character.\n-- :param value: an integer\n-- :return: a character representation\nlocal function to_char(value)\n  return string.char(value + 65)\nen","completion":""}
{"prompt":"-- :return the co-ordinate of head as per :param direction\nlocal function get_next(current_head, direction)\n  local next_head = {\n    x = current_head.x,\n    y = current_head.y,\n  }\n  if direction == \"up\" then\n    next_head.y = current_head.y + 1\n  elseif direction == \"down\" then\n    next_head.y = current_head.y - 1\n  elseif direction == \"left\" then\n    next_head.x = current_head.x - 1\n  elseif direction == \"right\" then\n    next_head.x = current_head.x + 1\n  end\n  return next_head\nen","completion":""}
{"prompt":"-- Vrati index leveho potomka prvku na pozici 'i'.\nlocal function left_index(i)\n\treturn 2 * i + 1\nen","completion":""}
{"prompt":"-- :type s: str\n-- :rtype: int\nlocal function lengthOfLongestSubstring(s)\n  local chars = {}\n  local max_length = 0\n  local start_index = 1\n  for i=1,#s do\n    if chars[s:byte(i)] then\n      if chars[s:byte(i)] >= start_index then\n        start_index = chars[s:byte(i)] + 1\n      end\n    end\n    chars[s:byte(i)] = i\n    max_length = math.max(max_length, i - start_index + 1)\n  end\n  return max_length\nen","completion":""}
{"prompt":"-- Returns the maximum total sum from top to bottom of the triangle.\n-- Must be formatted as a list of lists of ints.\nlocal function maximum_path_sum(tri)\n    for i = #tri, 1, -1 do\n        for j = 1, #tri[i] do\n            if (i == #tri) then\n                tri[i][j] = tri[i][j]\n            else\n                tri[i][j] = tri[i][j] + math.max(tri[i+1][j], tri[i+1][j+1])\n            end\n        end\n    end\n    return tri[1][1]\nen","completion":""}
{"prompt":"-- Return the URL to the image tile (x, y) at zoom z.\nlocal function get_url(x, y, z, tileserver)\n    local url = tileserver\n    url = url:gsub(\"{x}\", x)\n    url = url:gsub(\"{y}\", y)\n    url = url:gsub(\"{z}\", z)\n    return url\nen","completion":""}
{"prompt":"-- Helper function.\nlocal function lerp_np(x, y, w)\n   return (1-w)*x + w*y\nen","completion":""}
{"prompt":"-- Calculate proportion of positive outcomes under test condition\n-- :param t_pos: Positive results in Test group \n-- :param t_neg: Negative results in Test group\n-- :return p_test: Proportion of subjects w\/ positive outcome under treatment\/test condition\nlocal function p_test_subs(t_pos, t_neg)\n  return (t_pos \/ (t_pos + t_neg))\nen","completion":""}
{"prompt":"-- Get EPSG code for UTM zone\nlocal function get_utm_epsg(utm_zone, north)\n    -- Convert to numeric if string\n    if type(utm_zone) == 'string' then\n        utm_zone = tonumber(utm_zone)\n    end\n    if type(north) == 'string' then\n        north = north == 'true'\n    end\n    -- EPSG codes for UTM zones are in the form 32601-32660\n    local epsg = utm_zone + 32600\n    if not north then\n        epsg = epsg + 100\n    end\n    return tostring(epsg)\nen","completion":""}
{"prompt":"-- Replace any angled brackets in string s to avoid interfering with HTML attention visualizer.\n-- pyrouge calls a perl script that puts the data into HTML files.\n-- Therefore we need to make our output HTML safe.\nlocal function make_html_safe(s)\n  if (s == nil) then\n    return ''\n  else\n    return string.gsub(s, '[<>]', function(c) return string.format('&#%d;', string.byte(c)) end)\n  end\nen","completion":""}
{"prompt":"-- Convert given byte number to signed byte number.\n-- :param num: Unsigned byte number in range from 0 to 255.\n-- :return: Signed number in range from -128 to 127.\nlocal function to_signed_byte(num)\n  if num < 128 then\n    return num\n  else\n    return num - 256\n  end\nen","completion":""}
{"prompt":"-- Get the id component of the curie, 0000001 from CL:0000001 for example.\nlocal function _ontology_value(curie)\n  local id = curie:match(\"^%w+:([%w_-]+)$\")\n  if not id then\n    id = curie\n  end\n  return id\nen","completion":""}
{"prompt":"-- Convenience function for processing comma lists.\n-- A comma is returned for all but the last member in the list\nlocal function comma(member, memberList)\n\tif memberList[#memberList] == member then\n\t\treturn \"\"\n\telse\n\t\treturn \",\"\n\tend\nen","completion":""}
{"prompt":"-- Convert a numerical value into an ordinal number.\n-- @param value: the number to be converted\nlocal function ToOrdinal(value)\n  local ord = value\n  if value % 10 == 1 and value % 100 ~= 11 then\n    ord = value .. \"st\"\n  elseif value % 10 == 2 and value % 100 ~= 12 then\n    ord = value .. \"nd\"\n  elseif value % 10 == 3 and value % 100 ~= 13 then\n    ord = value .. \"rd\"\n  else\n    ord = value .. \"th\"\n  end\n  return ord\nen","completion":""}
{"prompt":"-- convert backslashes to slashes\nlocal function force_slash(x)\n\treturn (x:gsub(\"\\\\\", \"\/\"))\nen","completion":""}
{"prompt":"-- Return sorted list of prime factors of n, for n <= 120\nlocal function get_factors(n)\n\tassert(n <= 120)\n\tlocal factors = {}\n\tfor i = 1, n do\n\t\tif n % i == 0 then\n\t\t\ttable.insert(factors, i)\n\t\tend\n\tend\n\ttable.sort(factors)\n\treturn factors\nen","completion":""}
{"prompt":"-- Metodo para calculo sw un descuento\n-- :param porcentaje:\n-- :param pvp:\n-- :return:\nlocal function calcular_descuento(porcentaje, pvp)\n\treturn pvp * porcentaje \/ 100\nen","completion":""}
{"prompt":"-- Return the source code block\nlocal function extract_source_code_from_notebook(notebook_cell)\n    if notebook_cell.source then\n        return notebook_cell.source\n    elseif notebook_cell.cell_type == \"code\" then\n        return notebook_cell.input:match(\"%-%-%-%-%- BEGIN SOURCE CODE %-%-%-%-%-([%w%W]+)%-%-%-%-%- END SOURCE CODE %-%-%-%-%-\")\n    else\n        return \"\"\n    end\nen","completion":""}
{"prompt":"-- https:\/\/leetcode-cn.com\/problems\/divisor-game\/\n-- :param n:\n-- :return:\nlocal function divisorGame(n)\n    return n % 2 == 0\nen","completion":""}
{"prompt":"-- Return the lenght in pixels of a distance in millimeter at a given resolution.\nlocal function px(mm, dpi)\n    return math.floor(mm * dpi \/ 25.4 + 0.5)\nen","completion":""}
{"prompt":"-- Computes the LCS-based F-measure score\n-- Source: http:\/\/research.microsoft.com\/en-us\/um\/people\/cyl\/download\/papers\/\n-- rouge-working-note-v1.3.1.pdf\n-- :param llcs: Length of LCS\n-- :param m: number of words in reference summary\n-- :param n: number of words in candidate summary\n-- :returns float: LCS-based F-measure score\nlocal function _f_lcs(llcs, m, n)\n    return 2 * llcs \/ (m + n)\nen","completion":""}
{"prompt":"-- :param lon_degrees: float for longitude in degrees\n-- :return: float for longitude in degrees but shifted to the fundamental domain.\nlocal function mod_longitude_degrees(lon_degrees)\n  local lon_degrees = lon_degrees or 0.0\n  return (lon_degrees + 180.0) % 360.0 - 180.0\nen","completion":""}
{"prompt":"-- x is a positive integer. Convert it to base two as a list of integers\n-- in reverse order as a list.\nlocal function int2baseTwo(x)\n    local ret = {}\n    while x > 0 do\n        ret[#ret+1] = x % 2\n        x = (x - (x % 2)) \/ 2\n    end\n    return ret\nen","completion":""}
{"prompt":"-- Calculates the error measure fuzzy rmse\n-- :param centrall_cell: float, cell under analysis in map A\n-- :param neighbours: np.array of floats, neighbours in map B\n-- :return: np.array of floats, each similarity between each of two cells\nlocal function squared_error(centrall_cell, neighbours)\n  local error = (centrall_cell - neighbours) ^ 2\n  return error\nen","completion":""}
{"prompt":"-- Essa funcao recebe uma lista de palavras e devolve o numero de palavras\n-- que aparecem uma unica vez.\nlocal function n_palavras_unicas(lista_palavras)\n    local dicionario_palavras = {}\n    for _, palavra in ipairs(lista_palavras) do\n        local contagem = dicionario_palavras[palavra] or 0\n        contagem = contagem + 1\n        dicionario_palavras[palavra] = contagem\n    end\n    local n_palavras_unicas = 0\n    for _, contagem in pairs(dicionario_palavras) do\n        if contagem == 1 then\n            n_palavras_unicas = n_palavras_unicas + 1\n        end\n    end\n    return n_palavras_unicas\nen","completion":""}
{"prompt":"-- returns an estimate of the square root of a\nlocal function square_root(a)\n\tlocal x = a\n\twhile true do\n\t\tlocal new_x = (x + a \/ x) \/ 2\n\t\tif new_x == x then return new_x end\n\t\tx = new_x\n\tend\nen","completion":""}
{"prompt":"-- Divides a by b and rounds up to the nearest integer.\nlocal function divup(a, b)\n  return math.ceil(a \/ b)\nen","completion":""}
{"prompt":"-- Merge the board left\n-- Args: b (list) two dimensional board to merge\n-- Returns: list\nlocal function merge_left(b)\n    local result = {}\n    for i, row in pairs(b) do\n        if i == 1 then\n            result[i] = row\n        else\n            result[i] = {}\n            for j, cell in pairs(row) do\n                if cell == nil and result[i-1][j] ~= nil then\n                    result[i][j] = result[i-1][j]\n                else\n                    result[i][j] = cell\n                end\n            end\n        end\n    end\n    return result\nen","completion":""}
{"prompt":"-- Replace potential special characters with escaped version.\n-- For example, newline => \\n and tab => \\t\nlocal function escape(s)\n  local result = s:gsub(\"\\\\\", \"\\\\\\\\\")\n  result = result:gsub(\"\\n\", \"\\\\n\")\n  result = result:gsub(\"\\r\", \"\\\\r\")\n  result = result:gsub(\"\\t\", \"\\\\t\")\n  return result\nen","completion":""}
{"prompt":"-- Given an index in the sequence, and a color, get the name of node who's index is i and color is c.\n-- :param i: Index in the sequence.\n-- :param c: Color, between 0 and 9.\n-- :return: Name of node corresponding to this index in s_star.\n-- **Example:** ::\n-- index_color_node(0, 9) = 'i_0_c_9'\nlocal function index_color_node(i, c)\n  return string.format(\"i_%d_c_%d\", i, c)\nen","completion":""}
{"prompt":"-- get the learning rate.\nlocal function get_learning_rate(epoch_step, cur_learning_rate, lr_decay_factor, num_epochs_per_decay)\n\tif epoch_step < num_epochs_per_decay then\n\t\treturn cur_learning_rate\n\telse\n\t\treturn cur_learning_rate * lr_decay_factor\n\tend\nen","completion":""}
{"prompt":"-- Convert a given input to the dictionary format.\n-- Parameters\n-- ----------\n-- a : list or other\n-- Returns\n-- -------\n-- list\n-- Examples\n-- --------\n-- >>> tolist(2)\n-- [2]\n-- >>> tolist([1, 2])\n-- [1, 2]\n-- >>> tolist([])\n-- []\nlocal function tolist(a)\n\tlocal typ = type(a)\n\tif typ == \"table\" then\n\t\treturn a\n\telseif typ == \"nil\" then\n\t\treturn {}\n\telse\n\t\treturn {a}\n\tend\nen","completion":""}
{"prompt":"-- Calculate more human readable values for byte sizes\n-- :param size: Will support sizes up to terra bytes. Afterwards all is returned as terra bytes.\n-- :return: string <calculatedsize><unit> for example \"1MB\"\nlocal function format_bytes(size)\n\tlocal size_bytes = tonumber(size)\n\tif size_bytes < 1024 then\n\t\treturn size_bytes .. 'B'\n\telseif size_bytes < (1024 * 1024) then\n\t\treturn (size_bytes \/ 1024) .. 'KB'\n\telseif size_bytes < (1024 * 1024 * 1024) then\n\t\treturn (size_bytes \/ (1024 * 1024)) .. 'MB'\n\telse\n\t\treturn (size_bytes \/ (1024 * 1024 * 1024)) .. 'TB'\n\tend\nen","completion":""}
{"prompt":"-- Check the winner number in diagonal direction.\n-- Arguments:\n-- input_list -- a two dimensional list for checking.\n-- size -- the length for winning.\n-- Returns:\n-- winner -- the winner player number, if no winner return None.\nlocal function check_diagonal_winner(input_list, size)\n    -- Check the winner number in diagonal direction.\n    for i = 1, size do\n        if input_list[i][i] ~= 0 then\n            return input_list[i][i]\n        end\n    end\nen","completion":""}
{"prompt":"-- Generate a gradient of 1 for each loss specified in 'loss_blobs'\nlocal function get_loss_gradients(model, loss_blobs)\n    local loss_gradients = {}\n    for i, loss_blob in ipairs(loss_blobs) do\n        local grad_blob = model:get_gradient_blob(loss_blob)\n        loss_gradients[i] = grad_blob\n        model:add_gradient_check_task(grad_blob, 1, 1)\n    end\n    return loss_gradients\nen","completion":""}
{"prompt":"-- calculates error\nlocal function calculate_error(dataclasses)\n  local all_errors = 0\n  for _, data_class in pairs(dataclasses) do\n    if data_class.error ~= nil then\n      all_errors = all_errors + data_class.error\n    end\n  end\n  return all_errors\nen","completion":""}
{"prompt":"-- Checks arguments correlation with triangle sides:\n-- If any two sides are equal returns \"Isosceles triangle\",\n-- If the sum of any two arguments is less then the third one returns - \"Not a triangle\"\n-- If all arguments are different returns \"Versatile triangle\"\n-- If all arguments are equal returns \"Equilateral triangle\"\nlocal function triangle_type(a, b, c)\n  if a == b and b == c then\n    return 'Equilateral triangle'\n  elseif a == b or b == c or a == c then\n    return 'Isosceles triangle'\n  elseif a + b > c and b + c > a and a + c > b then\n    return 'Versatile triangle'\n  else\n    return 'Not a triangle'\n  end\nen","completion":""}
{"prompt":"-- Returns the next power of two greater than or equal to `n`\nlocal function next_pow_two(n)\n    local p = 1\n    while p < n do\n        p = p * 2\n    end\n    return p\nen","completion":""}
{"prompt":"-- Return the input string with single and double quotes escaped out\nlocal function esc_quotes(strng)\n\tstrng = string.gsub(strng, \"'\", \"\\\\'\")\n\treturn string.gsub(strng, \"\\\"\", \"\\\\\\\"\")\nen","completion":""}
{"prompt":"-- Returns s with all non-alphanumeric characters replaced with *\n-- Parameters\n-- ----------\n-- s : str\n-- The string to be censored.\n-- Returns\n-- -------\n-- output : str\n-- The censored version of `s`\nlocal function censor_non_alphanum(s)\n  return s:gsub(\"[^%w]\", \"*\")\nen","completion":""}
{"prompt":"-- Only true if string is one of \"yes\", \"true\", \"t\", \"1\". Returns false\n-- otherwise.\nlocal function str2bool(string)\n\treturn string and (string:lower() == \"yes\" or string:lower() == \"true\" or string:lower() == \"t\" or string:lower() == \"1\")\nen","completion":""}
{"prompt":"-- Find the LCM of two numbers.\nlocal function find_lcm(num_1, num_2)\n    local num = 1\n    while num % num_1 ~= 0 or num % num_2 ~= 0 do\n        num = num + 1\n    end\n    return num\nen","completion":""}
{"prompt":"-- Get the base name of a variable, without the time index.\n-- Given a variable \"FooBar_10\", the last component is the time index (if present),\n-- so we want to strip the \"_10\".  This does no error checking.  You should not be\n-- passing in a variable whose name starts with \"Seq_\"; this is for user-generated\n-- names, not the internal names for DataTank.\nlocal function _basename_of_variable(varname)\n\tlocal last = string.find(varname, \"_%d+$\")\n\tif last then\n\t\treturn string.sub(varname, 1, last - 1)\n\telse\n\t\treturn varname\n\tend\nen","completion":""}
{"prompt":"-- Escape the given command line argument for the shell.\nlocal function _escapeArg(arg)\n\treturn arg:gsub(\"[\\\"'`]\", \"\\\\%0\")\nen","completion":""}
{"prompt":"-- Make data zero mean and with unit variance with given mean and standard deviation.\nlocal function stdr_val(val_freqv, mean, std)\n    val_freqv = val_freqv - mean\n    val_freqv = val_freqv \/ std\n    return val_freqv\nen","completion":""}
{"prompt":"-- Left rotate a 32-bit integer n by b bits.\nlocal function _left_rotate(n, b)\n    return ((n << b) | (n >> (32 - b))) & 0xFFFFFFFF\nen","completion":""}
{"prompt":"-- Return double factorial.\n-- Args:\n-- n (int): Argument (non-negative)\n-- Returns:\n-- Double factorial of n\nlocal function double_factorial(n)\n    if n < 0 then\n        error('Argument must be non-negative.')\n    elseif n == 0 then\n        return 1\n    elseif n == 1 then\n        return 1\n    else\n        return n * double_factorial(n - 2)\n    end\nen","completion":""}
{"prompt":"-- Converts a string into an action for Nim.\n-- Args:\n-- action_str (str):\n-- A string of the form \"(pile,num_stones)\"\n-- Returns:\n-- (int, int):\n-- ((pile,num_stones)), actions intended by action_str\nlocal function str_to_action(action_str)\n    local pile, num_stones = action_str:match(\"(.+),(.+)\")\n    return {tonumber(pile), tonumber(num_stones)}\nen","completion":""}
{"prompt":"-- t, tuple or list\n-- Each element of t is either an int, a tuple, or a list\n-- No tuple or list is empty\n-- Returns the maximum int in t or (recursively) in an element of t\nlocal function max_val(t)\n    local val, max = 0, 0\n    for k, v in pairs(t) do\n        local t = type(v)\n        if t == 'number' then\n            val = v\n        elseif t == 'table' then\n            val = max_val(v)\n        else\n            error(\"Type \"..t..\" not supported\")\n        end\n        if val > max then max = val end\n    end\n    return max\nen","completion":""}
{"prompt":"-- Translate CIDR to netmask notation.\n-- :param cidr:\n-- :return: netmask as string\nlocal function translater_cidr_netmask(cidr)\n    local mask = 0xffffffff << (32 - cidr)\n    return string.format(\"%d.%d.%d.%d\", (mask & 0xff000000) >> 24, (mask & 0xff0000) >> 16, (mask & 0xff00) >> 8, mask & 0xff)\nen","completion":""}
{"prompt":"-- Transforms the float 0.0-1.0 RGB color values to\n-- integer 0-255 RGB values.\nlocal function rgb_f2i(rgb)\n    return {\n        math.floor(rgb[1] * 255),\n        math.floor(rgb[2] * 255),\n        math.floor(rgb[3] * 255)\n    }\nen","completion":""}
{"prompt":"-- Reurns a list of regions\n-- # Returns:\n-- list, str\n-- # Example:\n-- from datahub_core import data\n-- regions = data.regions\n-- print(regions)\n-- >> ['NAM', 'EMEA', 'LATAM', 'APAC' ]\nlocal function regions()\n  local region_list = {\n    \"NAM\",\n    \"EMEA\",\n    \"LATAM\",\n    \"APAC\",\n  }\n  return region_list\nen","completion":""}
{"prompt":"-- wrap a list around something, if it is not currently a list\nlocal function listify(obj)\n\tif type(obj) == 'table' then\n\t\treturn obj\n\telse\n\t\treturn { obj }\n\tend\nen","completion":""}
{"prompt":"-- Get Attribute `attr` from dict `xmldict`\n-- Parameters\n-- ----------\n-- xmldict : dict\n-- Blob Description Dictionary\n-- attr : string\n-- Attribute key\n-- Returns\n-- -------\n-- sattr : int\n-- Attribute Values\nlocal function get_rb_data_attribute(xmldict, attr)\n\tif xmldict['@' .. attr] then\n\t\treturn tonumber(xmldict['@' .. attr])\n\tend\n\treturn nil\nen","completion":""}
{"prompt":"-- Function: get_center_location\n-- Parameters: N -> Number of rows in the Grid, M -> Number of columns in the Grid\n-- Returns: a tuple of center location of the disaster area\nlocal function get_center_location(N, M)\n    local center_location = {math.floor(N\/2), math.floor(M\/2)}\n    return center_location\nen","completion":""}
{"prompt":"-- Calculate the size of a matplotlib plot marker representing an object with\n-- a given visual megnitude.\n-- A third-degree polynomial was fit to a few hand-curated examples of\n-- marker sizes for magnitudes, as follows:\n-- >>> x = np.array([-1.44, -0.5, 0., 1., 2., 3., 4., 5.])\n-- >>> y = np.array([120., 90., 60., 30., 15., 11., 6., 1.])\n-- >>> coeffs = np.polyfit(x, y, 3)\n-- This function is valid over the range -2.0 < v <= 6.0; v < -2.0 returns\n-- size = 160. and v > 6.0 returns size = 1.\n-- Args:\n-- v_mag: A float representing the visual magnitude of a sky object.\n-- Returns:\n-- A float to be used as the size of a marker depicting the sky object in a\n-- matplotlib.plt scatterplot.\nlocal function _magnitude_to_marker_size(v_mag)\n  if v_mag < -2.0 then\n    return 160.0\n  elseif v_mag > 6.0 then\n    return 1.0\n  else\n    return 120.0 + 25.0*v_mag + 0.5*math.pow(v_mag, 2)\n  end\nen","completion":""}
{"prompt":"-- Parse comma separated list of component references to a list\nlocal function parseReferences(dStr)\n    -- split string on ',' and remove spaces\n    local refStr = string.gsub(dStr, \"(%s+)\", \"\")\n    local refList = {}\n    for ref in string.gmatch(refStr, \"([^,]+)\") do\n        table.insert(refList, ref)\n    end\n    return refList\nen","completion":""}
{"prompt":"-- Number of arms to be played in a round before Estimation\/Elimination routine.\n-- Parameters\n-- ----------\n-- i : round number\n-- Returns\n-- -------\n-- int : number of arms to be played in the current round\nlocal function round_function(i)\n    return 1\nen","completion":""}
{"prompt":"-- Convert minutes into something like 02h03m if given 123.\n-- Note that both hr and min are 0-padded\nlocal function convert_length_in_minutes_to_hr_min_str(length_minutes)\n  local hr = math.floor(length_minutes \/ 60)\n  local min = length_minutes % 60\n  return string.format(\"%02dh%02dm\", hr, min)\nen","completion":""}
{"prompt":"-- Encode an integer (0-26) into alpha characters, useful for sequences of\n-- axes\/figures.\n-- Parameters\n-- -----------\n-- int : :class:`int`\n-- Integer to encode.\n-- Returns\n-- ---------\n-- :class:`str`\n-- Alpha-encoding of a small integer.\nlocal function int_to_alpha(num)\n  if num < 26 then\n    return string.char(97 + num)\n  else\n    return int_to_alpha(num \/\/ 26) .. int_to_alpha(num % 26)\n  end\nen","completion":""}
{"prompt":"-- Do some massive stuff with one element from iterable.\nlocal function test_function(data, increase_by, sleep)\n\t-- Increase counter by `increase_by` (default 1) and return it.\n\t-- The optional `sleep` parameter will sleep for `sleep` milliseconds\n\t-- before returning.\n\tsleep = sleep or 0\n\treturn data + increase_by, sleep\nen","completion":""}
{"prompt":"-- Return text before start of entity.\nlocal function get_head(text, headpos, numchars)\n    local start = headpos - numchars + 1\n    if start <= 0 then\n        start = 1\n    end\n    return text:sub(start, headpos)\nen","completion":""}
{"prompt":"-- Return the standard length string of css.\n-- It's compatible with number values in old versions.\n-- :param x:\n-- :return:\nlocal function to_css_length(x)\n    if type(x) == 'string' then\n        return x\n    else\n        return string.format('%spx', x)\n    end\nen","completion":""}
{"prompt":"-- Use brute force to calculate the longest common substring of two strings\n-- Args:\n-- first: first string\n-- second: second string\n-- Returns:\n-- the length of the longest common substring\nlocal function lcs_brute_force(first, second)\n  local max = 0\n  for i = 1, #first do\n    for j = 1, #second do\n      local count = 0\n      while i + count < #first and j + count < #second and first:sub(i + count, i + count) == second:sub(j + count, j + count) do\n        count = count + 1\n      end\n      if count > max then\n        max = count\n      end\n    end\n  end\n  return max\nen","completion":""}
{"prompt":"-- Formats a height in decimeters as M m.\nlocal function format_height_metric(height)\n\treturn string.format(\"%.1f m\", height \/ 10)\nen","completion":""}
{"prompt":"-- Fibonacci Sequencer, returns f(N) per:www.oeis.org\/\n-- Performance is O(N) from calculating (N) by sequencing.\nlocal function fibonacciSequencer(N)\n\tif (N < 2) then\n\t\treturn N\n\tend\n\tlocal result = 0\n\tlocal previous = 0\n\tlocal current = 1\n\tfor i = 2,N,1 do\n\t\tresult = previous + current\n\t\tprevious = current\n\t\tcurrent = result\n\tend\n\treturn result\nen","completion":""}
{"prompt":"-- Return the idealised imperfection profile [m] - JIP.\n-- :param float x: Distance along profile [m]\n-- :param float delta_f: Imperfection height [m]\n-- :param float L_o: Natural wavelength [m]\nlocal function foundation_profile(x, delta_f, L_o)\n  return math.sin(x\/L_o*math.pi\/2) * delta_f\nen","completion":""}
{"prompt":"-- Given that v is voltage in Volts, return pressure as given by a HUBA 505 transducer\n-- The transducer is:\n-- 0.5V    -   0 bar\n-- 3.5V    -   4 bar\nlocal function huba505(voltage)\n    if voltage < 0.5 then\n        return 0\n    end\n    if voltage > 3.5 then\n        return 4\n    end\n    return 4 * (voltage - 0.5) \/ 3\nen","completion":""}
{"prompt":"-- parses input removing single quotes and semicolons\nlocal function parse_input(s)\n  return s:gsub(\"\\'\", \"\"):gsub(\";\", \"\")\nen","completion":""}
{"prompt":"-- Determinant of a 2d matrix\n-- A = [[a, b], [c, d]]\n-- det(A) = ad - bc\nlocal function det_2d_matrix(A)\n\tlocal a, b, c, d = A[1][1], A[1][2], A[2][1], A[2][2]\n\treturn a * d - b * c\nen","completion":""}
{"prompt":"-- s is a string of 0's and 1's\nlocal function _fromBinary(s)\n\tlocal x = 0\n\tfor i=1, #s do\n\t\tx = x * 2\n\t\tif s:sub(i, i) == '1' then\n\t\t\tx = x + 1\n\t\tend\n\tend\n\treturn x\nen","completion":""}
{"prompt":"-- Returns a list of *all* subclasses of cls, recursively.\nlocal function all_subclasses(cls)\n  local subclasses = {cls}\n  for _, subclass in pairs(subclasses) do\n    for _, subclass_subclass in pairs(all_subclasses(subclass)) do\n      if not subclass_subclass:is_a(cls) then\n        table.insert(subclasses, subclass_subclass)\n      end\n    end\n  end\n  return subclasses\nen","completion":""}
{"prompt":"-- anti-multiline workaround for ROS message types\nlocal function no_multilines(string)\n  string = string:gsub('%s+',' ')\n  string = string:gsub('%s+$','')\n  string = string:gsub('^%s+','')\n  return string\nen","completion":""}
{"prompt":"-- Expect a (number, list of numbers) tuple.\nlocal function unbox_usecase3(x)\n    local a, b = x[1], x[2]\n    local l = 0\n    for _, v in pairs(b) do\n        l = l + v\n    end\n    return a + l\nen","completion":""}
{"prompt":"-- Last name, Given name(s) or Last name, Given name(s) or just email if there are no given or last name\n-- :param first_name_first:\n-- :param user:\n-- :return:\nlocal function render_user_name(user, first_name_first)\n    if not user then\n        return \"\"\n    end\n    if user.email then\n        return user.email\n    end\n    local name = \"\"\n    if user.given_name then\n        name = user.given_name\n        if user.family_name then\n            name = name .. \" \" .. user.family_name\n        end\n    elseif user.family_name then\n        name = user.family_name\n    end\n    if not name or name == \"\" then\n        return user.id\n    end\n    if first_name_first then\n        return name\n    end\n    return user.family_name .. \", \" .. user.given_name\nen","completion":""}
{"prompt":"-- t^1\/2 fit w\/ 1 param: slope a.\nlocal function square_root_1param(t, a)\n  return a * t^0.5\nen","completion":""}
{"prompt":"-- Helper functie om een email adres te maskeren\n-- voorbeeld: nhb.whatever@gmail.com --> nh####w@gmail.com\nlocal function mailer_obfuscate_email(email)\n\tlocal e, l, c = string.match(email, \"([^@]+)@([^@]+)%.([^@]+)\")\n\tif (e and l) then\n\t\tlocal l2 = \"\"\n\t\tfor i = 1, #l do\n\t\t\tl2 = l2 .. string.sub(l, i, i)\n\t\tend\n\t\treturn e .. '@' .. l2 .. '.' .. c\n\tend\n\treturn email\nen","completion":""}
{"prompt":"-- For all characters in text, replace if found in map m or keep as-is\nlocal function mapChars(text, m)\n    local ret = {}\n    for i = 1, #text do\n        local c = text:sub(i, i)\n        local r = m[c]\n        if r then\n            table.insert(ret, r)\n        else\n            table.insert(ret, c)\n        end\n    end\n    return table.concat(ret)\nen","completion":""}
{"prompt":"-- Helps find square units, the nine 3x3 cells in a puzzle, in which a cell is in.\n-- Input\n-- x : row or column index of the cell in the puzzle.\n-- Output\n-- x : location of square unit, specifically the first cell of the unit.\nlocal function locateSquareHelper(x)\n    if x < 3 then\n        return 0\n    elseif x < 6 then\n        return 3\n    else\n        return 6\n    end\nen","completion":""}
{"prompt":"-- Print a list of help related flags\n-- :return: 1 for exit code purposes\n-- :rtype: int\nlocal function print_help_info()\n    io.stderr:write(\"Usage: \" .. arg[0] .. \" [-h|--help]\\n\")\n    io.stderr:write(\"Options:\\n\")\n    io.stderr:write(\"    --help\\n\")\n    io.stderr:write(\"        Prints this help info\\n\")\n    return 1\nen","completion":""}
{"prompt":"-- Converts a string to a float.\n-- Arguments:\n-- value (string) : The string to convert.\n-- Returns:\n-- float : The converted float.\nlocal function convert_to_float(value)\n  return tonumber(value) or value\nen","completion":""}
{"prompt":"-- Zero-padded right shift\nlocal function rshift_zero_padded(val, n)\n  return (val % 2^32) >> n\nen","completion":""}
{"prompt":"-- Coerce NoneType to empty list, wrap non-list in list.\nlocal function ensurelist(v)\n  if type(v) == \"nil\" then\n    return {}\n  elseif type(v) == \"table\" then\n    return v\n  else\n    return { v }\n  end\nen","completion":""}
{"prompt":"-- count_bits == PEP8 (forced mixedCase by CodeWars)\nlocal function countBits(n)\n  local count = 0\n  while n > 0 do\n    count = count + n % 2\n    n = n \/\/ 2\n  end\n  return count\nen","completion":""}
{"prompt":"-- If the coordinate pair defining a grid is equal, expand it out so\n-- that the grid is 2 * base wide.\nlocal function expandGrid(coord_tuple, base)\n  if coord_tuple[1] == coord_tuple[3] then\n    return {coord_tuple[1] - base, coord_tuple[2], coord_tuple[1] + base, coord_tuple[4]}\n  else\n    return coord_tuple\n  end\nen","completion":""}
{"prompt":"-- Retrieve a sorted list of images with most recent first.\nlocal function _sorted_images(images, start_name)\n\tlocal res = {}\n\tfor _, image in ipairs(images) do\n\t\ttable.insert(res, image)\n\tend\n\ttable.sort(res, function(a, b)\n\t\tlocal a_name = _image_name(a)\n\t\tlocal b_name = _image_name(b)\n\t\treturn a_name == b_name and b.createdAt > a.createdAt or a_name > b_name\n\tend)\n\treturn res\nen","completion":""}
{"prompt":"-- bs is a string of console output the lines are:\n-- # delete me if you .... (must be deleted)\n-- id     col1    col2\n-- 010101 c11     c22222 ...\n-- If first line begins with # then return an empty list\n-- Ignore the second line\n-- Return a list composed of the first column in the rest of document\n-- Stop at end of file or first empty line\nlocal function id_list_from_editor_output(bs)\n  local lines = {}\n  for line in bs:gmatch(\"[^\\r\\n]+\") do\n    if line:sub(1,1) == '#' then return {} end\n    if line == \"\" then return lines end\n    table.insert(lines, line:sub(3))\n  end\nen","completion":""}
{"prompt":"-- Return color c changed by intensity i\n-- For 0 <= i <= 127 the color is a shade, with 0 being black, 127 being the\n-- unaltered color.\n-- For 128 <= i <= 255 the color is a tint, with 255 being white, 128 the\n-- unaltered color.\nlocal function intensity(c, i)\n    local r = c[1] * i \/ 127\n    local g = c[2] * i \/ 127\n    local b = c[3] * i \/ 127\n    local a = c[4]\n    return {r, g, b, a}\nen","completion":""}
{"prompt":"-- check if integer n is a prime\nlocal function isprime(n)\n  if n <= 3 then return n > 1 end\n  if n % 2 == 0 or n % 3 == 0 then return false end\n  for i = 5, math.sqrt(n), 6 do\n    if n % i == 0 or n % (i + 2) == 0 then return false end\n  end\n  return true\nen","completion":""}
{"prompt":"-- Convert other to a compatible data type.\nlocal function as_data(self, other)\n\tif type(other) == 'number' then return other end\n\tif type(other) == 'table' then\n\t\tif getmetatable(other) == getmetatable(self) then\n\t\t\treturn other\n\t\telseif type(other.new) == 'function' then\n\t\t\treturn self:new(other)\n\t\tend\n\tend\n\treturn self(other)\nen","completion":""}
{"prompt":"-- Path to data depending on user launching the script\nlocal function data_path()\n    local path = \".\/\" -- Path to the working directory\n    if arg[0]:match(\"^@\") then\n        path = arg[0]:sub(1, arg[0]:find(\"@\") - 1) -- Path to the executable\n    end\n    return path\nen","completion":""}
{"prompt":"-- Given an input n, returns the closest integer above square root of n.\nlocal function calculateSquareRoot(n)\n  if n < 0 then\n    return 0\n  end\n  local root = math.floor(math.sqrt(n))\n  return (root * root) < n and root + 1 or root\nen","completion":""}
{"prompt":"-- Convert a box with arguments to x_min, y_min, x_max, y_max to YOLO\n-- The YOLO format is x_center, y_center, width, height (Normalized)\n-- Args:\n-- img_width (int): Width of the image\n-- img_height (int): Height of the image\n-- pascalvoc_box (List of floats): Bounding Box coordinates\n-- x_min, y_min, x_max, y_max\n-- Returns:\n-- list: Box coordinates in YOLO[x_center, y_center, width, height]\nlocal function pascalvoc_boxconvert_yolo(img_width, img_height, pascalvoc_box)\n\tlocal x_center = (pascalvoc_box[1] + pascalvoc_box[3]) \/ 2 \/ img_width\n\tlocal y_center = (pascalvoc_box[2] + pascalvoc_box[4]) \/ 2 \/ img_height\n\tlocal width = math.abs(pascalvoc_box[3] - pascalvoc_box[1]) \/ img_width\n\tlocal height = math.abs(pascalvoc_box[4] - pascalvoc_box[2]) \/ img_height\n\treturn {x_center, y_center, width, height}\nen","completion":""}
{"prompt":"-- compute the median of three values using built-in min and max functions\n-- and a little bit of arithmetic. \n-- Notes\n-- -----\n-- The median of three values is the sum of the values minus the smallest minus the largest\n-- Parameters\n-- ----------\n-- a : float, int\n-- the first value\n-- b : float, int\n-- the second value\n-- c : float, int\n-- the third value \n-- Returns\n-- -------\n-- the median of values a, b, and c\nlocal function median_solution_2(a, b, c)\n    local max = math.max(a, math.max(b, c))\n    local min = math.min(a, math.min(b, c))\n    return (a + b + c - max - min)\nen","completion":""}
{"prompt":"-- >>> print check_range(0,3,7)\n-- 3\n-- >>> print check_range(10,3,7)\n-- 7\n-- >>> print check_range(10,7,3)\n-- 3\nlocal function check_range(x, min_x, max_x)\n    if x < min_x then\n        return min_x\n    elseif x > max_x then\n        return max_x\n    else\n        return x\n    end\nen","completion":""}
{"prompt":"-- Returns a copy of text than only contains characters in chars\n-- This function is case-sensitive.\n-- >>> valid(\"Barking\")\n-- 'B'\n-- >>> valid(\"KL754\", \"0123456789\")\n-- '754'\n-- >>> valid(\"BEAN\", \"abcdefghijklmnopqrstuvwxyz\")\n-- ''\nlocal function valid(text, chars)\n  chars = chars or \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n  local result = \"\"\n  for _, c in utf8.codes(text) do\n    if string.find(chars, utf8.char(c)) then\n      result = result .. utf8.char(c)\n    end\n  end\n  return result\nen","completion":""}
{"prompt":"-- Takes the content response from a neo4j REST API paths call (URLs to paths)\n-- and returns a list of just the node ID's\nlocal function format_path_nodes(urls)\n  local nodes = {}\n  for k,v in pairs(urls) do\n    local node_id = string.match(v, 'node\/(%d+)')\n    table.insert(nodes, node_id)\n  end\n  return nodes\nen","completion":""}
{"prompt":"-- return key info\nlocal function get_keys(dict_info)\n\tlocal keys = {}\n\tfor k, v in pairs(dict_info) do\n\t\tif k ~= 'type' then\n\t\t\ttable.insert(keys, k)\n\t\tend\n\tend\n\ttable.sort(keys)\n\treturn keys\nen","completion":""}
{"prompt":"-- Get the template used to describe a machine code byte.\n-- This is a set of information that describes the byte (of which there\n-- could be many) of machine code that an operation (e.g. LOAD\n-- [$variable] A) results in.\n-- The keys have the following meaning:\n-- - bitstring: A byte bitstring of the final byte that will make up\n-- the machine code.\n-- - byte_type: The type of machine code byte. Will be instruction or\n-- constant.\n-- - constant_type: The type of the constant. Could be a label,\n-- variable or number.\n-- - constant: The constant that this byte will need to become. The\n-- resolution of the constant to a real machine code byte is done by\n-- the assembler.\n-- - number_value: The value of the constant as an int if it's a\n-- number.\n-- - index: The index of this byte in program data.\n-- Returns:\n-- dict: Machine code byte description template.\nlocal function get_machine_code_byte_template()\n  local byte_template = {\n    bitstring = \"\",\n    byte_type = \"\",\n    constant_type = \"\",\n    constant = \"\",\n    number_value = 0,\n    index = -1\n  }\n  return byte_template\nen","completion":""}
{"prompt":"-- This function generates the values of \u0007lpha to be used for cross validation.\nlocal function alpha_vals(a, n)\n  local alpha = {}\n  for i = 1, n do\n    alpha[i] = a + (i - 1) * (1.0 - a) \/ n\n  end\n  return alpha\nen","completion":""}
{"prompt":"-- Find the total sum of the numbers entered\nlocal function find_sum(num_digits, nums)\n    local sum = 0\n    for i = 1, #nums do\n        sum = sum + nums[i]\n    end\n    return sum\nen","completion":""}
{"prompt":"-- Convert a string formatted as\n-- \"{a} ({b})\" to \"{a}_{b}\"\n-- Args:\n-- x: input string\n-- Returns:\n-- Formatted string\nlocal function parentheses_to_snake(x)\n    if type(x) ~= \"string\" then return end\n    return string.gsub(x, \"^%s*(.-)%s*%((.-)%)%s*$\", \"%1_%2\")\nen","completion":""}
{"prompt":"-- Generate list of error rates for qualities less than equal than n.\nlocal function errs_tab(n)\n\tlocal t = {}\n\tfor i = 0, n do\n\t\tt[#t+1] = math.pow(10, -i\/10)\n\tend\n\treturn t\nen","completion":""}
{"prompt":"-- Convert a string specification like 00-04,07,09-12 into a list [0,1,2,3,4,7,9,10,11,12]\n-- Args:\n-- spec (str): string specification\n-- Returns:\n-- List[int]\n-- Example:\n-- >>> parse_list(\"00-04,07,09-12\")\n-- [0, 1, 2, 3, 4, 7, 9, 10, 11, 12]\n-- >>> parse_list(\"05-04\")\n-- Traceback (most recent call last):\n-- ...\n-- ValueError: In specification 05-04, end should not be smaller than begin\nlocal function parse_list(spec)\n  local list = {}\n  for range in spec:gmatch(\"[^,]+\") do\n    local begin, end_ = range:match(\"([^-]+)-(.+)\")\n    if end_ then\n      if tonumber(begin) > tonumber(end_) then\n        error(\"In specification \" .. range .. \", end should not be smaller than begin\")\n      end\n      for i = tonumber(begin), tonumber(end_) do\n        list[#list+1] = i\n      end\n    else\n      list[#list+1] = tonumber(range)\n    end\n  end\n  return list\nen","completion":""}
{"prompt":"-- Set a bit to off `0`\nlocal function unset_bit(bb, bit)\n    return bb & ~(1 << bit)\nen","completion":""}
{"prompt":"-- Multiply two quaternion.\nlocal function q_mult(a, b)\n  local result = {}\n  result[1] = a[1] * b[1] - a[2] * b[2] - a[3] * b[3] - a[4] * b[4]\n  result[2] = a[1] * b[2] + a[2] * b[1] + a[3] * b[4] - a[4] * b[3]\n  result[3] = a[1] * b[3] - a[2] * b[4] + a[3] * b[1] + a[4] * b[2]\n  result[4] = a[1] * b[4] + a[2] * b[3] - a[3] * b[2] + a[4] * b[1]\n  return result\nen","completion":""}
{"prompt":"-- A generic critical function for an interval,\n-- with weights at the endpoints.\n-- ((test_statistic < CL) + (test_statistic > CR) + \n-- gammaL * (test_statistic == CL) + \n-- gammaR * (test_statistic == CR))\n-- where (CL, gammaL) = left_cut, (CR, gammaR) = right_cut.\n-- Parameters\n-- ----------\n-- test_statistic : np.float\n-- Observed value of test statistic.\n-- left_cut : (float, float)\n-- (CL, gammaL): left endpoint and value at exactly the left endpoint (should be in [0,1]).\n-- right_cut : (float, float)\n-- (CR, gammaR): right endpoint and value at exactly the right endpoint (should be in [0,1]).\n-- Returns\n-- -------\n-- decision : np.float\nlocal function crit_func(test_statistic, left_cut, right_cut)\n    local CL = left_cut[1]\n    local CR = right_cut[1]\n    local gammaL = left_cut[2]\n    local gammaR = right_cut[2]\n    \n    local decision = 0\n    if test_statistic < CL then\n        decision = decision + 1\n    elseif test_statistic == CL then\n        decision = decision + gammaL\n    end\n    \n    if test_statistic > CR then\n        decision = decision + 1\n    elseif test_statistic == CR then\n        decision = decision + gammaR\n    end\n    \n    return decision\nen","completion":""}
{"prompt":"-- Checks that a numerical value (e.g. returned by robot) is an integer and\n-- not a float.\n-- Parameters\n-- ----------\n-- num : number to check\n-- Returns\n-- -------\n-- integer : num cast to an integer\n-- Raises\n-- ------\n-- ValueError : if n is not an integer\nlocal function num_to_int(num)\n    if num % 1 ~= 0 then\n        error('number is not an integer: ' .. tostring(num))\n    end\n    return math.floor(num)\nen","completion":""}
{"prompt":"-- Coerce a constant VBA object (integer, Null, etc) to a int.\n-- :param obj: VBA object\n-- :return: int\nlocal function coerce_to_int(obj)\n  if obj == nil then\n    return 0\n  elseif type(obj) == \"number\" then\n    return math.floor(obj)\n  elseif type(obj) == \"string\" then\n    local str_obj = obj:gsub('^0+', '')\n    if str_obj == \"\" then\n      return 0\n    else\n      return tonumber(str_obj) or 0\n    end\n  elseif type(obj) == \"boolean\" then\n    return obj and 1 or 0\n  elseif type(obj) == \"userdata\" then\n    return obj:value()\n  end\n  return 0\nen","completion":""}
{"prompt":"-- Inverts a matrix stored as a list of lists.\nlocal function arrayInvert(array)\n\tlocal res = {}\n\tfor i = 1, #array do\n\t\tres[i] = {}\n\t\tfor j = 1, #array[1] do\n\t\t\tres[i][j] = array[j][i]\n\t\tend\n\tend\n\treturn res\nen","completion":""}
{"prompt":"-- Convert a column index to spreadsheet letters.\n-- Adapted from http:\/\/asyoulook.com\/computers%20&%20internet\/python-convert-spreadsheet-number-to-column-letter\/659618\nlocal function spreadsheet_col_num_to_name(num)\n    -- 26 letters in the alphabet\n    local index_name = \"\"\n    local rem = num % 26\n    while (num >= 0) do\n        local col_num = (num - rem) \/ 26\n        if (col_num > 0) then\n            index_name = string.char(string.byte(\"A\") + rem) .. index_name\n        else\n            index_name = string.char(string.byte(\"A\") + rem) .. index_name\n        end\n        num = col_num - 1\n        rem = num % 26\n    end\n    return index_name\nen","completion":""}
{"prompt":"-- return identity matrix as `list` of \"vectors\" (lists themselves)\nlocal function eye(dimension)\n    local e = {}\n    for i = 1, dimension do\n        e[i] = {}\n        for j = 1, dimension do\n            e[i][j] = 0.0\n        end\n        e[i][i] = 1.0\n    end\n    return e\nen","completion":""}
{"prompt":"-- Calcula o Imposto de Renda sobre a PLR ou Bonus Anual\n-- :param plr:\n-- :return: valorIRPLR\nlocal function IR_PLR(plr)\n\tlocal plrVal = 0\n\tif plr < 200000 then\n\t\tplrVal = 0\n\telseif plr < 300000 then\n\t\tplrVal = 0.07\n\telseif plr < 450000 then\n\t\tplrVal = 0.14\n\telseif plr < 600000 then\n\t\tplrVal = 0.22\n\telseif plr < 900000 then\n\t\tplrVal = 0.32\n\telseif plr < 1500000 then\n\t\tplrVal = 0.37\n\telseif plr < 2500000 then\n\t\tplrVal = 0.45\n\telseif plr < 5000000 then\n\t\tplrVal = 0.47\n\telseif plr < 7500000 then\n\t\tplrVal = 0.50\n\telseif plr < 10000000 then\n\t\tplrVal = 0.53\n\telseif plr < 15000000 then\n\t\tplrVal = 0.55\n\telseif plr < 25000000 then\n\t\tplrVal = 0.60\n\telseif plr < 50000000 then\n\t\tplrVal = 0.70\n\telseif plr < 100000000 then\n\t\tplrVal = 0.80\n\telse\n\t\tplrVal = 0.90\n\tend\n\treturn plrVal\nen","completion":""}
{"prompt":"-- Parse a non-negative integer value\nlocal function natural(value)\n   local digits = string.match(value, \"^%d+\")\n   return digits and tonumber(digits)\nen","completion":""}
{"prompt":"-- Returns the percentile of 'value' in 'd's distribution.\n-- :param value: The value whose percentile is required\n-- :param d: A pandas.Series or Numpy array which represents the distribution\n-- :return: int\nlocal function which_percentile(value, d)\n    local count = 0\n    local percentile = 0\n    for k, v in pairs(d) do\n        count = count + 1\n        if value <= v then\n            percentile = k\n            break\n        end\n    end\n    return percentile\nen","completion":""}
{"prompt":"-- Convert row, col, cell type to state id\nlocal function trc2id(t, row, col, grid_dim)\n    return t*grid_dim[1]*grid_dim[2] + row*grid_dim[2] + col\nen","completion":""}
{"prompt":"-- Formats a number on thousands.\n-- :param n: Number\n-- :param c: Format char\n-- :return: Formatted number\nlocal function format_number_d(n, c)\n  local left,num,right = string.match(n,'^([^%d]*%d)(%d*)(.-)$')\n  return left..(num:reverse():gsub('(%d%d%d)','%1'..c):reverse())..right\nen","completion":""}
{"prompt":"-- Derivative of the parametric rectified linear unit function...\n-- Args:\n-- z (np.array)\n-- Returns:\n-- df(z)\/dz = 1 if x > 0 else alpha (np.array)\nlocal function dfdz_PReLU(z, alpha)\n\talpha = alpha or 0.25\n\tif type(z) ~= 'table' then\n\t\tz = {z}\n\tend\n\tlocal df = {}\n\tfor i, v in ipairs(z) do\n\t\tif v <= 0 then\n\t\t\tdf[#df+1] = alpha\n\t\telse\n\t\t\tdf[#df+1] = 1\n\t\tend\n\tend\n\tif #df == 1 then\n\t\treturn df[1]\n\tend\n\treturn df\nen","completion":""}
{"prompt":"-- merges source into destination\nlocal function deepmerge_dicts(source, destination)\n  if type(source) ~= 'table' then\n    destination[key] = source\n    return destination\n  end\n  for key, value in pairs(source) do\n    if type(value) == 'table' and type(destination[key] or false) == 'table' then\n      deepmerge_dicts(value, destination[key])\n    else\n      destination[key] = value\n    end\n  end\n  return destination\nen","completion":""}
{"prompt":"-- Returns a list\nlocal function listify(x)\n    local t = type(x)\n    if t == 'table' then\n        return x\n    elseif t == 'nil' then\n        return {}\n    else\n        return {x}\n    end\nen","completion":""}
{"prompt":"-- Calculate current time of video\nlocal function get_time_in_video(total_frames, frame_rate, curr_frame)\n\treturn curr_frame \/ frame_rate\nen","completion":""}
{"prompt":"-- Returns the difference between the sum of the squares of the first n\n-- natural numbers and the square of the sum.\n-- >>> solution(10)\n-- 2640\n-- >>> solution(15)\n-- 13160\n-- >>> solution(20)\n-- 41230\n-- >>> solution(50)\n-- 1582700\nlocal function solution(n)\n  local sumOfSquares = n * (n + 1) * (2 * n + 1) \/ 6\n  local squareOfSum = ((n + 1) * n) ^ 2 \/ 4\n  return squareOfSum - sumOfSquares\nen","completion":""}
{"prompt":"-- Hackerrank Problem: https:\/\/www.hackerrank.com\/challenges\/cats-and-a-mouse\/problem\n-- Two cats and a mouse are at various positions on a line. You will be given their starting positions. Your task is to\n-- determine which cat will reach the mouse first, assuming the mouse doesn't move and the cats travel at equal speed.\n-- If the cats arrive at the same time, the mouse will be allowed to move and it will escape while they fight.\n-- Determine which cat catches the mouse of if the mouse escapes.\n-- If the distance between the mouse and the cats is the same, it escapes.\n-- Otherwise, the cat that is closer to the mouse will catch it first.\n-- Args:\n-- x (int): Cat A's position\n-- y (int): Cat B's position\n-- z (int): Mouse C's position\n-- Returns:\n-- string: The cat that catches the mouse or the mouse if it escapes\nlocal function cat_and_mouse(x, y, z)\n    -- Handle if the mouse escapes\n    if math.abs(x - z) == math.abs(y - z) then\n        return \"Mouse C\"\n    -- Handle if Cat A catches the mouse\n    elseif math.abs(x - z) < math.abs(y - z) then\n        return \"Cat A\"\n    -- Handle if Cat B catches the mouse\n    else\n        return \"Cat B\"\n    end\nen","completion":""}
{"prompt":"-- Return the number of paths from one corner of an\n-- M by N grid to the opposite corner.\n-- >>> paths(2, 2)\n-- 2\n-- >>> paths(5, 7)\n-- 210\n-- >>> paths(117, 1)\n-- 1\n-- >>> paths(1, 157)\n-- 1\nlocal function paths(m, n)\n  if m == 1 and n == 1 then\n    return 1\n  end\n  if m == 1 then\n    return paths(m, n-1)\n  end\n  if n == 1 then\n    return paths(m-1, n)\n  end\n  return paths(m-1, n) + paths(m, n-1)\nen","completion":""}
{"prompt":"-- Just like comma, but returns a comma+space\nlocal function commaspace(member, memberList)\n    local comma = \"\"\n    if memberList and memberList[#memberList] ~= member then\n        comma = \", \"\n    end\n    return comma\nen","completion":""}
{"prompt":"-- Compute clustering index\n-- Parameters\n-- ----------\n-- Nu: int\n-- Number of units\n-- Nc: int\n-- Number of clusters\n-- Returns\n-- -------\n-- clust: float\n-- 0 if units are not clustered (checkerboard)\n-- 1 if units form a single cluster\nlocal function _single_clustering(Nu, Nc)\n    if Nu == 1 or Nc == 1 then\n        return 1\n    end\n    return 0\nen","completion":""}
{"prompt":"-- a) create a list of the dict's keys and values;\n-- b) return the key with the max value\n-- From stack overflow: getting-key-with-maximum-value-in-dictionary\nlocal function key_with_max_value(dictionary)\n   local max_value = 0\n   local max_key\n   for k,v in pairs(dictionary) do\n      if v > max_value then\n         max_value = v\n         max_key = k\n      end\n   end\n   return max_key\nen","completion":""}
{"prompt":"-- Find the Square Root on integer without using internal sqrt\n-- :param num: integer\n-- :return: floor(sqrt(num))\nlocal function sqrt(num)\n  local l = 1\n  local r = num\n  while l <= r do\n    local mid = math.floor((l + r) \/ 2)\n    if mid * mid == num then\n      return mid\n    elseif mid * mid < num then\n      l = mid + 1\n    elseif mid * mid > num then\n      r = mid - 1\n    end\n  end\n  return l - 1\nen","completion":""}
{"prompt":"-- Return a list of orders for context tiers.\n-- Parameters\n-- ----------\n-- value : int or string\n-- The maximum context length or a string in the set \"bigram\" (for\n-- context 1, and 2), \"trigram\" (for context 1, 2, and 3), or\n-- \"fourgram\" (for contexts 1, 2, 3, and 4).\nlocal function get_orders(value)\n    if type(value) == \"number\" then\n        local ret = {}\n        for i=1,value do\n            ret[#ret + 1] = i\n        end\n        return ret\n    elseif value == \"bigram\" then\n        return {1}\n    elseif value == \"trigram\" then\n        return {1, 2}\n    elseif value == \"fourgram\" then\n        return {1, 2, 3}\n    else\n        return {1}\n    end\nen","completion":""}
{"prompt":"-- Filter issues based on their label name.\n-- Parameters\n-- ----------\n-- issues : list\n-- Issue data.\n-- value : str\n-- Value required for the label name, e.g. \"status:web_ready\".\n-- Returns\n-- -------\n-- filtered_issues : list\n-- Filtered issues.\nlocal function filter_issues_on_label_name(issues, value)\n  local filtered_issues = {}\n  for _, issue in ipairs(issues) do\n    for _, label in ipairs(issue.labels) do\n      if label.name == value then\n        table.insert(filtered_issues, issue)\n        break\n      end\n    end\n  end\n  return filtered_issues\nen","completion":""}
{"prompt":"-- convert back from dimnesionless units\nlocal function with_tau_m(tau_m, prms)\n   prms.tau_m = tau_m\n   return prms\nen","completion":""}
{"prompt":"-- Args:\n-- old_value: computed average so far up to step n\n-- added_value: new value to be added to the average\n-- n: time step of the average (first is 1)\n-- Returns:\nlocal function incremental_average(old_value, added_value, n)\n  local n = n or 1\n  local new_value = 0\n  if old_value and added_value then\n    new_value = (old_value * (n - 1) + added_value) \/ n\n  end\n  return new_value\nen","completion":""}
{"prompt":"-- Get counter that finds index pairs of all contacts between layers.\n-- Args:\n-- layer_0: String. Must be key in state.\n-- layer_1: String. Must be key in state.\n-- Returns:\n-- _call: Function state --> list, where the elements of the returned list\n-- are tuples (i_0, i_0) of indices of sprites in layer_0 and layer_1\n-- that are contacting.\nlocal function get_contact_indices(layer_0, layer_1)\n   return function(state)\n      local pairs = {}\n      for i, _ in ipairs(state[layer_0]) do\n         for j, _ in ipairs(state[layer_1]) do\n            if state[layer_0][i].x <= state[layer_1][j].x + state[layer_1][j].w\n               and state[layer_0][i].x + state[layer_0][i].w\n                  >= state[layer_1][j].x\n               and state[layer_0][i].y <= state[layer_1][j].y + state[layer_1][j].h\n               and state[layer_0][i].y + state[layer_0][i].h\n                  >= state[layer_1][j].y\n            then\n               table.insert(pairs, {i, j})\n            end\n         end\n      end\n      return pairs\n   end\nen","completion":""}
{"prompt":"-- Escape text so that it will be displayed safely within HTML\nlocal function html_escape(text)\n\ttext = tostring(text)\n\treturn (text:gsub(\"[<>&]\", {\n\t\t[\"<\"] = \"&lt;\",\n\t\t[\">\"] = \"&gt;\",\n\t\t[\"&\"] = \"&amp;\"\n\t}))\nen","completion":""}
{"prompt":"-- Returns a decay factor based on the step function\n-- .. math::\n-- f(x) = \\begin{cases} high & \\mbox{if} x < threshold; \\\\\n-- low & otherwise.\n-- \\end{cases}\n-- :param x: The function argument.\n-- :param threshold: The first value of *x* that yields *low* as the decay factor.\nlocal function step(x, high, low, threshold)\n   return x < threshold and high or low\nen","completion":""}
{"prompt":"-- :return: Number, or 0 if number is negative\nlocal function non_negative(number)\n  return number and math.max(0, number) or 0\nen","completion":""}
{"prompt":"-- Get the ratio between pixel number and physical distance\n-- Returns the pixel-to-distance ratio (physical distance, in meters)\n-- Parameters\n-- ----------\n-- m_size : int\n-- The number of pixels used along one-dimension for the model\n-- (the model is assumed to be square)\n-- ant_rad : float\n-- The radius of the antenna trajectory during the scan, in meters\n-- Returns\n-- -------\n-- pix_to_dist_ratio : float\n-- The number of pixels per physical meter\nlocal function get_pixdist_ratio(m_size, ant_rad)\n  -- Get the radius of the model, in meters\n  local mod_rad = m_size \/ 2\n  -- Get the ratio between pixel number and physical distance\n  local pix_to_dist_ratio = mod_rad \/ ant_rad\n  -- Return the ratio\n  return pix_to_dist_ratio\nen","completion":""}
{"prompt":"-- Remove all duplicate monomials in the feedback functions FF.\nlocal function sort_function(FF)\n  local set = {}\n  local F = {}\n  for _, f in ipairs(FF) do\n    if not set[f] then\n      table.insert(F, f)\n      set[f] = true\n    end\n  end\n  return F\nen","completion":""}
{"prompt":"-- interest distance with weights for each dimension\nlocal function weighed_interest_distance(vec1, vec2, weights)\n    -- Calculate interest distance using the weighted Euclidean distance\n    local distance = 0\n    for i = 1, #vec1 do\n        distance = distance + math.abs(vec1[i] - vec2[i]) * weights[i]\n    end\n    return distance\nen","completion":""}
{"prompt":"-- Indents the given string by a specified number of indents.\n-- Indents the given string by a specified number of indents, e.g. indenting by 1 will preprend the string\n-- with 4 space characters:\n-- >>> indent_statement(0, 'x = 3')\n-- 'x = 3'\n-- >>> indent_statement(1, 'x = 3')\n-- '    x = 3'\nlocal function indent_statement(indent, statement)\n    if indent == 0 then\n        return statement\n    end\n    local prefix = string.rep('    ', indent)\n    return prefix .. statement\nen","completion":""}
{"prompt":"-- Get the userhost part of a nickmask.\n-- (The source of an Event is a nickmask.)\nlocal function nm_to_uh(s)\n\treturn string.sub(s, string.find(s, \"!\") + 1)\nen","completion":""}
{"prompt":"-- If the name of the transcript ends with -d as in\n-- ENSMUST00000169901.2-1, return ENSMUST00000169901.2\nlocal function removeAlignmentNumber(s)\n  return string.gsub(s, \"-[0-9]+$\", \"\")\nen","completion":""}
{"prompt":"-- converts temperature from format 0.1 to format 0.100 by adding three places after decimal\nlocal function temp_to_str(temp)\n    temp = tostring(temp)\n    local l = string.len(temp)\n    if l == 3 then\n        return temp .. \"00\"\n    elseif l == 4 then\n        return temp .. \"0\"\n    else\n        return temp\n    end\nen","completion":""}
{"prompt":"-- returns the grid cell coordinates containing the given point.\n-- size is the side length of a grid cell\n-- beware: in other languages negative coordinates need special care\n-- in C++ for example int(-1.5) == -1 and not -2 as we need\n-- hence we need floor(x \/ pas) in C++ using #include <cmath>\nlocal function cell(point, size)\n  local x = math.floor(point[1] \/ size)\n  local y = math.floor(point[2] \/ size)\n  return {x, y}\nen","completion":""}
{"prompt":"-- compute along 1 dimension, with these sizes, what will be the output dimension\n-- Arguments:\n-- X (int): input data dimension\n-- S (int): filter dimension\n-- padding (int): padding on each side\n-- strides (int): striding\nlocal function output_dim(X, S, padding, strides)\n   -- print(\"output_dim\")\n   -- print(\"X: \" .. tostring(X))\n   -- print(\"S: \" .. tostring(S))\n   -- print(\"padding: \" .. tostring(padding))\n   -- print(\"strides: \" .. tostring(strides))\n   return math.floor((X - S + 2 * padding)\/strides) + 1\nen","completion":""}
{"prompt":"-- Move a number towards another number (here, the numbers were angles).\n-- args:\n-- theta1: The first number\n-- theta2: The second number\n-- p: The extent of movement. 1 means full movement.\nlocal function move_angle_to_angle(theta1, theta2, p)\n    return theta1 + (theta2 - theta1) * p\nen","completion":""}
{"prompt":"-- Return price of OCEAN token, in USD\nlocal function OCEANprice(firm_valuation, OCEAN_supply)\n\tif (firm_valuation ~= nil) then\n\t\treturn firm_valuation\/OCEAN_supply\n\telse\n\t\treturn 1\/1000000000000\n\tend\nen","completion":""}
{"prompt":"-- modify image range from [0,1] to [-1, 1]\n-- return: range modified image\nlocal function preprocess(image)\n    return image * 2 - 1\nen","completion":""}
{"prompt":"-- Set a bit value onto an integer bitmask\n-- eg. set bits 2 and 4 to True\n-- >>> mask = 0\n-- >>> mask = set_value_at_index(mask, 2, True)\n-- >>> mask = set_value_at_index(mask, 4, True)\n-- >>> print(bin(mask))\n-- 0b10100\n-- >>> mask = set_value_at_index(mask, 2, False)\n-- >>> print(bin(mask))\n-- 0b10000\n-- :param bitmask: existing int bitmask to alter\n-- :type bitmask: int\n-- :type index: int\n-- :type value: bool\nlocal function set_value_at_index(bitmask, index, value)\n  if value then\n    return bitmask | (2 ^ index)\n  else\n    return bitmask & ~(2 ^ index)\n  end\nen","completion":""}
{"prompt":"-- Args:\n-- arr (list): 2d list of numbers.\n-- Returns:\n-- int: max hourglass sum\nlocal function hourglassSum(arr)\n  local maxSum = -math.huge\n  for i=2, #arr - 1 do\n    for j=2, #arr[i] - 1 do\n      maxSum = math.max(maxSum, \n        arr[i-1][j-1] + arr[i-1][j] + arr[i-1][j+1] +\n        arr[i][j] +\n        arr[i+1][j-1] + arr[i+1][j] + arr[i+1][j+1]\n      )\n    end\n  end\n  return maxSum\nen","completion":""}
{"prompt":"-- extract key-value pairs from a url query string\n-- for example\n-- \"collection=23&someoption&format=json\"\n-- -> {\"collection\": \"23\", \"someoption\": None, \"format\": \"json\"}\nlocal function _parse_query(query)\n  local pairs = {}\n  for k, v in query:gmatch(\"([^&=]+)=([^&=]*)\") do\n    pairs[k] = v\n  end\n  return pairs\nen","completion":""}
{"prompt":"-- Converts None to an empty string.\nlocal function none_to_empty(val)\n\tif val == nil then\n\t\treturn ''\n\telse\n\t\treturn val\n\tend\nen","completion":""}
{"prompt":"-- Returns the inverse of k modulo p.\n-- This function returns the only integer x such that (x * k) % p == 1.\n-- k must be non-zero and p must be a prime.\nlocal function inverse_mod(k, p)\n  local t = 0\n  local newt = 1\n  local r = p\n  local newr = k\n  while newr ~= 0 do\n    local quotient = math.floor(r \/ newr)\n    local temp = newt\n    newt = t - quotient * newt\n    t = temp\n    temp = newr\n    newr = r - quotient * newr\n    r = temp\n  end\n  if r > 1 then\n    return nil -- p and k aren't coprime\n  else\n    if t < 0 then t = t + p end\n    return t\n  end\nen","completion":""}
{"prompt":"-- https:\/\/en.wikipedia.org\/wiki\/Least_common_multiple\n-- >>> lcm(4, 6)\n-- 12\n-- >>> lcm(21, 6)\n-- 42\nlocal function lcm(a, b)\n    local function gcd(a, b)\n        if b == 0 then\n            return a\n        else\n            return gcd(b, a % b)\n        end\n    end\n    return (a * b) \/ gcd(a, b)\nen","completion":""}
{"prompt":"-- Compute the CRT private_exponent % (p - 1) value from the RSA\n-- private_exponent (d) and p.\nlocal function rsa_crt_dmp1(private_exponent, p)\n    return private_exponent % (p - 1)\nen","completion":""}
{"prompt":"-- Will use splice site sequence to infer validity of splice motif\nlocal function novelValidity(chr_seq, start, side, strand, toprint, chrom)\n  --[[\n  for side = 1,2 do\n    print(side)\n    print(string.sub(chr_seq,start+side-1,start+side-1+10))\n  end]]\n  -- If splice site is not present, then it's always novel\n  if (side == 1) and (string.sub(chr_seq,start+side-1,start+side-1) ~= \"G\") and (string.sub(chr_seq,start+side-1,start+side-1) ~= \"C\") then\n    --print(\"novel\")\n    return true\n  elseif (side == 2) and (string.sub(chr_seq,start+side-1,start+side-1) ~= \"A\") and (string.sub(chr_seq,start+side-1,start+side-1) ~= \"T\") then\n    --print(\"novel\")\n    return true\n  elseif side == 2 then\n    if (string.sub(chr_seq,start+side-1,start+side-1) == \"C\") and (string.sub(chr_seq,start+side,start+side) == \"G\") then\n      --print(\"novel\")\n      return true\n    end\n    if (string.sub(chr_seq,start+side-1,start+side-1) == \"T\") and (string.sub(chr_seq,start+side,start+side) == \"A\") then\n      --print(\"novel\")\n      return true\n    end\n  elseif side == 1 then\n    if (string.sub(chr_seq,start+side-1,start+side-1) == \"G\") and (string.sub(chr_seq,start+side,start+side) == \"C\") then\n      --print(\"novel\")\n      return true\n    end\n    if (string.sub(chr_seq,start+side-1,start+side-1) == \"A\") and (string.sub(chr_seq,start+side,start+side) == \"T\") then\n      --print(\"novel\")\n      return true\n    end\n  end\n  return false\nen","completion":""}
{"prompt":"-- Convert a file URI to a local path. Idempotent on regular paths.\n-- Raises if presented with a scheme besides file:\/\/\nlocal function path_from_file_uri(uri)\n  if not string.match(uri, \"^file:\/\/\") then\n    return uri\n  end\n  return uri:sub(8)\nen","completion":""}
{"prompt":"-- Position formatter.\n-- Check for valid position and format.\n-- @param value: value\n-- @return: position if value otherwise None.\nlocal function position_formatter(value)\n  if value == nil or value == '' or value == 'None' or value == 'none' then\n    return 'None'\n  end\n  value = tonumber(value)\n  if not value or value < 0 or value > 100000 then\n    return 'None'\n  end\n  return string.format('%.0f', value)\nen","completion":""}
{"prompt":"-- .\nlocal function get_type(geojson)\n    if geojson.type == \"Feature\" then\n        return geojson.geometry.type\n    else\n        return geojson.type\n    end\nen","completion":""}
{"prompt":"-- convert x to a list\nlocal function tolist(x)\n    return type(x) == 'table' and x or {x}\nen","completion":""}
{"prompt":"-- takes two RGB tuples and returns a componentwise weighted average\nlocal function interpolate_colors(a, b, bias)\n    return {\n        math.floor(a[1] + bias * (b[1] - a[1])),\n        math.floor(a[2] + bias * (b[2] - a[2])),\n        math.floor(a[3] + bias * (b[3] - a[3]))\n    }\nen","completion":""}
{"prompt":"-- Derivative of K with respect to u.\n-- .. math:\n-- \\dfrac{\\partial K}{\\partial u} = K_{u} = 3\\,\u000barepsilon \\kappa\\, (1 + \u000barepsilon\\, u)^2\n-- Parameters\n-- ----------\n-- u : array_like\n-- Temperature variable.\n-- kap : float\n-- Diffusion parameter.\n-- eps : float\n-- Inverse of activation energy.\n-- Returns\n-- -------\n-- array_like\n-- Ku evaluation.\nlocal function Ku(u, kap, eps)\n   return 3 * eps * kap * (1 + eps * u)^2\nen","completion":""}
{"prompt":"-- Return clamped value between minimum and maximum.\n-- :param float value:\n-- :param float minimum:\n-- :param float maximum:\nlocal function clamp(value, minimum, maximum)\n    return math.max(math.min(value, maximum), minimum)\nen","completion":""}
{"prompt":"-- Reconstruct the library name without it's version\nlocal function libname_from_dir(dirname)\n  return dirname:gsub(\"%-?%d+.*$\", \"\")\nen","completion":""}
{"prompt":"-- Load the hashes dict from the hashfile\nlocal function load_hashes(filename)\n    if not filename then return {} end\n    local hashes = {}\n    local f = io.open(filename, \"rb\")\n    if not f then return {} end\n    for line in f:lines() do\n        local hash = line:match(\"^([0-9a-f]+) [a-z]+$\")\n        if hash then\n            table.insert(hashes, hash)\n        end\n    end\n    f:close()\n    return hashes\nen","completion":""}
{"prompt":"-- returns produces the nth fibonacci numbers following a, b\nlocal function next_fib(a, b, n)\n    if n == 0 then return b\n    else return next_fib(b, a + b, n - 1)\n    end\nen","completion":""}
{"prompt":"-- Returns the input string but with all newlines removed and truncated.\n-- The newlines are replaced with spaces.  This is done both for carriage return and newline.\n-- Note, this does not add ellipses for the truncated text.\n-- @param input_string: The string to transform\n-- @param char_limit: The maximum number of characters the resulting string should be\n-- @type input_string: str\n-- @type char_limit: int\n-- @return:  The string with all newlines replaced with spaces and truncated.\n-- @rtype: str\nlocal function remove_newlines_and_truncate(input_string, char_limit)\n    local new_input_string = string.gsub(input_string, '\\n', ' ')\n    new_input_string = string.gsub(new_input_string, '\\r', ' ')\n    if char_limit ~= nil then\n        if string.len(new_input_string) > char_limit then\n            new_input_string = string.sub(new_input_string, 1, char_limit)\n        end\n    end\n    return new_input_string\nen","completion":""}
{"prompt":"-- Easing function for animations: Cubic Ease In & Out\nlocal function cubic_easeinout(pos)\n  if pos < 0.5 then return 4 * pos * pos * pos else return 0.5 * math.pow(2 * pos - 2, 3) + 1 end\nen","completion":""}
{"prompt":"-- Return the distance (mm) from signal travel time (ns) and velocity (m\/ns).\n-- Attributes:\n-- time <float>: travel time (ns) of radio signal;\n-- velocity <float>: travel velocity (m\/ns) of radio signal.\nlocal function ns2mm(time, velocity)\n  if (time and velocity) then\n    return time * velocity * 1000\n  end\n  return 0\nen","completion":""}
{"prompt":"-- Return a fraction as a percent value.\nlocal function print_percent(val)\n  return string.format(\"%.2f\", val * 100)\nen","completion":""}
{"prompt":"-- Remove any indentation and newlines from the html.\nlocal function collapse(html)\n\tlocal t = {}\n\tfor w in html:gmatch(\"([^\\r\\n]+)\") do\n\t\tw = w:gsub(\"^%s*\", \"\"):gsub(\"%s*$\", \"\"):gsub(\"  \", \" \")\n\t\ttable.insert(t, w)\n\tend\n\treturn table.concat(t, \"\")\nen","completion":""}
{"prompt":"-- Return snapshot to use based off latest available snapshot from a list of snapshots\nlocal function get_latest_snapshot_identifier(snapshot_list, engine)\n\tlocal latest_snapshot = {}\n\tlocal latest_snapshot_identifier = \"\"\n\tlocal latest_snapshot_create_time = 0\n\tfor i, snapshot in ipairs(snapshot_list) do\n\t\tlocal snapshot_identifier = snapshot.id\n\t\tlocal snapshot_create_time = snapshot.createTime\n\t\tif engine == nil then\n\t\t\tif latest_snapshot_create_time < snapshot_create_time then\n\t\t\t\tlatest_snapshot = snapshot\n\t\t\t\tlatest_snapshot_create_time = snapshot_create_time\n\t\t\t\tlatest_snapshot_identifier = snapshot_identifier\n\t\t\tend\n\t\telse\n\t\t\tif latest_snapshot_create_time < snapshot_create_time then\n\t\t\t\tlatest_snapshot_identifier = snapshot_identifier\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\treturn latest_snapshot_identifier\nen","completion":""}
{"prompt":"-- :return: the components x, negated if both components are negative\nlocal function corrected_components(x)\n    return {\n        x[1],\n        x[2] < 0 and -x[2] or x[2],\n    }\nen","completion":""}
{"prompt":"-- Enquote string if it's not numeric.\n-- Args:\n-- s (str): The string to enquote.\n-- Returns:\n-- str: A quoted string or unquoted numeric value as a string.\nlocal function enquote(s)\n  local n = tonumber(s)\n  return n and tostring(n) or '\"'..tostring(s):gsub('\"','\\\\\"'):gsub('%%','%%%%')..'\"'\nen","completion":""}
{"prompt":"-- :parameters\n-- tic -- start time, system time\n-- toc -- finish time, system time\n-- :returns\n-- runtime - string in format 'MM min SS sec'\nlocal function get_readable_runtime(tic_, toc_)\n    local s = toc_ - tic_\n    local min = math.floor(s \/ 60)\n    local sec = math.floor(s - min * 60)\n    local runtime = string.format(\"%d min %d sec\", min, sec)\n    return runtime\nen","completion":""}
{"prompt":"-- translate tkinter hex color code #ffffff to rgb tuple of integers\n-- https:\/\/stackoverflow.com\/a\/29643643\/6929343\nlocal function hex_to_rgb(hex_str)\n    local hex = hex_str:gsub(\"#\",\"\"):gsub(\"0x\",\"\"):gsub(\"0X\",\"\")\n    local rgb_tbl = {\n        tonumber(\"0x\"..hex:sub(1,2)) or 0,\n        tonumber(\"0x\"..hex:sub(3,4)) or 0,\n        tonumber(\"0x\"..hex:sub(5,6)) or 0\n    }\n    return rgb_tbl\nen","completion":""}
{"prompt":"-- Counts the number of uppercase letters in a string.\n-- Args:\n-- val (str): The string to count uppercase letters in.\n-- Returns:\n-- int: The number of uppercase letters in the string.\nlocal function count_uppers(val)\n  return #val:gsub(\"[^A-Z]\", \"\")\nen","completion":""}
{"prompt":"-- Takes a decimal number as input and returns the number of ones in the\n-- binary representation.\n-- This translates to the number of tasks being done by an organism with a\n-- phenotype represented as a decimal number.\nlocal function n_tasks(dec_num)\n  local num_tasks = 0\n  while dec_num > 0 do\n    num_tasks = num_tasks + dec_num % 2\n    dec_num = math.floor(dec_num \/ 2)\n  end\n  return num_tasks\nen","completion":""}
{"prompt":"-- calculated the area of a polygon given points on its surface\n-- https:\/\/stackoverflow.com\/questions\/24467972\/calculate-area-of-polygon-given-x-y-coordinates\n-- https:\/\/en.wikipedia.org\/wiki\/Shoelace_formula\nlocal function polygon_area(corners)\n    local sum = 0\n    for i=1,#corners-1,1 do\n        sum = sum + corners[i][1]*corners[i+1][2] - corners[i][2]*corners[i+1][1]\n    end\n    sum = sum + corners[#corners][1]*corners[1][2] - corners[#corners][2]*corners[1][1]\n    return math.abs(sum\/2)\nen","completion":""}
{"prompt":"-- strip trailing whitespace and leading and trailing empty lines\nlocal function stripdesc(desc)\n  return string.gsub(string.gsub(desc, \"^%s*(.-)%s*$\", \"%1\"), \"^(.-)%s*[\\n\\r]*$\", \"%1\")\nen","completion":""}
{"prompt":"-- Return a tuple from the input.\nlocal function _as_tuple(x)\n\treturn type(x) == \"table\" and x or {x}\nen","completion":""}
{"prompt":"-- Conversion from SI wind speed units to km\/hr.\n-- Note\n-- ----\n-- Code was migrated from https:\/\/github.com\/nguy\/PyRadarMet.\n-- Parameters\n-- ----------\n-- vals : float\n-- float or array of floats\n-- Speed in SI units (m\/s)\n-- Returns\n-- -------\n-- output: float\n-- float or array of floats\n-- Speed in km\/hr\n-- Examples\n-- --------\n-- >>> from wradlib.trafo import si_to_kmh\n-- >>> print(si_to_kmh(1.))\n-- 3.6\nlocal function si_to_kmh(vals)\n    return (vals * 3.6)\nen","completion":""}
{"prompt":"-- Interpolate between x and y by the fraction p.\n-- When p == 0 x will be returned, when p == 1 y will be returned.  Note\n-- that p is not restricted to being between 0 and 1.\n-- :Return:\n-- The interpolated value.\n-- :Param x, y:\n-- The interpolation end-points.\n-- :Param p:\n-- The interpolation fraction.\nlocal function lerp(x, y, p)\n\treturn (y - x) * p + x\nen","completion":""}
{"prompt":"-- Calculate the Signal-to-Noise Ratio (SNR) of an image.\n-- - For anatomical images:\n-- SNR = (mean GM intensity) \/ (std of background intensities)\n-- - For functional images:\n-- SNR = (mean brain intensity) \/ (std of background intensities)\n-- :type mean_fg: float\n-- :param mean_fg: The mean value of voxel intensities in the foreground\n-- (either within the head or a particular tissue) of the\n-- image.\n-- :type std_bg: float\n-- :param std_bg: The standard deviation of the voxel intensities of the\n-- background (outside of the head) voxels.\n-- :rtype: float\n-- :return: The signal-to-noise ratio (SNR).\nlocal function snr(mean_fg, std_bg)\n    return (mean_fg \/ std_bg)\nen","completion":""}
{"prompt":"-- Simple dot (scalar) product of two lists of numbers (assumed to be the same length)\nlocal function dotprod(u, v)\n\tlocal sum = 0\n\tfor i=1, #u do\n\t\tsum = sum + u[i] * v[i]\n\tend\n\treturn sum\nen","completion":""}
{"prompt":"-- Extract key of epic this issue belongs to (if given), else ''.\n-- Example XML:\n-- <customfields>\n-- <customfield id=\"customfield_10730\" key=\"com.pyxis.greenhopper.jira:gh-epic-link\">\n-- <customfieldname>Epic Link<\/customfieldname>\n-- <customfieldvalues>\n-- <customfieldvalue>IRS-4<\/customfieldvalue>\n-- <\/customfieldvalues>\n-- <\/customfield>\n-- ...\n-- <\/customfields>\nlocal function parse_epic_link(el)\n  if el ~= nil then\n    local epic_link = xml.find(el, 'customfieldvalue')\n    if epic_link ~= nil then\n      return xml.find(epic_link, 'key')\n    else\n      return ''\n    end\n  else\n    return ''\n  end\nen","completion":""}
{"prompt":"-- Create a function that takes any arguments and always\n-- returns x.\nlocal function returner(x)\n  return function(...)\n    return x\n  end\nen","completion":""}
{"prompt":"-- Sets the high (second least significant) byte of a 16 bit (or longer) target value (*not* a little endian word!) to\n-- hi_byte\nlocal function set_high_byte(target, hi_byte)\n\treturn ((hi_byte % 256) * 256) + (target % 256)\nen","completion":""}
{"prompt":"-- Convert a python value to a corresponding R string.\n-- >>> _literal_to_r_str(True)\n-- \"TRUE\"\n-- >>> _literal_to_r_str(6)\n-- \"8\"\n-- >>> _literal_to_r_str(\"test\")\n-- \"'test'\"\nlocal function _literal_to_r_str(value)\n  if value == nil then\n    return \"NULL\"\n  elseif type(value) == \"boolean\" then\n    if value then\n      return \"TRUE\"\n    else\n      return \"FALSE\"\n    end\n  elseif type(value) == \"number\" then\n    return tostring(value)\n  elseif type(value) == \"string\" then\n    return string.format(\"'%s'\", value)\n  elseif type(value) == \"table\" then\n    local json = require \"dkjson\"\n    return string.format(\"'%s'\", json.encode(value))\n  end\n  error(string.format(\"'%s' is of unsupported type '%s'\", value, type(value)))\nen","completion":""}
{"prompt":"-- Scale [min, max] to [0, 1]\n-- Normalize x to [min, max]\nlocal function normalize(x, min, max)\n  return (x - min) \/ (max - min)\nen","completion":""}
{"prompt":"-- Returns a linear value with a drop near the middle to a constant value for the Scheduler\n-- :param progress: (float) Current progress status (in [0, 1])\n-- :return: (float) 1 - progress if (1 - progress) >= 0.75 else 0.075\nlocal function middle_drop(progress)\n    if progress < 0.75 then\n        return 1 - progress\n    else\n        return 0.075\n    end\nen","completion":""}
{"prompt":"-- Performs the inverse of a min-max scaler (see method above),\n-- applied to a single number\nlocal function min_max_rescale(num, min_value, max_value)\n  return num * (max_value - min_value) + min_value\nen","completion":""}
{"prompt":"-- Internal normalization function for clipping integer values into\n-- the permitted range (0-255, inclusive).\nlocal function _normalize_integer_rgb(value)\n  if value < 0 then\n    value = 0\n  elseif value > 255 then\n    value = 255\n  end\n  return value\nen","completion":""}
{"prompt":"-- Suppress errors for openthread\nlocal function openthread_suppress_error_flags()\n  _G.error = function() end\nen","completion":""}
{"prompt":"-- Generate a mask to grab `i` bits from an int value.\nlocal function _mask_for_bits(i)\n    return (1 << i) - 1\nen","completion":""}
{"prompt":"-- Calculates the Manhattan distance between two pairs of grid coordinates.\nlocal function heuristic(a, b)\n  return math.abs(a[1] - b[1]) + math.abs(a[2] - b[2])\nen","completion":""}
{"prompt":"-- Slope between the two points only if the pixel is higher\n-- than the other\n-- 20150603 Scott Havens\nlocal function _slope_all(xi, zi, xj, zj)\n    return (zi - zj) \/ (xi - xj)\nen","completion":""}
{"prompt":"-- assume the length of encode1 and encode2 are n, time complexity is\n-- O(n), space complexity is O(n)\nlocal function _vector_similarity(encode1, encode2)\n    local n = #encode1\n    local score = 0\n    for i = 1, n do\n        score = score + encode1[i] * encode2[i]\n    end\n    return score\nen","completion":""}
{"prompt":"-- If the year is older than the defined \"starting_year\", i.e\n-- the year from when we start counting, set it to the \"starting_year\"\n-- This is just internal handling of the code and won't change the data\nlocal function smaller_starting_year(year, starting_year)\n  if year < starting_year then\n    return starting_year\n  else\n    return year\n  end\nen","completion":""}
{"prompt":"-- Gets a telegram message and returns all text as string\n-- :param tel_msg: Telegram message\nlocal function get_text_from_tel_msg(tel_msg)\n    local ok, result = pcall(function()\n        return tel_msg.text or \"\"\n    end)\n    if ok then\n        return result\n    else\n        return \"\"\n    end\nen","completion":""}
{"prompt":"-- Return the aparc+aseg.mgz file\nlocal function get_aparc_aseg(files)\n  for _, file in ipairs(files) do\n    if file:lower():match('aparc+') and file:lower():match('aseg') and file:lower():match('mgz') then\n      return file\n    end\n  end\n  return nil\nen","completion":""}
{"prompt":"-- Returns a new list with the given element at the front, followed by the\n-- contents of the list\nlocal function prepend(value, list)\n    local new_list = {value}\n    for _, element in pairs(list) do\n        new_list[#new_list + 1] = element\n    end\n    return new_list\nen","completion":""}
{"prompt":"-- Remove punctuation from a text.\n-- :param text:    the text input\n-- :return:        the text with punctuation removed\nlocal function _remove_punctuation(text)\n    return text:gsub('[^a-zA-Z0-9 \\n\\r\\t]', '')\nen","completion":""}
{"prompt":"-- Convert 3D coordinates to homogeneous coordinates.\n-- Arguments:\n-- pnts: A sequnce array of 3-tuples (x,y,z)\n-- Returns:\n-- A list of 4-tuples (x,y,z,1)\nlocal function to4(pnts)\n  local l = {}\n  for _,v in ipairs(pnts) do\n    table.insert(l, {v[1],v[2],v[3],1})\n  end\n  return l\nen","completion":""}
{"prompt":"-- Return the reverse complement of a string from a DNA strand. Found this method that is slightly faster than\n-- biopython. Thanks to this stack exchange post:\n-- https:\/\/bioinformatics.stackexchange.com\/questions\/3583\/what-is-the-fastest-way-to-get-the-reverse-complement-of-a-dna-sequence-in-pytho\n-- :param dna_string: string of DNA, either in string or Seq format\n-- :return: the reverse complement of the above string in either string or MutableSeq format\nlocal function reverse_complement(dna_string)\n    local seq_type = type(dna_string)\n    local complements = {\n        A = 'T',\n        T = 'A',\n        C = 'G',\n        G = 'C',\n        N = 'N'\n    }\n    local rev_complements = {}\n    for i = #dna_string, 1, -1 do\n        local char = dna_string:sub(i, i)\n        rev_complements[#rev_complements + 1] = complements[char]\n    end\n    local rev_complement_string = seq_type == 'string' and table.concat(rev_complements) or Seq.MutableSeq(table.concat(rev_complements), 'dna')\n    return rev_complement_string\nen","completion":""}
{"prompt":"-- Compute the output plane sampling which is Nyquist sampled for\n-- intensity.\n-- Parameters\n-- ----------\n-- wave : float\n-- Wavelength in meters\n-- f_number : float\n-- Optical system F\/#\n-- Returns\n-- -------\n-- float\n-- Sampling in meters\nlocal function pixelscale_nyquist(wave, f_number)\n  return wave * (f_number \/ 2.0)\nen","completion":""}
{"prompt":"-- Verify that values remain in valid range\nlocal function bounds_check(i)\n  return math.max(math.min(i, 255), 0)\nen","completion":""}
{"prompt":"-- Return a box-shape (Theta-function) that is zero before `t_start` and\n-- after `t_stop` and one elsewehere.\n-- Parameters:\n-- t (scalar, numpy.ndarray): Time point or time grid\n-- t_start (scalar): First value of `t` for which the box has value 1\n-- t_stop (scalar): Last value of `t` for which the box has value 1\n-- Returns:\n-- box_shape (numpy.ndarray(float)): If `t` is an array, `box_shape` is\n-- an array of the same size as `t` If `t` is scalar, `box_shape` is\n-- an array of size 1 (which for all intents and purposes can be used\n-- like a float)\nlocal function box(t, t_start, t_stop)\n  if type(t) == 'number' then\n    return t_stop < t and 0 or t < t_start and 0 or 1\n  elseif type(t) == 'table' then\n    local box_shape = {}\n    for i, time_point in ipairs(t) do\n      box_shape[i] = box(time_point, t_start, t_stop)\n    end\n    return box_shape\n  else\n    error('t must be scalar or a table of scalars')\n  end\nen","completion":""}
{"prompt":"-- Applies the EPA calibration to Purple's PM2.5 data.\n-- Version of formula matches the Purple Air site's info.\n-- We floor it to 0 since the combination of very low pm2.5 concentration\n-- and very high humidity can lead to negative numbers.\nlocal function _apply_epa_correction(pm, rh)\n\treturn math.max(0, pm - (0.033 * rh * rh))\nen","completion":""}
{"prompt":"-- Create quick reply message.\n-- reference\n-- - `Common Message Property <https:\/\/developers.worksmobile.com\/jp\/document\/100500807?lang=en>`_\n-- :param replay_items: Array of return object of make_quick_reply_item function.\n-- :return: quick reply content.\nlocal function make_quick_reply(replay_items)\n    local quick_reply = {}\n    quick_reply.items = replay_items\n    return quick_reply\nen","completion":""}
{"prompt":"-- return the relative path of the file in the given URI\n-- for uri = '\/...\/files\/a\/b\/c', return 'a\/b\/c'\n-- raises ValueError (through .index()) if '\/files\/' is not in the URI\nlocal function file_path(uri)\n  if uri:find(\"\/files\/\") == nil then\n    error(\"no files dir found\")\n  end\n  return uri:sub(uri:find(\"\/files\/\") + 7)\nen","completion":""}
{"prompt":"-- Calculate fuel level for the given coordinate(s).\nlocal function fuel_level(x, y, serial_number)\n  local rack_id = x + 10\n  rack_id = (rack_id * y + serial_number) * rack_id\n  rack_id = math.floor((rack_id % 1000) \/ 100)\n  return rack_id - 5\nen","completion":""}
{"prompt":"-- Splits long queried urls into many shorter urls.\nlocal function _http_414_scrubber(endpoints)\n    for _, endpoint in pairs(endpoints) do\n        if endpoint.http_method == \"GET\" and #endpoint.uri > 2000 then\n            local scrubbed_endpoints = {}\n            local uri_parts = endpoint.uri:split(\"\/\", true)\n            local scrubbed_uri = \"\"\n            for i = 1, #uri_parts, 10 do\n                scrubbed_uri = table.concat(uri_parts, \"\/\", i, i + 9)\n                local new_endpoint = endpoint\n                new_endpoint.uri = scrubbed_uri\n                scrubbed_endpoints[#scrubbed_endpoints + 1] = new_endpoint\n            end\n            endpoints = endpoints:merge(scrubbed_endpoints)\n        end\n    end\n    return endpoints\nen","completion":""}
{"prompt":"-- Return the sign of each entry of an array\nlocal function signum(x)\n\treturn (x > 0) and 1 or ((x < 0) and -1 or 0)\nen","completion":""}
{"prompt":"-- align(alignment, x) -> int\n-- Rounds `x` up to nearest multiple of the `alignment`.\n-- Example:\n-- >>> [align(5, n) for n in range(15)]\n-- [0, 5, 5, 5, 5, 5, 10, 10, 10, 10, 10, 15, 15, 15, 15]\nlocal function align(alignment, x)\n    return math.floor((x + alignment - 1) \/ alignment) * alignment\nen","completion":""}
{"prompt":"-- Pull all values of specified key from nested JSON.\n-- Taken from: https:\/\/hackersandslackers.com\/extract-data-from-complex-json-python\/\nlocal function extract_values(obj, key)\n    local result = {}\n    local function extract(obj, arr)\n        for k, v in pairs(obj) do\n            if type(v) == \"table\" then\n                extract(v, arr)\n            else\n                if k == key then\n                    table.insert(arr, v)\n                end\n            end\n        end\n    end\n    extract(obj, result)\n    return result\nen","completion":""}
{"prompt":"-- Calculate next cumulative moving average\n-- 'list_len' is the length of the currently being averaged list before adding the new value\nlocal function next_cma(new_value, list_len, old_cma)\n\treturn old_cma + (new_value - old_cma) \/ (list_len + 1)\nen","completion":""}
{"prompt":"-- Scale the graph\n-- graph = ...\n-- newg  = graph \/ 10\nlocal function _gre_div_(graph, scale)\n    return graph \/ scale\nen","completion":""}
{"prompt":"-- Returns the opposite (if exists) of an instruction.\nlocal function invert(instruction, mirror)\n\treturn mirror[instruction] or instruction\nen","completion":""}
{"prompt":"-- \nlocal function normal_format(x, pos)\n\tif pos == 1 then\n\t\treturn tostring(x)\n\telse\n\t\treturn tostring(x)\n\tend\nen","completion":""}
{"prompt":"-- Method to return a rounded down number\n-- Args:\n-- num: (float), a number to round down\n-- divisor: (int), divisor to denote how to round down\n-- Returns:\n-- (float), the rounded-down number\nlocal function round_down(num, divisor)\n\tlocal rounded = math.floor(num \/ divisor) * divisor\n\treturn rounded\nen","completion":""}
{"prompt":"-- Mathematical step function\n-- A type of indicatio function\/characteristic function.\nlocal function step_function(x)\n  if x >= 0 then\n    return 1\n  else\n    return 0\n  end\nen","completion":""}
{"prompt":"-- Function to convert minutes to seconds.\nlocal function minutes_to_second(minutes)\n    if minutes ~= nil then\n        return minutes * 60\n    else\n        return 0\n    end\nen","completion":""}
{"prompt":"-- Calculated as in global_pct_id(), but with the percent similarity field\nlocal function global_pct_sim(segments)\n    local total_sim = 0\n    local segment_count = 0\n    for _, seg in pairs(segments) do\n        local sim = seg.pct_sim\n        if sim ~= nil then\n            total_sim = total_sim + sim\n            segment_count = segment_count + 1\n        end\n    end\n    return total_sim \/ segment_count\nen","completion":""}
{"prompt":"-- Get neighboring cell positions\n-- Args:\n-- r_index (int): Current row index\n-- c_index ([type]): Current column index\n-- Returns:\n-- [List of list of integers]: List of neighbors with each neighbor containing a list of their row and column index.\nlocal function get_neighbors(r_index, c_index)\n    local neighbor_positions = {\n        {r_index-1, c_index-1},\n        {r_index-1, c_index},\n        {r_index-1, c_index+1},\n        {r_index, c_index-1},\n        {r_index, c_index+1},\n        {r_index+1, c_index-1},\n        {r_index+1, c_index},\n        {r_index+1, c_index+1},\n    }\n    return neighbor_positions\nen","completion":""}
{"prompt":"-- Monarch begins its indexing at zero, and start refers to the index of\n-- the data rather than the page number. This method calculates the start index\n-- from the pageNumber and pageSize\nlocal function getStartIndex(pageNumber, pageSize)\n  return (pageNumber - 1) * pageSize\nen","completion":""}
{"prompt":"-- The number of coefficients (i.e. different \"order\" terms) at a given degree, l\n-- 2*l + 1\nlocal function num_coeffs(l)\n  return 2*l + 1\nen","completion":""}
{"prompt":"-- Gets the url for a page containing shift information for specified game from NHL API.\n-- :param season: int, the season\n-- :param game: int, the game\n-- :return : str, http:\/\/www.nhl.com\/stats\/rest\/shiftcharts?cayenneExp=gameId=[season]0[game]\nlocal function get_shift_url(season, game)\n    return 'http:\/\/www.nhl.com\/stats\/rest\/shiftcharts?cayenneExp=gameId=' .. season .. '0' .. game\nen","completion":""}
{"prompt":"-- Convert NoneType to blank ('') string.\nlocal function xstr(s)\n  if s == nil then\n    return ''\n  else\n    return tostring(s)\n  end\nen","completion":""}
{"prompt":"-- Flatten a list of lists\nlocal function flatten(lol)\n  local flat = {}\n  for i = 1, #lol do\n    for j = 1, #lol[i] do\n      flat[#flat + 1] = lol[i][j]\n    end\n  end\n  return flat\nen","completion":""}
{"prompt":"-- Replaces all unescaped xml characters\nlocal function xml_escape(string)\n    string = string:gsub(\"&\", \"&amp;\")\n    string = string:gsub(\"<\", \"&lt;\")\n    string = string:gsub(\">\", \"&gt;\")\n    string = string:gsub(\"'\", \"&apos;\")\n    string = string:gsub(\"\\\"\", \"&quot;\")\n    return string\nen","completion":""}
{"prompt":"-- Given an expression expressed as Python lists, uses recursion to return\n-- the depth of the expression, where depth is defined by the maximum number of\n-- nested operations.\nlocal function expression_depth(expr)\n    local function depth(expr)\n        local expr_type = type(expr)\n        if expr_type == 'table' then\n            local op = expr[1]\n            local op_depth = 0\n            for _,v in ipairs(expr) do\n                if type(v) == 'table' then\n                    local v_depth = depth(v)\n                    op_depth = op_depth > v_depth and op_depth or v_depth\n                end\n            end\n            return op_depth + 1\n        else\n            return 0\n        end\n    end\n    return depth(expr)\nen","completion":""}
{"prompt":"-- From a given integer, return an string of length len_str_out completed by zero\n-- Example:\n-- ut.string(1,3)-->'001'\nlocal function string(integer, len_str_out)\n  local str = tostring(integer)\n  if len_str_out - #str < 0 then\n    return \"\"\n  end\n  local ret = \"\"\n  for i = 1, len_str_out - #str do\n    ret = ret .. \"0\"\n  end\n  return ret .. str\nen","completion":""}
{"prompt":"-- Return a list of the combine inbound and outbound links\nlocal function flatten_network(wiki_linked_pages)\n  local links = {}\n  for _, linked_pages in pairs(wiki_linked_pages) do\n    for _, linked_page in pairs(linked_pages) do\n      table.insert(links, linked_page)\n    end\n  end\n  return links\nen","completion":""}
{"prompt":"-- Property: Projection.ProjectionType\nlocal function projection_type_validator(x)\n   return x:match(\"^[a-zA-Z0-9\\\\s\\\\-_]+$\")\nen","completion":""}
{"prompt":"-- >>> get_game_id({'id1':{ 'numbers': ['#1', '#2']},'id2': { 'numbers': [\"#3\", \"#4\"]}}, '#1')\n-- 'id1'\n-- >>> get_game_id({'id1':{ 'numbers': ['#1', '#2']},'id2': { 'numbers': [\"#3\", \"#4\"]}}, '#4')\n-- 'id2'\n-- >>> get_game_id({'id1':{ 'numbers': ['#1', '#2']},'id2': { 'numbers': [\"#3\", \"#4\"]}}, '#5')\nlocal function get_game_id(data, texter_number)\n  for id, game in pairs(data) do\n    for i, number in pairs(game.numbers) do\n      if number == texter_number then\n        return id\n      end\n    end\n  end\nen","completion":""}
{"prompt":"-- given binomial probability (p,k,n) => p^k*(1-p)^(n-k),\n-- return binom_prob(p,k,n) \/ binom_prob(p,k0,n)\n-- note that n isn't actually needed! this is because we're calculating a\n-- per-configuration weight, and in a true binomial distribution we'd then\n-- multiply by (n choose k) configurations; however, we've effectively done\n-- that already with the enumeration\/tallying phase\nlocal function nondiscrete_relative_likelihood(p, k, k0)\n\treturn (p ^ k) * ((1-p) ^ (k0 - k)) \/ ((p ^ k0) * ((1-p) ^ (k0 - k0)))\nen","completion":""}
{"prompt":"-- Converts a number from an integer to an array of bits\nlocal function bits_to_array(num, output_size)\n    local bits = {}\n    for i = output_size, 1, -1 do\n        local power_of_2 = math.pow(2, i - 1)\n        local remainder = num % (power_of_2 * 2)\n        if remainder < power_of_2 then\n            bits[#bits+1] = 0\n        else\n            bits[#bits+1] = 1\n            num = num - power_of_2\n        end\n    end\n    return bits\nen","completion":""}
{"prompt":"-- Min max normalization\n-- Keyword arguments:\n-- value -- value\n-- min -- minimum\n-- max -- maximum\nlocal function normalize(value, min, max)\n    return (value - min) \/ (max - min)\nen","completion":""}
{"prompt":"-- Sanitize url.\n-- Converts address to valid HTTP url.\nlocal function url(address)\n    if address:find(\"^%w+:\/\/\") then\n        return address\n    else\n        return \"http:\/\/\" .. address\n    end\nen","completion":""}
{"prompt":"-- A function that takes an integer and\n-- calculates the sum of n's digits\nlocal function sum_of_digits(number)\n  local total = 0\n  while number > 0 do\n    total = total + number % 10\n    number = math.floor(number \/ 10)\n  end\n  return total\nen","completion":""}
{"prompt":"-- Call detect-secrets tool\n-- I think this is the problem:\n-- # Code expects to stream output to file and then expects\n-- # interactive person, so code hangs. But also hangs in git-bash\n-- detect-secrets scan test_data\/config.env > foo.txt\n-- detect-secrets audit foo.txt\nlocal function do_detect_secrets()\n   local ok, result = pcall(os.execute, \"detect-secrets scan test_data\/config.env > foo.txt\")\n   if ok then\n      local ok, result = pcall(os.execute, \"detect-secrets audit foo.txt\")\n      if ok then\n         if result ~= 0 then\n            os.exit(result)\n         end\n      else\n         print(\"Problem auditing secrets\")\n         os.exit(1)\n      end\n   else\n      print(\"Problem scanning secrets\")\n      os.exit(1)\n   end\nen","completion":""}
{"prompt":"-- Converting elapsed seconds from the beginning of a video to video time's string representation\n-- Arguments:\n-- seconds (int): Time for the beginning of a video.\n-- Examples:\n-- >>> convert_seconds_to_video_time_string(16)\n-- \"00:16\"\n-- >>> convert_seconds_to_video_time_string(210)\n-- \"03:30\"\n-- Returns:\n-- str: string representation of the video time\nlocal function convert_seconds_to_video_time_string(seconds)\n    if seconds <= 0 then\n        return \"00:00\"\n    end\n    return string.format(\"%02d:%02d\", math.floor(seconds \/ 60), seconds % 60)\nen","completion":""}
{"prompt":"-- Copied from _update_other_results in numpy\/core\/einsumfunc.py\n-- Update the positions and provisional input_sets of ``results`` based on\n-- performing the contraction result ``best``. Remove any involving the tensors\n-- contracted.\n-- Parameters\n-- ----------\n-- results : list\n-- List of contraction results produced by ``_parse_possible_contraction``.\n-- best : list\n-- The best contraction of ``results`` i.e. the one that will be performed.\n-- Returns\n-- -------\n-- mod_results : list\n-- The list of modifed results, updated with outcome of ``best`` contraction.  # NOQA\nlocal function _update_other_results(results, best)\n    local mod_results = {}\n    for r_i, result in ipairs(results) do\n        if result.indices ~= best.indices then\n            table.insert(mod_results, result)\n        end\n    end\n    return mod_results\nen","completion":""}
{"prompt":"-- As this tool is meant to be used in an enterprise setting, we assume\n-- that the email address of the committer uniquely identifies a given user.\n-- This function extracts that information.\nlocal function _extract_user_from_git_blame_info(info)\n  local email = info:match('<(.*)>')\n  return email and email:match('(.*)@')\nen","completion":""}
{"prompt":"-- Returns a modified url pointing to the high resolution version of\n-- the image\n-- >>> print(_get_high_res_img_url(\"https:\/\/images-na.ssl-images-amazon.com\/images\/I\/513gErH1dML._AC_SX236_SY340_FMwebp_QL65_.jpg\"))\n-- https:\/\/images-na.ssl-images-amazon.com\/images\/I\/513gErH1dML.jpg\n-- >>> print(_get_high_res_img_url(\"https:\/\/images-na.ssl-images-amazon.com\/images\/I\/51F48HFHq6L._AC_SX118_SY170_QL70_.jpg\"))\n-- https:\/\/images-na.ssl-images-amazon.com\/images\/I\/51F48HFHq6L.jpg\nlocal function _get_high_res_img_url(img_url)\n  if string.match(img_url, \"._AC_SX236_SY340_FMwebp_QL65_.jpg\") then\n    return string.gsub(img_url, \"._AC_SX236_SY340_FMwebp_QL65_.jpg\", \".jpg\")\n  elseif string.match(img_url, \"._AC_SX118_SY170_QL70_.jpg\") then\n    return string.gsub(img_url, \"._AC_SX118_SY170_QL70_.jpg\", \".jpg\")\n  else\n    return img_url\n  end\nen","completion":""}
{"prompt":"-- Calculate the square deviation between a given error value and a significance level\n-- if the deviation is positive (>0)\n-- Parameters\n-- ----------\n-- error : error\n-- sl : significance level\n-- Returns\n-- -------\n-- square deviation or 0\nlocal function calculate_pos_deviation_square(error, sl)\n    if error >= sl then\n        return (error - sl)^2\n    else\n        return 0\n    end\nen","completion":""}
{"prompt":"-- F-score\nlocal function f_score(p, r, beta)\n\tlocal b = beta or 1\n\treturn (1 + b^2) * (p * r) \/ ((b^2 * p) + r)\nen","completion":""}
{"prompt":"-- Remove newlines.\n-- The `name` field serves as a displayable title. We remove newlines and leading and trailing\n-- whitespace. We also collapse consecutive spaces to single spaces.\n-- :param text: Text for newline removal\n-- :return: Single line of text\n-- :rtype: str\nlocal function remove_newlines(text)\n\treturn (text:gsub(\"[%s\\n\\r]+\", \" \")):gsub(\"^%s*(.-)%s*$\", \"%1\")\nen","completion":""}
{"prompt":"-- Return HTML color '#hhhhhh' format string.\nlocal function rgbToHtmlColor(r, g, b)\n  return string.format('#%02X%02X%02X', r, g, b)\nen","completion":""}
{"prompt":"-- Caps the value at given minimum and maximum.\n-- Arguments:\n-- value {float} -- The value being capped.\n-- minimum {float} -- Smallest value.\n-- maximum {float} -- Largest value.\n-- Returns:\n-- float -- The capped value or the original value if within range.\nlocal function cap(value, minimum, maximum)\n\tif value < minimum then return minimum end\n\tif value > maximum then return maximum end\n\treturn value\nen","completion":""}
{"prompt":"-- Given a time series of values, sum the values\nlocal function total_value(metric)\n    local total = 0\n    for i=1,#metric do\n        total = total + metric[i]\n    end\n    return total\nen","completion":""}
{"prompt":"-- Return the input x if it is an int or float.\n-- Parameters\n-- ----------\n-- x : input argument\n-- Returns\n-- -------\n-- x : If it is of type int or float\n-- Examples\n-- --------\n-- >>> baz(0)\n-- 0\n-- >>> baz(0.0)\n-- 0.0\n-- >>> baz('a string')\n-- Traceback (most recent call last):\n-- ...\n-- ValueError: x must be int or float\nlocal function baz(x)\n    if type(x) ~= 'number' then\n        error(\"x must be int or float\", 2)\n    end\n    return x\nen","completion":""}
{"prompt":"-- Determines the number of tweets the api should call\n-- :param numLeft: Number of tweets remained to call\n-- :return: number of tweets the api should call\nlocal function amount_of_tweets(numLeft)\n    if numLeft < 200 then\n        return numLeft\n    else\n        return 200\n    end\nen","completion":""}
{"prompt":"-- Converts microseconds to milliseconds.\nlocal function to_ms(microseconds)\n  return microseconds \/ 1000\nen","completion":""}
{"prompt":"-- Extract a slice index from a PyInt or PyLong or an object with the\n-- nb_index slot defined, and store in *pi.\n-- Silently reduce values larger than PY_SSIZE_T_MAX to PY_SSIZE_T_MAX,\n-- and silently boost values less than -PY_SSIZE_T_MAX-1 to -PY_SSIZE_T_MAX-1.\n-- Return 0 on error, 1 on success.\n-- Note:  If v is NULL, return success without storing into *pi.  This\n-- is because_PyEval_SliceIndex() is called by apply_slice(), which can be\n-- called by the SLICE opcode with v and\/or w equal to NULL.\nlocal function _PyEval_SliceIndex(space, w_obj, pi)\n    if w_obj == nil then\n        return 1\n    end\n    local w_index = w_obj[1](w_obj, space)\n    local index = w_index[1]\n    if index == nil then\n        return 0\n    end\n    local int_index = tonumber(index)\n    if int_index ~= nil then\n        int_index = int_index + 0\n        pi[1] = int_index\n        return 1\n    end\n    if index.tp == 7 then\n        -- PyLong\n        int_index = index[1]:to_int()\n        pi[1] = int_index\n        return 1\n    end\n    return 0\nen","completion":""}
{"prompt":"-- Returns the value of a given variable between 0 and 360 degrees\n-- :param deg:\n-- :return: deg\nlocal function rev(deg)\n    return deg % 360\nen","completion":""}
{"prompt":"-- (string) -> string\n-- >>> even_odd('this is a test')\n-- ThIs iS A TeSt\nlocal function even_odd(text)\n    local even = true\n    local result = \"\"\n    for i = 1, #text do\n        if even then\n            result = result .. string.upper(string.sub(text, i, i))\n        else\n            result = result .. string.lower(string.sub(text, i, i))\n        end\n        even = not even\n    end\n    return result\nen","completion":""}
{"prompt":"-- Get zone name\nlocal function zone_name(zone)\n\treturn zone.name\nen","completion":""}
{"prompt":"-- Guesse the type of a value encoded in a string and parses\nlocal function autoparse(text)\n  if text == 'true' or text == 'false' then\n    return text == 'true'\n  elseif tonumber(text) ~= nil then\n    return tonumber(text)\n  else\n    return text\n  end\nen","completion":""}
{"prompt":"-- Ensures x is multiple elements. If x is not a list or a tuple,\n-- return a list containing it; otherwise return x\nlocal function multiple_elements(x)\n  if type(x) ~= 'table' then\n    return {x}\n  else\n    return x\n  end\nen","completion":""}
{"prompt":"-- Converts a cls ind to string name\nlocal function clsInd2Name(lbls, ind)\n  if type(ind) == \"number\" then\n    ind = ind + 1 -- labels start at 1 in .mat files\n  end\n  return lbls[ind]\nen","completion":""}
{"prompt":"-- Returns a string, which will be padded on the left with characters if necessary. If the input string is longer\n-- than the specified length, it will be returned unchanged.\n-- >>> left_pad('foo', 5)\n-- '  foo'\n-- >>> left_pad('foobar', 6)\n-- 'foobar'\n-- >>> left_pad('toolong', 2)\n-- 'toolong'\n-- >>> left_pad(1, 2, '0')\n-- '01'\n-- >>> left_pad(17, 5, 0)\n-- '00017'\n-- :param input: \n-- :param length: The return string's desired length.\n-- :param fill_character: \n-- :rtype str:\nlocal function left_pad(input, length, fill_character)\n    if type(input) ~= \"string\" then\n        input = tostring(input)\n    end\n    if length <= 0 then\n        return input\n    end\n    if fill_character == nil then\n        fill_character = ' '\n    end\n    return string.rep(fill_character, math.ceil(length - string.len(input))) .. input\nen","completion":""}
{"prompt":"-- Return the total fuel burned in at a cumulative rate.\nlocal function gauss_burn(units)\n  return (units + 1) * units \/ 2\nen","completion":""}
{"prompt":"-- In : S (string)\n-- Out: reverse of S (string)\n-- Example:\n-- srev('ab') -> 'ba'\nlocal function srev(S)\n    local s = \"\"\n    for i=#S,1,-1 do\n        s = s .. S:sub(i,i)\n    end\n    return s\nen","completion":""}
{"prompt":"-- >>> reverse_int(123)\n-- 321\n-- >>> reverse_int(685030)\n-- 30586\nlocal function reverse_int(num)\n  local reversed = 0\n  while num > 0 do\n    reversed = reversed * 10\n    reversed = reversed + num % 10\n    num = num \/\/ 10\n  end\n  return reversed\nen","completion":""}
{"prompt":"-- Given the arrival time of each student and a threshold number of attendees, determine if the class is canceled.\n-- :param k: int threshold for minimum on time student\n-- :param a: array of arrival time of students\n-- :return: Class cancel\nlocal function angryProfessor(k, a)\n    local onTime = 0\n    local i = 1\n    while i <= #a do\n        if a[i] <= 0 then\n            onTime = onTime + 1\n        end\n        i = i + 1\n    end\n    return onTime < k\nen","completion":""}
{"prompt":"-- Appends jpg to a number\nlocal function append_ext(id)\n\treturn id .. '.jpg'\nen","completion":""}
{"prompt":"-- Converts the list of key:value strings (example [\"mykey:myValue\", ...])\n-- into a list of AWS tag dicts (example: [{'Key': 'mykey', 'Value': 'myValue'}, ...]\nlocal function key_values_to_tags(dicts)\n  local tags = {}\n  for _, dict in ipairs(dicts) do\n    local key, value = dict:match(\"^(.-):(.*)$\")\n    table.insert(tags, { Key = key, Value = value })\n  end\n  return tags\nen","completion":""}
{"prompt":"-- Computes quaternion multiplication\n-- :param q: Quaternion\n-- :param r: Quaternion\n-- :return:\nlocal function quaternion_multiply(q, r)\n\treturn {\n\t\tq[1] * r[1] - q[2] * r[2] - q[3] * r[3] - q[4] * r[4],\n\t\tq[1] * r[2] + q[2] * r[1] + q[3] * r[4] - q[4] * r[3],\n\t\tq[1] * r[3] - q[2] * r[4] + q[3] * r[1] + q[4] * r[2],\n\t\tq[1] * r[4] + q[2] * r[3] - q[3] * r[2] + q[4] * r[1]\n\t}\nen","completion":""}
{"prompt":"-- perfrom text.replace(key, value) for all keys and values in dic\nlocal function replace_all(text, dic)\n    for key, value in pairs(dic) do\n        text = text:gsub(key, value)\n    end\n    return text\nen","completion":""}
{"prompt":"-- Calculate the ch4 concentration average between the historical ch4 and\n-- current ch4 concentrations\n-- Parameters\n-- ----------\n-- m_0 : float\n-- Historical ch4 concentration, in ppm\n-- m_curr : float\n-- Current ch4 concentration, in ppm\n-- Return\n-- ------\n-- m_bar : float\n-- Averaged concentration, in W m^-2 ppb^-1\nlocal function calc_mbar(m_0, m_curr)\n    -- The average concentration is equal to the sum of the current\n    -- concentration and the historical concentration, divided by two.\n    local m_bar = (m_curr + m_0) \/ 2\n    return m_bar\nen","completion":""}
{"prompt":"-- Double Factorial of integer. Also called $N!!$\nlocal function DoubleFactorial(n)\n    if n == 0 or n == 1 then\n        return 1\n    end\n    return n * DoubleFactorial(n - 2)\nen","completion":""}
{"prompt":"-- calcularpi(x)\n-- Aproximacion de pi usando el metodo de Leibniz con x terminos.\n-- Parameters\n-- ----------\n-- x: int\n-- Cantidad de terminos.\n-- Returns\n-- ----------\n-- output: float\n-- Aproximacion de pi\nlocal function calcularpi(x)\n\tlocal i=0\n\tlocal sumatoria=0\n\twhile i<x do\n\t\tsumatoria=sumatoria+(-1)^i*(1\/(2*i+1))\n\t\ti=i+1\n\tend\n\treturn sumatoria*4\nen","completion":""}
{"prompt":"-- Returns the full name (ex. <a-user>\/optee_os) of the Git project.\nlocal function pr_full_name_committer(payload)\n  if payload.pull_request then\n    local full_name = payload.pull_request.head.repo.full_name\n    local sha = payload.pull_request.head.sha\n    return full_name, sha\n  elseif payload.repository then\n    local full_name = payload.repository.full_name\n    local sha = payload.after\n    return full_name, sha\n  end\nen","completion":""}
{"prompt":"-- remove numbers\nlocal function remove_number(words)\n    local new_words = {}\n    for _, word in ipairs(words) do\n        if not tonumber(word) then\n            new_words[#new_words + 1] = word\n        end\n    end\n    return new_words\nen","completion":""}
{"prompt":"-- Returns the slope of the edge\nlocal function slope(edge)\n\tlocal x1, y1 = edge[1][1], edge[1][2]\n\tlocal x2, y2 = edge[2][1], edge[2][2]\n\treturn (y2 - y1) \/ (x2 - x1)\nen","completion":""}
{"prompt":"-- The PEP number as a 4-digit string.\n-- This is the format used by the URLs on python.org.\nlocal function _format_pep_number(pep_number)\n    pep_number = tostring(pep_number)\n    if #pep_number < 4 then\n        local zeros = string.rep(\"0\", 4 - #pep_number)\n        pep_number = zeros .. pep_number\n    end\n    return pep_number\nen","completion":""}
{"prompt":"-- Zernike primary Spherical.\nlocal function primary_spherical(rho, phi)\n   local m, n = 0, 0\n   return n + 1, m + 1\nen","completion":""}
{"prompt":"-- Convert a hex string into a human-readable string.\n-- XRPL uses hex strings as inputs in fields like `domain`\n-- in the `AccountSet` transaction.\n-- Args:\n-- input: hex-encoded string to convert\n-- Returns:\n-- Input encoded as a human-readable string.\nlocal function hex_to_str(input)\n\treturn (input:gsub('..', function (cc)\n\t\treturn string.char(tonumber(cc, 16))\n\tend))\nen","completion":""}
{"prompt":"-- Return the minimum value in sublist of list.\nlocal function find_min(data)\n\tlocal min = nil\n\tfor _, sublist in pairs(data) do\n\t\tfor _, value in pairs(sublist) do\n\t\t\tif (min == nil) or (min > value) then\n\t\t\t\tmin = value\n\t\t\tend\n\t\tend\n\tend\n\treturn min\nen","completion":""}
{"prompt":"-- 0-aware add, to prevent computation graph from getting very large\nlocal function smart_add(x, y)\n    if (x ~= nil and x ~= 0) then\n        return y + x\n    else\n        return y\n    end\nen","completion":""}
{"prompt":"-- Convert a right ascension in hours, min, seconds to degrees \n-- st  = Right ascension as \"hh mm ss.ss\".\nlocal function PHMS2RA(st)\n\t-- RA in hours, min, seconds.\n\tlocal hr, min, sec = st:match(\"(%d+) (%d+) (%d+%.%d+)\")\n\tif hr and min and sec then\n\t\treturn 15 * (hr + min\/60 + sec\/3600)\n\telse\n\t\t-- RA in degrees, minutes.\n\t\tlocal ra = st:match(\"(%d+) (%d+)\")\n\t\tif ra then\n\t\t\treturn tonumber(ra) \/ 15\n\t\tend\n\tend\nen","completion":""}
{"prompt":"-- Integer slide number from filename\n-- Assumes \/path\/to\/Slidefile\/somekindofSlide36.something\nlocal function slide_number_from_xml_file(filename)\n  local slide_number = filename:match(\"%d+\")\n  if slide_number then\n    return tonumber(slide_number)\n  end\n  return 0\nen","completion":""}
{"prompt":"-- Inverse to bipolar().\n-- Converts a bipolar signal to an unipolar signal.\nlocal function unipolar(signal)\n  return (signal + 1) \/ 2\nen","completion":""}
{"prompt":"-- Calculates amount of whitespaces leading the given string and returns int\nlocal function get_depth(string)\n\tlocal depth = 0\n\tfor char in string:gmatch(\".\") do\n\t\tif char == \" \" then\n\t\t\tdepth = depth + 1\n\t\telse\n\t\t\treturn depth\n\t\tend\n\tend\n\treturn depth\nen","completion":""}
{"prompt":"-- Do the roots\nlocal function root(num, pow)\n\treturn num^(1\/pow)\nen","completion":""}
{"prompt":"-- >>> recur_luc(1)\n-- 1\n-- >>> recur_luc(0)\n-- 2\nlocal function recur_luc(n)\n    if n == 1 then\n        return 1\n    elseif n == 0 then\n        return 2\n    end\n    return recur_luc(n - 1) + recur_luc(n - 2)\nen","completion":""}
{"prompt":"-- neighbourhood function that is constant within r\nlocal function nh_const(dist, r)\n    if dist > r then\n        return 0\n    else\n        return 1\n    end\nen","completion":""}
{"prompt":"-- Get the correct order parameter value for the table heading link\nlocal function table_get_link_order(column, order_key, order)\n  if column == order_key and order == 'desc' then\n    return 'asc'\n  else\n    return 'desc'\n  end\nen","completion":""}
{"prompt":"-- Returns protocol name for the given identifier.\n-- :param protocol_identifier: Number representing the protocol.\n-- :return: string \"tcp\" if protocol_identifier is 6, \"udp\" if protocol_identifier is 17, and \"other\" otherwise\nlocal function get_protocol_name(protocol_identifier)\n    if protocol_identifier == 6 then\n        return \"tcp\"\n    elseif protocol_identifier == 17 then\n        return \"udp\"\n    else\n        return \"other\"\n    end\nen","completion":""}
{"prompt":"-- Find the difference between 2 numbers.\n-- :type num1: number\n-- :param num1: The first number to use.\n-- :type num2: number\n-- :param num2: The second number to use.\n-- >>> difference(1, 4)\n-- 3\nlocal function difference(num1, num2)\n    return math.abs(num1 - num2)\nen","completion":""}
{"prompt":"-- Converts a numeric value to hex (pointer to hex)\n-- Arguments:\n-- n - the value to convert\n-- Return:\n-- A string, representing the value in hex (8 characters long)\nlocal function toHex(n)\n    return string.format(\"%08x\", n)\nen","completion":""}
{"prompt":"-- returns a list with prime factors\nlocal function factorization(integer)\n\tlocal factors = {}\n\tlocal i = 2\n\twhile i <= integer do\n\t\tif integer % i == 0 then\n\t\t\tinteger = integer \/ i\n\t\t\ttable.insert(factors, i)\n\t\telse\n\t\t\ti = i + 1\n\t\tend\n\tend\n\treturn factors\nen","completion":""}
{"prompt":"-- run tests with codecov\nlocal function task_run_tests_with_codecov()\n   local command = \"bash -c \\\"source .ci\/env-variables.sh && .\/gradlew jacocoTestReport\\\"\"\n   local exit_code = os.execute(command)\n   if exit_code ~= 0 then\n      print(\"Test failed\")\n      os.exit(exit_code)\n   end\nen","completion":""}
{"prompt":"-- \"Returns the middle point of the interval [low, high].\nlocal function compute_middle(low, high)\n  return low + 0.5 * (high - low)\nen","completion":""}
{"prompt":"-- Returns the length (number of letters) in the current hand.\n-- hand: dictionary (string-> int)\n-- returns: integer\nlocal function calculateHandlen(hand)\n  local length = 0\n  for k,v in pairs(hand) do\n    length = length + v\n  end\n  return length\nen","completion":""}
{"prompt":"-- A single step in the series expansion\nlocal function expand(step, num_steps)\n\tif step == 0 then\n\t\treturn 1, 1\n\tend\n\tlocal a, b = 1, 1\n\tfor i = 1, step do\n\t\ta, b = b, a + b\n\tend\n\treturn a, b \/ a * num_steps\nen","completion":""}
{"prompt":"-- The Lorenz equations.\nlocal function deriv_rossler(X, t, a, b, c)\n  local u, v, w = X[1], X[2], X[3]\n  return {u - v, v * (a - w), u * w - b}\nen","completion":""}
{"prompt":"-- Return diagonal line of a list of list representation of a matrix\nlocal function diag_line(matrix)\n    local diagonal = {}\n    for i = 1, #matrix do\n        table.insert(diagonal, matrix[i][i])\n    end\n    return diagonal\nen","completion":""}
{"prompt":"-- This functions returns the filename for the given configuration N_1, N_2.\nlocal function configurationString(N_1, N_2)\n   if N_1 == N_2 then\n      return N_1 .. \"x\" .. N_2\n   elseif N_1 > N_2 then\n      return N_1 .. \"x\" .. N_2\n   else\n      return N_2 .. \"x\" .. N_1\n   end\nen","completion":""}
{"prompt":"-- Reverse string using the \"reversed\" function.\nlocal function reverse_builtin(value)\n\treturn string.reverse(value)\nen","completion":""}
{"prompt":"-- Returns a string where the characters in text are shifted left n number of\n-- spaces. The characters in text are only decrypted if they exist in p. If\n-- they don't exist in p, they will remain unchanged.\n-- Ex.  str = 'def45'\n-- n = 3\n-- returns - 'abc12'\n-- Notes:\n-- Currently p can be string.ascii_lowercase or string.printable characters.\n-- The only whitespace string.printable will use is \" \". (one space only, no\n-- newline, tabs, etc.)\n-- str.maketrans returns a translation table that replaces items in p with\n-- items in p[-n:] + p[:-n], which is just the string p shifted to the left n\n-- units.\n-- my_str.translate(lookup_table) returns a copy of my_str using the lookup\n-- table.\nlocal function caesar_cipher_decode(n, text, p)\n    -- You code goes here\n    local result = \"\"\n    for i=1, #text do\n        local idx = string.find(p, string.sub(text,i,i))\n        if idx ~= nil then\n            idx = idx + n\n            if idx > #p then\n                idx = idx - #p\n            end\n            result = result .. p:sub(idx, idx)\n        else\n            result = result .. text:sub(i,i)\n        end\n    end\n    return result\nen","completion":""}
{"prompt":"-- Wrap html with the necessary html to make horizontal scrolling possible.\n-- Examples\n-- ________\n-- display(HTML(utils.horizontal_scrollable_div(my_html)))\n-- Parameters\n-- ----------\n-- html: str\n-- Your HTML to wrap.\n-- Returns\n-- -------\n-- type\n-- Wrapped HTML.\nlocal function horizontal_scrollable_div(html)\n    return [[<div style=\"overflow-x: auto; width: 100%; white-space: nowrap;\">]] .. html .. [[<\/div>]]\nen","completion":""}
{"prompt":"-- Add <w> markers to ensure word-boundary alignment.\nlocal function space_tokenize_with_bow(sentence)\n  -- Tokenize sentence into words.\n  local words = {}\n  for word in string.gmatch(sentence, \"[^%s]+\") do\n    table.insert(words, word)\n  end\n  -- Add <w> markers for words.\n  local result = {}\n  for i = 1, #words do\n    table.insert(result, \"<w>\" .. words[i])\n  end\n  return result\nen","completion":""}
{"prompt":"-- Escape linefeeds.\n-- To make templates work with both YAML and JSON, escape linefeeds instead of\n-- allowing Jinja to render them.\nlocal function preserve_linefeeds(value)\n  return value:gsub('\\n', '\\\\n')\nen","completion":""}
{"prompt":"-- Scattering timescale in seconds at f in MHz. t_G is the timescale at \n-- 1GHz, in seconds.\nlocal function t_scat(t_G, f)\n\treturn t_G * f \/ 1000\nen","completion":""}
{"prompt":"-- Follows the 'orig' attribute until it comes to an object without that attribute.\nlocal function get_orig(term)\n  if type(term) == 'table' and term.orig then\n    return get_orig(term.orig)\n  end\n  return term\nen","completion":""}
{"prompt":"-- Returns the name from a wsadmin object id string.\n-- For example, returns PAP_1 from the following id:\n-- PAP_1(cells\/ding6Cell01|coregroupbridge.xml#PeerAccessPoint_1157676511879)\n-- Returns the original id string if a left parenthesis is not found.\nlocal function getNameFromId(obj_id)\n    local index = string.find(obj_id, \"%(\")\n    if index ~= nil then\n        return string.sub(obj_id, 1, index - 1)\n    end\n    return obj_id\nen","completion":""}
{"prompt":"-- Exponentiation by squaring\n-- :return: n ** k\nlocal function pow_mod(n, k, mod)\n  if (k == 0) then\n    return 1\n  elseif (k == 1) then\n    return n\n  elseif (k % 2 == 0) then\n    return pow_mod(n * n % mod, k \/ 2, mod)\n  elseif (k % 2 == 1) then\n    return n * pow_mod(n * n % mod, (k - 1) \/ 2, mod) % mod\n  end\nen","completion":""}
{"prompt":"-- Runs through a collection of x,y tuple pairs and \n-- extracts the values (xmin,ymin),(xmax,ymax).\nlocal function bounding_box2D(coords)\n  local xmin = math.huge\n  local ymin = math.huge\n  local xmax = -math.huge\n  local ymax = -math.huge\n  for i,v in ipairs(coords) do\n    xmin = math.min(xmin, v[1])\n    ymin = math.min(ymin, v[2])\n    xmax = math.max(xmax, v[1])\n    ymax = math.max(ymax, v[2])\n  end\n  return { {xmin, ymin}, {xmax, ymax} }\nen","completion":""}
{"prompt":"-- Return the contents of *command* appearing before #.\nlocal function remove_comment(command)\n    return (command:match(\"^%s*(.-)%s*#.-$\") or command):gsub(\"^%s*(.-)%s*$\", \"%1\")\nen","completion":""}
{"prompt":"-- Good bye message for user\nlocal function good_bye()\n\tprint(\"Good bye! Thanks for using this program\")\n\tos.exit()\nen","completion":""}
{"prompt":"-- Returns 1 for positive sentiment, 0 otherwise\nlocal function determine_sentiment(delta)\n  return delta > 0 and 1 or 0\nen","completion":""}
{"prompt":"-- A self-recursive function to obtain the final fibonacci result.\n-- :type n: int\n-- :rtype: int\nlocal function get_fibonacci(n)\n    if n <= 1 then\n        return n\n    end\n    return get_fibonacci(n-2) + get_fibonacci(n-1)\nen","completion":""}
{"prompt":"-- :param x:\n-- :return:\nlocal function mySqrt3(x)\n  if x == 0 then\n    return 0\n  end\n  local left, right = 1, x\n  while left <= right do\n    local mid = left + ((right - left) >> 1)\n    if mid * mid == x then\n      return mid\n    elseif mid * mid > x then\n      right = mid - 1\n    else\n      left = mid + 1\n    end\n  end\n  return right\nen","completion":""}
{"prompt":"-- >>> factorial_recursive(3)\n-- 6\n-- >>> factorial_recursive(5)\n-- 120\n-- >>> factorial_recursive(0)\n-- 1\n-- >>> factorial_recursive(1)\n-- 1\nlocal function factorial_recursive(n)\n  if n == 0 then\n    return 1\n  else\n    return n * factorial_recursive(n - 1)\n  end\nen","completion":""}
{"prompt":"-- Convert SQLAlchemy proxy result object to list of dictionary.\nlocal function proxy_result_as_dict(obj)\n    local ret = {}\n    for i, v in pairs(obj) do\n        ret[i] = v\n    end\n    return ret\nen","completion":""}
{"prompt":"-- \"Conversion of MW to GWh\n-- Arguments\n-- ---------\n-- kwh : float\n-- Kilowatthours\n-- Return\n-- ------\n-- gwh : float\n-- Gigawatthours\nlocal function kwh_to_gwh(kwh)\n  if kwh then\n    return kwh \/ 1e6\n  end\n  return nil\nen","completion":""}
{"prompt":"-- Computes the Akaike Information Criterion: 2k-2ln(L),\n-- where k is the number of estimated parameters in the model and LnL is the \n-- max ln-likelihood for the model.\nlocal function akaike(LnL, k)\n   local result = 2*k - 2*LnL\n   return result\nen","completion":""}
{"prompt":"-- Replace spaces in input_string with '%20', without using the\n-- replace() method of Python str objects, and must be done in-place.\n-- List slicing in Python is O(k), where k is the slice size, so this solution\n-- could be more optimal.\n-- Parameters\n-- ----------\n-- input_string : str\n-- String to process\n-- Returns\n-- -------\n-- str\n-- input_string, with spaces replaces by '%20'\nlocal function URLify(input_string)\n\tfor i = #input_string, 1, -1 do\n\t\tif input_string:sub(i, i) == ' ' then\n\t\t\tinput_string = input_string:sub(1, i - 1) .. '%20' .. input_string:sub(i + 1, #input_string)\n\t\tend\n\tend\n\treturn input_string\nen","completion":""}
{"prompt":"-- Cubic objective function.\nlocal function cubic_objective(x, a, b, c, d)\n    return a*x^3 + b*x^2 + c*x + d\nen","completion":""}
{"prompt":"-- Reverse the input string\n-- Args:\n-- our_string(string): String to be reversed\n-- Returns:\n-- string: The reversed string\nlocal function string_reverser(our_string)\n  return string.reverse(our_string)\nen","completion":""}
{"prompt":"-- I(x) is the initial condition, meaning t=0\n-- x is a variable in space\n-- A is the amplitude\n-- s is the intersection\n-- L is the length\n-- To form a \"triangle-shaped\" initial condition we\n-- return the value I(x) of the 1st linear function in the equation set for x less than s\n-- return the value I(x) of the 2nd linear function in the equation set for x larger than s\nlocal function I(x, A, s, L)\n    local result\n    if x <= s then\n        result = A * (x \/ s)\n    else\n        result = A * ((L - x) \/ (L - s))\n    end\n    return result\nen","completion":""}
{"prompt":"-- For spawning processes using os.spawnv() to call Python, the options\n-- between double quotes (\") must be put into just one element of the\n-- list. Turn the 'cmd' string into a list and consolidate all options\n-- between double quotes into one element.\n-- Currently not used, but kept in case it might be needed.\nlocal function JoinOptionsList(cmd)\n  local cmdlist = {}\n  local quoted = false\n  for w in string.gmatch(cmd, \"%S+\") do\n    if quoted then\n      cmdlist[#cmdlist] = cmdlist[#cmdlist] .. \" \" .. w\n      if w:find(\"\\\"\") then\n        quoted = false\n      end\n    elseif w:find(\"\\\"\") then\n      cmdlist[#cmdlist + 1] = w\n      quoted = true\n    else\n      cmdlist[#cmdlist + 1] = w\n    end\n  end\n  return cmdlist\nen","completion":""}
{"prompt":"-- >>> 0.7 * 0.2\n-- 0.13999999999999999\n-- >>> -0.7 * 0.2\n-- -0.13999999999999999\n-- >>> nano_mul(0.7, 0.2)\n-- 0.14\n-- >>> nano_mul(-0.7, 0.2)\n-- -0.14\n-- :param x:\n-- :param y:\n-- :return:\nlocal function nano_mul(x, y)\n    return math.floor((x * y) * 100 + 0.5) \/ 100\nen","completion":""}
{"prompt":"-- Helper function for read_bitpacked to generage a mask to grab i bits.\nlocal function _mask_for_bits(i)\n    return 2^(i)-1\nen","completion":""}
{"prompt":"-- how much does the range (start1, end1) overlap with (start2, end2)\n-- Looks strange, but algorithm is tight and tested.\n-- Args:\n-- start1: start of interval 1, in any unit\n-- end1: end of interval 1\n-- start2: start of interval 2\n-- end2: end of interval 2\n-- Returns:\n-- overlap of intervals in same units as supplied.\nlocal function overlap(start1, end1, start2, end2)\n  return math.max(0, math.min(end1, end2) - math.max(start1, start2))\nen","completion":""}
{"prompt":"-- Return the distance between two longitude values as an angular measure.\n-- Parameters represent two longitude values in degrees.\n-- :return:\n-- Float, the angle between ``lon1`` and ``lon2`` in degrees. Value\n-- is positive if ``lon2`` is on the east from ``lon1`` and negative\n-- otherwise. Absolute value of the result doesn't exceed 180 for\n-- valid parameters values.\nlocal function get_longitudinal_extent(lon1, lon2)\n  local result = math.fmod(lon2 - lon1, 360)\n  if result >= 180 then\n    result = result - 360\n  elseif result <= -180 then\n    result = result + 360\n  end\n  return result\nen","completion":""}
{"prompt":"-- Returns the ASCII decoded version of the given HTML string. This does\n-- NOT remove normal HTML tags like <p>.\nlocal function html_decode(s)\n  s = string.gsub(s, \"&amp;\", \"&\")\n  s = string.gsub(s, \"&lt;\", \"<\")\n  s = string.gsub(s, \"&gt;\", \">\")\n  s = string.gsub(s, \"&quot;\", '\"')\n  s = string.gsub(s, \"&#(%d+);\", function (n) return string.char(n) end)\n  return s\nen","completion":""}
{"prompt":"-- :type n: int\n-- :rtype: int\nlocal function arrangeCoins(n)\n    local i = 0\n    while n > i do\n        i = i + 1\n        n = n - i\n    end\n    return i\nen","completion":""}
{"prompt":"-- Flattens an iterable of iterables by one level\n-- Examples\n-- --------\n-- >>> flatten([[1,2,3,4],[5,6,7,8],[9,10]])\n-- [1,2,3,4,5,6,7,8,9,10]\nlocal function flatten(l)\n    local newl = {}\n    for _, v in pairs(l) do\n        if type(v) == \"table\" then\n            for _, v2 in pairs(v) do\n                table.insert(newl, v2)\n            end\n        else\n            table.insert(newl, v)\n        end\n    end\n    return newl\nen","completion":""}
{"prompt":"-- Takes a list of key ids, and converts them to the 'short' format,\n-- by reducing them to their last 8 characters.\nlocal function shorten_key_ids(key_id_list)\n    local shortened_key_id_list = {}\n    for _, key_id in ipairs(key_id_list) do\n        shortened_key_id_list[#shortened_key_id_list + 1] = string.sub(key_id, -8)\n    end\n    return shortened_key_id_list\nen","completion":""}
{"prompt":"-- Move left\nlocal function left(pos)\n  return {pos[1] - 1, pos[2]}\nen","completion":""}
{"prompt":"-- Cosine learning rate with warm up.\nlocal function fun_lr(lr, total_iters, warmup_total_iters, warmup_lr_start, iters)\n    local lr_scale = math.min(1.0, iters \/ warmup_total_iters)\n    return lr * lr_scale\nen","completion":""}
{"prompt":"-- Number of reconstructed points visible on each image.\n-- Returns:\n-- A list of (image, num_point) pairs sorted by decreasing number\n-- of points.\nlocal function reconstructed_points_for_images(graph, reconstruction, images)\n  local image_to_num_point = {}\n  for i, image in ipairs(images) do\n    local num_point = 0\n    for _ = 1, #graph[image].images do\n      num_point = num_point + #graph[image].images[i].points\n    end\n    image_to_num_point[image] = num_point\n  end\n  local image_to_num_point_sorted = {}\n  for image, num_point in pairs(image_to_num_point) do\n    table.insert(image_to_num_point_sorted, {image = image, num_point = num_point})\n  end\n  table.sort(image_to_num_point_sorted, function(a, b)\n    return a.num_point > b.num_point\n  end)\n  return image_to_num_point_sorted\nen","completion":""}
{"prompt":"-- Iteratively finds the result of the expression (base**exp) mod n\nlocal function fast_exponentiation(base, exp, n)\n  if (exp == 0) then\n    return 1\n  elseif (exp % 2 == 0) then\n    local res = fast_exponentiation(base, exp \/ 2, n)\n    return res * res % n\n  else\n    local res = fast_exponentiation(base, exp - 1, n)\n    return res * base % n\n  end\nen","completion":""}
{"prompt":"-- Produces a string from an integer's binary representation.\n-- (preceding zeros removed).\nlocal function asBinary(i)\n\tif i > 2147483647 or i < -2147483648 then\n\t\terror(\"Number out of bounds.\", 2)\n\tend\n\tlocal binary = \"\"\n\tlocal rem\n\trepeat\n\t\ti, rem = math.floor(i\/2), i%2\n\t\tbinary = rem..binary\n\tuntil i == 0\n\treturn binary\nen","completion":""}
{"prompt":"-- >>> validateDSType('counter')\n-- 'COUNTER'\n-- >>> validateDSType('ford prefect')\n-- Traceback (most recent call last):\n-- ValueError: A data source type must be one of the following: GAUGE COUNTER DERIVE ABSOLUTE COMPUTE\nlocal function validateDSType(dsType)\n  local lowerDSType = string.lower(dsType)\n  if lowerDSType == 'gauge' then\n    return 'GAUGE'\n  elseif lowerDSType == 'counter' then\n    return 'COUNTER'\n  elseif lowerDSType == 'derive' then\n    return 'DERIVE'\n  elseif lowerDSType == 'absolute' then\n    return 'ABSOLUTE'\n  elseif lowerDSType == 'compute' then\n    return 'COMPUTE'\n  else\n    error('A data source type must be one of the following: GAUGE COUNTER DERIVE ABSOLUTE COMPUTE')\n  end\nen","completion":""}
{"prompt":"-- Calculates the moments of a gamma distribution based on mean and sd\n-- as they are more intuitive inputs\n-- More info on gamma: https:\/\/en.wikipedia.org\/wiki\/Gamma_distribution\n-- Inputs:\n-- mean - a float - the chosen mean of the distribution\n-- sd - a float - the chosen standard deviation of the distribution\n-- Returns:\n-- dict - keys: shape and scale, values of corresponding moments\nlocal function gamma_moments(mean, sd)\n    -- calculate the shape and scale parameters\n    local scale = math.pow(sd, 2) \/ mean\n    local shape = mean \/ scale\n    return {shape = shape, scale = scale}\nen","completion":""}
{"prompt":"-- Calculate the sum of a number's digits\nlocal function sum_digit(number)\n    local result = 0\n    local length = string.len(number)\n    for i = 1, length do\n        result = result + tonumber(string.sub(number, i, i))\n    end\n    return result\nen","completion":""}
{"prompt":"-- sumOfSquares\n-- Output the sum of the first n positive integers, where \n-- n is provided by the user.\n-- passes:\n-- n:\n-- Output the sum of the first n positive integers, where \n-- n is provided by the user.\n-- returns:\n-- Returns an array of the sum of the nth squared integers.\nlocal function sumOfSquares(n)\n  -- n:\n  -- Returns an array of the sum of the nth squared integers.\n  local arr = {}\n  -- for i=1, n do\n  for i=1, tonumber(n) do\n    -- arr[#arr + 1] = (i ^ 2)\n    arr[#arr + 1] = tonumber(i) ^ 2\n  end\n  return arr\nen","completion":""}
{"prompt":"-- squared distance between two points in a 2d periodic structure\nlocal function sq_distance_mod(x0, y0, x1, y1, x_period, y_period)\n\tlocal dx = x1 - x0\n\tlocal dy = y1 - y0\n\tdx = dx - x_period * math.floor((dx + x_period \/ 2) \/ x_period)\n\tdy = dy - y_period * math.floor((dy + y_period \/ 2) \/ y_period)\n\treturn dx * dx + dy * dy\nen","completion":""}
{"prompt":"-- 'clamping' is fixing a value within a range\nlocal function _clamp(value, low_bound, high_bound)\n    return math.max(low_bound, math.min(high_bound, value))\nen","completion":""}
{"prompt":"-- Watermelon nutrition info.\n-- Contains nutrition facts of a serving of watermelon.\n-- Returns:\n-- Prints a series of strings containing the nutrition facts of a serving of watermelon.\nlocal function nutrition()\n  print(\"Serving size: 1\/3 cup\")\n  print(\"Calories: 230\")\n  print(\"Total fat: 21.9g\")\n  print(\"Cholesterol: 18mg\")\n  print(\"Sodium: 10mg\")\n  print(\"Carbohydrate: 34.4g\")\n  print(\"Fiber: 1.2g\")\n  print(\"Sugars: 1.9g\")\n  print(\"Protein: 5.9g\")\n  print(\"---------------------------------------------\")\n  print(\"TOTAL: 103.9g\")\nen","completion":""}
{"prompt":"-- (1,0)  -> k=1&tau=0 -> (1,0)\n-- A convention for packing 2-tuple into something hashable and json'able\nlocal function k_and_tau_to_horizon_str(k, tau)\n    return (\"k=%s&tau=%s\"):format(k, tau)\nen","completion":""}
{"prompt":"-- Return overlap between two intervals\n-- >>> getOverlap( [0,2], [0,1])    \n-- 1\nlocal function getOverlap(a, b)\n  return math.max(0, math.min(b[2], a[2]) - math.max(a[1], b[1]))\nen","completion":""}
{"prompt":"-- Given a matrix [square list of lists], return sum of diagonals.\n-- Sum of TL-to-BR diagonal along with BL-to-TR diagonal:\n-- >>> m1 = [\n-- ...     [1,   2],\n-- ...     [30, 40],\n-- ... ]\n-- >>> sum_up_diagonals(m1)\n-- 73\n-- >>> m2 = [\n-- ...    [1, 2, 3],\n-- ...    [4, 5, 6],\n-- ...    [7, 8, 9],\n-- ... ]\n-- >>> sum_up_diagonals(m2)\n-- 30\nlocal function sum_up_diagonals(matrix)\n    local rows = #matrix\n    local cols = #matrix[1]\n    local top_left_diag = 0\n    local bottom_left_diag = 0\n    for row = 1, rows do\n        top_left_diag = top_left_diag + matrix[row][row]\n        bottom_left_diag = bottom_left_diag + matrix[row][cols - row + 1]\n    end\n    return top_left_diag + bottom_left_diag\nen","completion":""}
{"prompt":"-- Takes the different formats of options containing multiple values and\n-- returns the value as a list object.\nlocal function normalize_to_list(value)\n    if type(value) == \"table\" then\n        return value\n    elseif type(value) == \"string\" then\n        local result = {}\n        for i in string.gmatch(value, \"([^,]+)\") do\n            result[#result + 1] = i\n        end\n        return result\n    else\n        return {value}\n    end\nen","completion":""}
{"prompt":"-- Returns a string with an uppercase letter and a modifier.\n-- The modifier indicates how many times around the alphabet the index has\n-- gone, e.g. for index = 27, the string is A'.\nlocal function rhyme_designator(index)\n    local letter = string.char(string.byte('A') + index % 26)\n    local modifier = (math.floor(index \/ 26) == 0) and \"\" or string.format(\"%d\", math.floor(index \/ 26))\n    return letter .. modifier\nen","completion":""}
{"prompt":"-- Compute max of a pair of two ints.\nlocal function max_value(a, b)\n    if a > b then\n        return a\n    else\n        return b\n    end\nen","completion":""}
{"prompt":"-- Reverse a normalization. Requires the original mean and\n-- standard deviation of the data set.\nlocal function unnormalize(X, mean, std)\n    return (X - mean) \/ std\nen","completion":""}
{"prompt":"-- Easing function for animations: Cubic Ease In\nlocal function cubic_easein(pos)\n\treturn pos*pos*pos\nen","completion":""}
{"prompt":"-- Convert matplotlib canvas coordinate to pixels\nlocal function canvas2px(coord, dmn, dpi)\n    return math.floor(coord*dmn*dpi)\nen","completion":""}
{"prompt":"-- This returns the length of the hypotenuse when the lengths of other\n-- two sides is given of a right angled triangle\nlocal function hypothenuse(perpendicular, base)\n  return (perpendicular^2 + base^2)^0.5\nen","completion":""}
{"prompt":"-- Return average weighted by `lr` of `value` and `target`\nlocal function gradient_update(value, lr, target)\n    return value + lr * (target - value)\nen","completion":""}
{"prompt":"-- takes in predicted values and actual values, returns elementwise squared error\n-- via (x-y)^2\nlocal function ese(pred, target)\n    return (pred - target)^2\nen","completion":""}
{"prompt":"-- F(0) = 1\n-- F(1) = 1\n-- F(n) = F(n-1) + F(n-2)\n-- :param n:\n-- :return:\nlocal function recursive_fibonacci(n)\n    if n == 1 or n == 0 then\n        return 1\n    end\n    return recursive_fibonacci(n-1) + recursive_fibonacci(n-2)\nen","completion":""}
{"prompt":"-- Return true if n has two eights in a row.\n-- >>> double_eights(8)\n-- False\n-- >>> double_eights(88)\n-- True\n-- >>> double_eights(2882)\n-- True\n-- >>> double_eights(880088)\n-- True\n-- >>> double_eights(12345)\n-- False\n-- >>> double_eights(80808080)\n-- False\nlocal function double_eights(n)\n    return string.match(tostring(n), '88') and true or false\nen","completion":""}
{"prompt":"-- Take a user provided username and \"normalize it\" (take out spaces, quotes, etc).\n-- This is not a security measure, it's more for interoperability with, eg. command\n-- line tools.\nlocal function sanitize_username(uname)\n    local res = uname:gsub(\"[\\\" ']+\", \"\")\n    if #res > 0 and res:sub(1,1) == \"+\" then\n        res = res:sub(2)\n    end\n    return res\nen","completion":""}
{"prompt":"-- Returns the dns servers configured in \/etc\/resolv.conf\nlocal function get_resolv_dns()\n    local f = io.open(\"\/etc\/resolv.conf\")\n    local dns = {}\n    if f then\n        local s = f:read()\n        for srv in s:gmatch(\"nameserver ([^ ]+)\") do\n            dns[#dns + 1] = srv\n        end\n    end\n    return dns\nen","completion":""}
{"prompt":"-- Compute (a pow b) % q, alternative shorter implementation\n-- :param int a b: non negative\n-- :param int q: positive\n-- :complexity: O(log b)\nlocal function fast_exponentiation(a, b, q)\n  local r = 1\n  while b > 0 do\n    if b % 2 == 1 then r = (r * a) % q end\n    a = (a * a) % q\n    b = b \/\/ 2\n  end\n  return r\nen","completion":""}
{"prompt":"-- Return 3n+1 for a given number.\nlocal function collatz_odd(number)\n\tif number < 1 then\n\t\treturn 0\n\tend\n\treturn number * 3 + 1\nen","completion":""}
{"prompt":"-- Given a 3 column interval, return the length of the interval\nlocal function interval_len(aInterval)\n  return aInterval[3] - aInterval[2] + 1\nen","completion":""}
{"prompt":"-- abs(x-y)\/((abs(x)+abs(y))\/2)\nlocal function reldiff(x, y)\n  if x == y then return 0 end\n  return math.abs(x-y)\/((math.abs(x)+math.abs(y))\/2)\nen","completion":""}
{"prompt":"-- \nlocal function find_factors(x)\n  local factors = {}\n  for i=1, x do\n    if (x % i == 0) then\n      table.insert(factors, i)\n    end\n  end\n  return factors\nen","completion":""}
{"prompt":"-- >>> parenthesize('1')\n-- '1'\n-- >>> parenthesize('1 + 2')\n-- '(1 + 2)'\nlocal function parenthesize(s)\n  if s:match('%s') or s:match('^.*[%+%-%*%^%%\/.]|[%+%-%*%^%%\/.]$') then\n    return '(' .. s .. ')'\n  else\n    return s\n  end\nen","completion":""}
{"prompt":"-- Strip the shacl prefix and return value of the url.\n-- Args:\n-- url (str): String with shacl prefix.\n-- Returns:\n-- str: String after removing shacl prefix..\nlocal function strip_shacl_prefix(url)\n\treturn string.gsub(url, \"http:\/\/www.w3.org\/ns\/shacl#\", \"\")\nen","completion":""}
{"prompt":"-- Return the value at x of the 'cubic out' easing function between 0 and 1.\nlocal function cubicout(x)\n\treturn math.pow(x - 1, 3) + 1\nen","completion":""}
{"prompt":"-- Find the length of the longest substr with less than or equal to\n-- k distinct characters.\n-- Time:  O(n)\n-- Space: O(k)\n-- >>> longest_substring_with_k_distinct(\"araaci\", 2)\n-- 4\n-- >>> longest_substring_with_k_distinct(\"araaci\", 1)\n-- 2\n-- >>> longest_substring_with_k_distinct(\"cbbebi\", 3)\n-- 5\nlocal function longest_substring_with_k_distinct(s, k)\n    if k < 1 then\n        return 0\n    end\n    local count = {}\n    local distinct_count = 0\n    local start = 1\n    local longest = 0\n    local longest_start = 1\n    for i = 1, #s do\n        local char = s:sub(i, i)\n        count[char] = (count[char] or 0) + 1\n        if count[char] == 1 then\n            distinct_count = distinct_count + 1\n        end\n        while distinct_count > k do\n            local char = s:sub(start, start)\n            count[char] = count[char] - 1\n            if count[char] == 0 then\n                distinct_count = distinct_count - 1\n            end\n            start = start + 1\n        end\n        longest = math.max(longest, i - start + 1)\n        longest_start = start\n    end\n    return longest\nen","completion":""}
{"prompt":"-- $t = 5x+x^2-0.5x^3$\nlocal function true_function(x)\n    local x2 = x * x\n    return 5 * x + x2 - 0.5 * x2 * x\nen","completion":""}
{"prompt":"-- Sums up edge weights by adding the maximum of w1 and w2. This\n-- results in edge weights that are dominated by dominant figures.\nlocal function sum_max_edge_weight(acc, w1, w2)\n   if w1 > w2 then return w1 + acc end\n   return w2 + acc\nen","completion":""}
{"prompt":"-- Inicializa la matrix en blanco (4x4) lista de listas\nlocal function new_game(n)\n    local mat = {}\n    for i = 1,n do\n        mat[i] = {}\n        for j = 1,n do\n            mat[i][j] = 0\n        end\n    end\n    return mat\nen","completion":""}
{"prompt":"-- Mix parcel and environment variables (for entrainment).\n-- Args:\n-- parcel: Parcel value.\n-- environment: Environment value.\n-- rate: Entrainment rate.\n-- dz: Distance descended.\n-- Returns:\n-- Mixed value of the variable.\nlocal function mix(parcel, environment, rate, dz)\n   return parcel + rate * (environment - parcel) * dz\nen","completion":""}
{"prompt":"-- Pasa de string a float\nlocal function clean_float(num)\n\tif type(num) == 'string' then\n\t\tnum = num:gsub(\"%.\", \"\")\n\t\tnum = num:gsub(\",\", \".\")\n\tend\n\treturn tonumber(num)\nen","completion":""}
{"prompt":"-- Calculates the acceleration at timestep t\n-- Args:\n-- force_gravity (float): force of gravity at timestep i\n-- mass_ship (float): The mass of the ship at timestep i\n-- force_drag (float): Force of drag at timestep i\n-- Returns:\n-- acceleration (float): Acceleration vector from a=dF\/dm\nlocal function Acceleration(thrust, force_gravity, mass_ship, force_drag)\n  local acceleration = (thrust - force_gravity - force_drag) \/ mass_ship\n  return acceleration\nen","completion":""}
{"prompt":"-- Takes in a triangle (list of list of integers) and returns path with the most weight on the way down\nlocal function find_most_weighted_path_down(triangle)\n    local triangle_len = #triangle\n    local first_column = triangle[1]\n    for i = 2, triangle_len do\n        triangle[i][1] = triangle[i - 1][1] + triangle[i][1]\n    end\n    for i = 2, triangle_len do\n        for j = 2, triangle_len do\n            triangle[i][j] = math.max(triangle[i - 1][j - 1], triangle[i - 1][j]) + triangle[i][j]\n        end\n    end\n    return triangle[triangle_len][triangle_len]\nen","completion":""}
{"prompt":"-- \nlocal function _assure_zipped(iterables)\n\tlocal zipped = {}\n\tfor _, it in ipairs(iterables) do\n\t\tzipped[#zipped + 1] = it\n\tend\n\treturn zipped\nen","completion":""}
{"prompt":"-- Assumes that X is a list of numbers.\n-- Returns the standard deviation of X\nlocal function variance(a)\n    local sum = 0\n    local N = 0\n    for _,x in ipairs(a) do\n        sum = sum + x\n        N = N + 1\n    end\n    local mean = sum \/ N\n    local sumsq = 0\n    for _,x in ipairs(a) do\n        sumsq = sumsq + (x - mean)^2\n    end\n    return (sumsq \/ N)\nen","completion":""}
{"prompt":"-- Skipping duplicate by deleting from configuration\nlocal function skip_duplicate(keys, child_members, parent_members, combined_dict_temp)\n  local combined_dict = combined_dict_temp\n  local i = 0\n  local j = 0\n  while i < #combined_dict do\n    i = i + 1\n    local current_key = combined_dict[i]\n    if #keys > 0 then\n      for j = 1, #keys do\n        if parent_members[j] ~= current_key[keys[j]] then\n          break\n        end\n      end\n      if j == #keys + 1 then\n        j = 0\n        i = i - 1\n        table.remove(combined_dict, i)\n      end\n    else\n      for j = 1, #child_members do\n        if parent_members[j] ~= current_key[child_members[j]] then\n          break\n        end\n      end\n      if j == #child_members + 1 then\n        j = 0\n        i = i - 1\n        table.remove(combined_dict, i)\n      end\n    end\n  end\n  return combined_dict\nen","completion":""}
{"prompt":"-- Removes trailing .0 from a <class 'float'>:\n-- 1.0 to 1\n-- 5.5 to 5.5\nlocal function format_rate(rate)\n\treturn tostring(rate):gsub('%.0$', '')\nen","completion":""}
{"prompt":"-- return the index of an array element\nlocal function clean_index(a)\n\tlocal _,e = string.find(a,\"[%[%]]\")\n\tif e then return a:sub(1,e-1) end\n\treturn a\nen","completion":""}
{"prompt":"-- Converts strings into numbers (floats)\nlocal function isnumeric(s)\n  local v = tonumber(s)\n  if v then return v end\nen","completion":""}
{"prompt":"-- Charged particle multiplicity as a function of initial entropy density\n-- empirically follows a power law relation.\n-- The constant c accounts for missing entropy below the UrQMD switching\n-- temperature. This is commonly referred to as the \"corona\".\nlocal function powerlaw(x, a, b, c)\n  return c + a * math.pow(x, b)\nen","completion":""}
{"prompt":"-- Return the playing card numeral as a string for a positive n <= 13.\nlocal function card(n)\n\tif n < 1 or n > 13 then return \"\" end\n\tlocal s = {\"A\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"J\",\"Q\",\"K\"}\n\treturn s[n]\nen","completion":""}
{"prompt":"-- Convert RGB tuple to GRB tuple.\nlocal function rgb_to_grb(color_tuple)\n  return {color_tuple[2], color_tuple[1], color_tuple[3]}\nen","completion":""}
{"prompt":"-- Merge bounding boxes in format (xmin, xmax, ymin, ymax)\nlocal function merge_bbox(left, right)\n  return {\n    left[1] < right[1] and left[1] or right[1],\n    left[2] > right[2] and left[2] or right[2],\n    left[3] < right[3] and left[3] or right[3],\n    left[4] > right[4] and left[4] or right[4],\n  }\nen","completion":""}
{"prompt":"-- Computes base^p mod mod using repeated squaring\nlocal function modular_pow(base, p, mod)\n  local result = 1\n  while p > 0 do\n    if p % 2 == 1 then\n      result = (result * base) % mod\n    end\n    p = math.floor(p \/ 2)\n    base = (base * base) % mod\n  end\n  return result\nen","completion":""}
{"prompt":"-- Convert cents to dollars.\n-- :param cents: Amount in cents\n-- :type cents: int\n-- :return: float\nlocal function cents_to_dollars(cents)\n  return math.floor((cents \/ 100 + 0.00001) * 100) \/ 100\nen","completion":""}
{"prompt":"-- Converts minutes to seconds\nlocal function minutes_to_seconds(minutes)\n\treturn minutes * 60\nen","completion":""}
{"prompt":"-- Adjust times to conserve precip, but change intensity, tricky.\nlocal function conservative_adjust(times, accum, multipler)\n  local adjusted = {}\n  local last = -1\n  for i,t in ipairs(times) do\n    -- If we are still on the current day, keep going\n    if t ~= last then\n      adjusted[i] = t\n    else\n      local offset = accum[i] - accum[last]\n      adjusted[i] = t - offset * multipler\n    end\n    last = t\n  end\n  return adjusted\nen","completion":""}
{"prompt":"-- Converts a POSIX path to an equivalent Macintosh path.\n-- Works for .\/x ..\/x \/x and bare pathnames.\n-- Won't work for '..\/..\/style\/paths'.\n-- Also will expand environment variables and Cshell tilde\n-- notation if running on a POSIX platform.\nlocal function mpath(path)\n\t-- If not on a POSIX system, no need to convert.\n\tif not _POSIX then return path end\n\t-- Split path into components.\n\tlocal comps = string.split(path, '\/')\n\t-- If we're at the root of the tree, then we're done.\n\tif #comps == 1 then return path end\n\t-- If there is no leading \/, we're relative to the current directory.\n\tif comps[1] == '' then comps[1] = '.' end\n\t-- Step backwards looking for a directory component.\n\tfor i = #comps, 2, -1 do\n\t\tlocal c = comps[i]\n\t\tif c == '..' then table.remove(comps, i)\n\t\telseif c == '.' then table.remove(comps, i)\n\t\telse break\n\t\tend\n\tend\n\t-- Return the components back together, separated by \/.\n\treturn table.concat(comps, '\/')\nen","completion":""}
{"prompt":"-- Convert the temperature from Rankine to Kelvin scale.\n-- :param float temp: The temperature in degrees Rankine.\n-- :returns: The temperature in degrees Kelvin.\n-- :rtype: float\nlocal function convert_rankine_to_kelvin(temp)\n  return temp * 5 \/ 9\nen","completion":""}
{"prompt":"-- Try converting a string to base-10 integer. If that fails, try base-16.\n-- If that fails, we'll allow the ValueError to propogate.\nlocal function mkint(string)\n  local i = tonumber(string)\n  if i then return i end\n  return tonumber(string, 16)\nen","completion":""}
{"prompt":"-- Titleizes a string, aka transforms it from underscored to English title\n-- format\nlocal function titleize(s)\n  s = string.gsub(s, \"_\", \" \")\n  s = string.gsub(s, \"(%a)([%w_']*)\", function(a,b) return string.upper(a) .. b end)\n  return s\nen","completion":""}
{"prompt":"-- Remove metadata indicated by fixtures\n-- :param context: Behave context\n-- :param metadata: Metadata dictionary containing macro parameters\nlocal function filter_metadata(context, metadata)\n  metadata.fixtures = nil\n  return metadata\nen","completion":""}
{"prompt":"-- Dimensionless production rate for a gene regulated by one\n-- activator and one repressor with OR logic in the absence of\n-- leakage.\n-- Parameters\n-- ----------\n-- x : float or NumPy array\n-- Concentration of activator.\n-- y : float or NumPy array\n-- Concentration of repressor.\n-- nx : float\n-- Hill coefficient for activator.\n-- ny : float\n-- Hill coefficient for repressor.\n-- Returns\n-- -------\n-- output : NumPy array or float\n-- (1 + x**nx + x**nx * y**ny)) \/ (1 + x**nx) \/ (1 + y**ny)\nlocal function ar_or(x, y, nx, ny)\n   return (1 + x^nx + x^nx * y^ny) \/ (1 + x^nx) \/ (1 + y^ny)\nen","completion":""}
{"prompt":"-- Calculate operation result\n-- n2 Number: Number 2\n-- n1 Number: Number 1\n-- operator Char: Operation to calculate\nlocal function calc(n2, n1, operator)\n\tif operator == \"+\" then\n\t\treturn n1 + n2\n\telseif operator == \"-\" then\n\t\treturn n1 - n2\n\telseif operator == \"*\" then\n\t\treturn n1 * n2\n\telseif operator == \"\/\" then\n\t\treturn n1 \/ n2\n\telseif operator == \"^\" then\n\t\treturn n1 ^ n2\n\telseif operator == \"pi\" then\n\t\treturn math.pi\n\telse\n\t\treturn 0\n\tend\nen","completion":""}
{"prompt":"-- Linear rampup\nlocal function linear_rampup(current, rampup_length)\n    if rampup_length > 0 then\n        local rampup = current \/ rampup_length\n        if rampup > 1.0 then\n            rampup = 1.0\n        end\n        return rampup\n    end\n    return 1.0\nen","completion":""}
{"prompt":"-- Replace the Latex command \"|mbox{<argument>}|\" with just <argument>\nlocal function mBoxReplacements(tex)\n  tex = string.gsub(tex, \"|mbox{(.-)}|\", \"%1\")\n  tex = string.gsub(tex, \"|\\\\mbox{(.-)}|\", \"%1\")\n  return tex\nen","completion":""}
{"prompt":"-- Property: DataSource.Type\nlocal function validate_data_source_type(data_source_type)\n    if not data_source_type then\n        return nil, \"Please provide a valid Data Source Type\"\n    end\n    return data_source_type\nen","completion":""}
{"prompt":"-- Detects if text in table is rotated or not using the current\n-- transformation matrix (CTM) and returns its orientation.\n-- Parameters\n-- ----------\n-- lttextlh : list\n-- List of PDFMiner LTTextLineHorizontal objects.\n-- lttextlv : list\n-- List of PDFMiner LTTextLineVertical objects.\n-- ltchar : list\n-- List of PDFMiner LTChar objects.\n-- Returns\n-- -------\n-- rotation : string\n-- '' if text in table is upright, 'anticlockwise' if\n-- rotated 90 degree anticlockwise and 'clockwise' if\n-- rotated 90 degree clockwise.\nlocal function get_rotation(lttextlh, lttextlv, ltchar)\n    local rotation = ''\n    local hlines = 0\n    local vlines = 0\n    for i = 1, #lttextlh do\n        if lttextlh[i].get_text() ~= '' then\n            hlines = hlines + 1\n        end\n    end\n    for i = 1, #lttextlv do\n        if lttextlv[i].get_text() ~= '' then\n            vlines = vlines + 1\n        end\n    end\n    if hlines > vlines then\n        rotation = 'clockwise'\n    elseif vlines > hlines then\n        rotation = 'anticlockwise'\n    end\n    return rotation\nen","completion":""}
{"prompt":"-- Add a scalar to a vector\n-- Parameters\n-- ----------\n-- vector : np.ndarray\n-- shape=(n,)\n-- number : Number\n-- scalar\n-- Examples\n-- --------\n-- >>> a = np.array([1, 2, 3])\n-- >>> add_scalar(a, 5)\n-- np.array([6, 7, 8])\nlocal function add_scalar(vector, number)\n    local new_vector = {}\n    for i, v in ipairs(vector) do\n        new_vector[i] = v + number\n    end\n    return new_vector\nen","completion":""}
{"prompt":"-- Insert a period every ten characters, starting from the back.\nlocal function sep_by_10s(s)\n\tlocal chunks = {}\n\tfor i=0, #s, 10 do\n\t\tchunks[#chunks+1] = string.sub(s, i+1, math.min(i+10, #s))\n\tend\n\treturn table.concat(chunks, \".\")\nen","completion":""}
{"prompt":"-- http:\/\/en.wikipedia.org\/wiki\/Ackermann_function\nlocal function ackermann(m, n)\n    if m == 0 then return n + 1 end\n    if n == 0 then return ackermann(m - 1, 1) end\n    return ackermann(m - 1, ackermann(m, n - 1))\nen","completion":""}
{"prompt":"-- Get string with \"%d jobs\".\nlocal function cron_str_job_count(number)\n\treturn number .. ((number == 1) and \" job\" or \" jobs\")\nen","completion":""}
{"prompt":"-- Returns the factorial of n.\n-- e.g. factorial(7) = 7x6x5x4x3x2x1 = 5040\nlocal function factorial(n)\n\tlocal function iter(acc, n)\n\t\tif n <= 1 then\n\t\t\treturn acc\n\t\tend\n\t\treturn iter(acc * n, n - 1)\n\tend\n\treturn iter(1, n)\nen","completion":""}
{"prompt":"-- Converts a dahua brightness (which is 0 to 100 inclusive) and converts it to what HASS\n-- expects, which is 0 to 255 inclusive\nlocal function dahua_brightness_to_hass_brightness(bri_str)\n    if bri_str == nil or bri_str == \" \" then return 0 end\n    local bri = tonumber(bri_str)\n    if bri == nil then return 0 end\n    if bri < 0 then bri = 0 end\n    if bri > 100 then bri = 100 end\n    return math.ceil((bri \/ 100) * 255)\nen","completion":""}
{"prompt":"-- Full shape of token. Default .shape attr only\n-- returns max 5 chars per token.\n-- Based on https:\/\/github.com\/explosion\/spaCy\/blob\/master\/spacy\/lang\/lex_attrs.py#L115\n-- text (str): Input text\n-- RETURNS (str): Shape str\nlocal function full_word_shape(text)\n  local shape = text:lower()\n  shape = shape:gsub(\"%W\", \"\")\n  shape = shape:sub(1, 5)\n  return shape\nen","completion":""}
{"prompt":"-- very similar to modcoord, but only for a LxL.\n-- takes as input walk[i][0] or walk[i][1]\n-- returns the pos modified with the move, accounting for PBCs.\nlocal function modpos(pos, L, move)\n  pos = pos + move\n  return pos - math.floor(pos\/L)*L\nen","completion":""}
{"prompt":"-- Clean a word for counting.\nlocal function clean_word(word)\n  return word:gsub(\"[^%w ]\", \"\"):lower()\nen","completion":""}
{"prompt":"-- Creates the Data base initial Dictionary that will hold keys and values\nlocal function create_db()\n    local db = {}\n    return db\nen","completion":""}
{"prompt":"-- Performs matrix multiplication on two given matrices.\n-- :param a: lists of lists containing integers.\n-- :param b: lists of lists containing integers.\n-- :return: the right hand side of the equation.\nlocal function matrix_mult(a, b)\n\tlocal result = {}\n\tfor i=1, #a do\n\t\tresult[i] = {}\n\t\tfor j=1, #b[1] do\n\t\t\tlocal sum = 0\n\t\t\tfor k=1, #a[1] do\n\t\t\t\tsum = sum + a[i][k] * b[k][j]\n\t\t\tend\n\t\t\tresult[i][j] = sum\n\t\tend\n\tend\n\treturn result\nen","completion":""}
{"prompt":"-- Round nanoseconds to microseconds\nlocal function _nsec_to_usec_round(nsec)\n  return math.floor(nsec\/1000 + 0.5)\nen","completion":""}
{"prompt":"-- Returns power reflection at the interface\n-- of two refractive index materials.\n-- Args:\n-- n1: Refractive index of material 1.\n-- n2: Refractive index of material 2.\n-- Returns:\n-- float: The percentage of reflected power.\nlocal function reflection(n1, n2)\n    return ((n1 - n2) \/ (n1 + n2))^2\nen","completion":""}
{"prompt":"-- floating point version of range. Returns a list of real numbers starting\n-- at start, stepping by step, and stopping less than stop.\n-- If only one number is given, start is assumed to be 0.0, and step to be 1.0\nlocal function frange(start, stop, step)\n\tif (stop == nil) then\n\t\tstop = start\n\t\tstart = 0\n\tend\n\tif (step == nil) then\n\t\tstep = 1\n\tend\n\tlocal range = {}\n\tlocal next = start\n\tlocal i = 1\n\twhile (next < stop) do\n\t\trange[i] = next\n\t\tnext = next + step\n\t\ti = i + 1\n\tend\n\treturn range\nen","completion":""}
{"prompt":"-- Pluralize term when n is greater than one.\nlocal function pluralize(n, text, suffix)\n  if n == 1 then\n    return text\n  else\n    return text .. (suffix or 's')\n  end\nen","completion":""}
{"prompt":"-- count the frequency that phrases and words appear in a text,\n-- when passed the list of phrases (which are kept as lists). \n-- It's a list of lists.\nlocal function count_phrase_frequency(raw_list)\n\tlocal output = {}\n\tfor _, phrase in pairs(raw_list) do\n\t\tlocal index = table.concat(phrase, \" \")\n\t\tif output[index] == nil then\n\t\t\toutput[index] = 1\n\t\telse\n\t\t\toutput[index] = output[index] + 1\n\t\tend\n\tend\n\treturn output\nen","completion":""}
{"prompt":"-- Convert R or G or B pixel values from integer to binary\n-- INPUT: An integer tuple (e.g. (220))\n-- OUTPUT: A string tuple (e.g. (\"00101010\"))\nlocal function integer_to_binary(value)\n    local binary = ''\n    for i = 7, 0, -1 do\n        local mask = 1 << i\n        if value & mask ~= 0 then\n            binary = binary .. '1'\n        else\n            binary = binary .. '0'\n        end\n    end\n    return binary\nen","completion":""}
{"prompt":"-- This function takes a list of arrays and returns them (or a section of them),\n-- either untouched, or transposed, according to the parameter.\n-- Parameters\n-- ----------\n-- args : sequence of arrays\n-- The input arrays.\n-- transpose : bool\n-- If True, return transposed versions.\n-- section : slice object\n-- Section of output data to return.\n-- Returns\n-- -------\n-- list of arrays\n-- The input arrays, or their transposed versions.\nlocal function transpose_if_needed()\n  local args = {}\n  for _,arg in ipairs(arg) do\n    if arg == \"transpose\" then\n      table.insert(args, true)\n    elseif arg == \"section\" then\n      table.insert(args, arg)\n    else\n      table.insert(args, false)\n    end\n  end\n  if #args == 3 then\n    return { args[1] and transpose(args[2]), args[2] and transpose(args[3]) }\n  else\n    return { args[1] and transpose(args[2]) }\n  end\nen","completion":""}
{"prompt":"-- Remove multiple whitespaces and linefeeds from string.\n-- Args:\n-- data: String to process\n-- Returns:\n-- result: Stipped data\nlocal function cleanstring(data)\n    local result = string.gsub(data, \"%s+\", \" \")\n    result = string.gsub(result, \"%s$\", \"\")\n    result = string.gsub(result, \"^%s\", \"\")\n    return result\nen","completion":""}
{"prompt":"-- Calculate the area of wrapping paper required\nlocal function calculate_area(length, width, height)\n    return 2 * (length * width + length * height + width * height) + math.min(length * width, math.min(length * height, width * height))\nen","completion":""}
{"prompt":"-- Based on how many items were processed and how many items are there in total\n-- return string representing progress (e.g. \"Progress: 54%\")\n-- :param processed: number of already processed items\n-- :param total: total number of items to be processed\n-- :return: string with current progress\nlocal function get_progress(processed, total)\n    return string.format('Progress: %.2f%%', processed \/ total * 100)\nen","completion":""}
{"prompt":"-- Getting the prefix for the new name \n-- e.g, '0' for 12 so it becomes '012'\nlocal function get_prefix_number(num)\n  local num_string = tostring(num)\n  if #num_string == 1 then\n    return \"00\"\n  elseif #num_string == 2 then\n    return \"0\"\n  end\n  return \"\"\nen","completion":""}
{"prompt":"-- Determine if a number is a power of 2\nlocal function is_power_of_2(x)\n\treturn x ~= 0 and (x & (x - 1)) == 0\nen","completion":""}
{"prompt":"-- Splits a Wiretap Browser node path into a Wiretap server name and node\n-- ID.\n-- @details A \"node path\" combines a Wiretap server name and a node ID,\n-- yielding a single string.  When splitting a node path, this\n-- function assumes that the text before the first slash is the\n-- server name.\n-- @param[in] nodePath \\c{(str)} A non-standard conjunction of the Wiretap\n-- server name and node ID in the form of\n-- \\c{HOST:PRODUCT\/VOLUME\/PROJECT\/LIBRARY\/[REEL]\/CLIP}.\n-- @return \\c{(tuple)} The hostname and node ID (the latter always has a\n-- leading slash).\nlocal function SplitNodePath(nodePath)\n    local n = string.find(nodePath, \"\/\", 1, true)\n    local serverName, nodeID = nil, nil\n    if n == nil then\n        serverName = nodePath\n        nodeID = \"\/\"\n    else\n        serverName = string.sub(nodePath, 1, n - 1)\n        nodeID = \"\/\" .. string.sub(nodePath, n + 1, -1)\n    end\n    return {serverName, nodeID}\nen","completion":""}
{"prompt":"-- Remove html tags from a string\nlocal function remove_html_tags(text)\n\treturn text:gsub('<[^<]+>', '')\nen","completion":""}
{"prompt":"-- Function to stem words, so plural and singular are treated the same\nlocal function stem_words(text)\n  if #text > 2 then\n    text = text:gsub(\"(.*)s$\", \"%1\")\n  end\n  return text\nen","completion":""}
{"prompt":"-- This function ...\n-- :param entry:\n-- :return:\nlocal function get_float(entry)\n\treturn tonumber(string.match(entry, '^%s*([%+%-%d%.Ee]+)') or '0')\nen","completion":""}
{"prompt":"-- Helper function that converts a \"number\" in the range \n-- \"0\" to \"4\" into its corresponding (string) \"name\" \n-- in the way described below. \n-- 0 - rock\n-- 1 - Spock\n-- 2 - paper\n-- 3 - lizard\n-- 4 - scissors\nlocal function number_to_name(number)\n    local name = \"\"\n    if number == 0 then\n        name = \"rock\"\n    elseif number == 1 then\n        name = \"Spock\"\n    elseif number == 2 then\n        name = \"paper\"\n    elseif number == 3 then\n        name = \"lizard\"\n    elseif number == 4 then\n        name = \"scissors\"\n    end\n    return name\nen","completion":""}
{"prompt":"-- Collect dict of settings from env variables.\nlocal function gather_settings(pre)\n  pre = pre or \"\"\n  local settings = {}\n  for k,v in pairs(_G) do\n    if string.match(k, pre) then\n      local key = k:sub(#pre + 1)\n      if not key:match(\"[^A-Z]\") then\n        settings[key:lower()] = v\n      end\n    end\n  end\n  return settings\nen","completion":""}
{"prompt":"-- Helper function for escaping sensor and request names, replacing '.' and '-' with '_'\nlocal function escape_name(name)\n  return string.gsub(name, '[.-]', '_')\nen","completion":""}
{"prompt":"-- This could possibly be done more efficiently with `tolist` if L is\n-- np or pd array, but will stick with this simple solution for now.\nlocal function ensure_tuple_of_ints(L)\n    local new_L = {}\n    for i = 1, #L do\n        new_L[i] = math.floor(L[i])\n    end\n    return new_L\nen","completion":""}
{"prompt":"-- Replace characters in string that are not path-friendly with underscore\nlocal function sanitize_metric_name(metric_name)\n  metric_name = metric_name:gsub(\"[^%w]\", \"_\")\n  metric_name = metric_name:gsub(\"^[^a-zA-Z0-9_]\", \"\")\n  return metric_name\nen","completion":""}
{"prompt":"-- Extracts the sprreadsheet id from an url.\nlocal function extract_spreadsheet_id(string)\n  local url = string.match(string, \"https:\/\/docs.google.com\/spreadsheets\/d\/([^\/]+)\")\n  if url == nil then\n    print(\"Invalid spreadsheet id!\")\n    os.exit()\n  end\n  return url\nen","completion":""}
{"prompt":"-- Convert list of lists into flat list\nlocal function flatten(L)\n  local flat = {}\n  for _, v in ipairs(L) do\n    if type(v) == \"table\" then\n      for _, w in ipairs(flatten(v)) do\n        table.insert(flat, w)\n      end\n    else\n      table.insert(flat, v)\n    end\n  end\n  return flat\nen","completion":""}
{"prompt":"-- Designed to split up output from -o=name into a\n-- simple list of qualified object names ['kind\/name', 'kind\/name', ...]\n-- :param output: A single string containing all of the output to parse\n-- :return: A list of qualified object names\nlocal function split_names(output)\n    if output == nil then return {} end\n    local names = {}\n    for word in output:gmatch('%S+') do\n        table.insert(names, word)\n    end\n    return names\nen","completion":""}
{"prompt":"-- Used to count the vowels in the sequence\nlocal function count_vowels(s)\n    local count = 0\n    for i = 1, #s do\n        if string.find(\"aeiouAEIOU\", s:sub(i, i)) then\n            count = count + 1\n        end\n    end\n    return count\nen","completion":""}
{"prompt":"-- replace ${SRC_FILES}\nlocal function outputSourcesFiles(content, value)\n    return string.gsub(content, \"${SRC_FILES}\", value)\nen","completion":""}
{"prompt":"-- Parses a string into its tags by preserving spaces and other characters.\n-- We just split on commas\n-- :see: https:\/\/django-taggit.readthedocs.io\/page\/custom_tagging.html\n-- :param tag_string: a delimited string of tags\n-- :return: a sorted list of tag strings\nlocal function docsitalia_parse_tags(tag_string)\n    local tags = {}\n    if tag_string then\n        local t = {}\n        for w in tag_string:gmatch(\"[^, ]+\") do\n            table.insert(t, w)\n        end\n        tags = t\n    end\n    table.sort(tags)\n    return tags\nen","completion":""}
{"prompt":"-- Calculates the sigmoid derivative for the given value.\n-- :param x: Values whose derivatives should be calculated\n-- :return: Derivatives for given values\nlocal function sigmoid_deriv(x)\n    return x * (1 - x)\nen","completion":""}
{"prompt":"-- Return string without terminal newline if present\nlocal function chomp(s)\n  if s and string.sub(s, -1) == '\\n' then\n    return string.sub(s, 1, #s - 1)\n  end\n  return s\nen","completion":""}
{"prompt":"-- Check if the field has a value other then zero.\n-- :param str_field_to_check:\n-- :return:\nlocal function record_to_numeric(num)\n  return tonumber(num) ~= nil and tonumber(num) or 0\nen","completion":""}
{"prompt":"-- Mengekstraksi sup dan mengembalikan .text.strip()-nya secara aman.\nlocal function ekstraksi_aman(sup)\n\treturn sup and sup.text and sup.text:gsub(\"\\n\", \"\") or \"\"\nen","completion":""}
{"prompt":"-- Add newline to a string if it does not end with a newline.\nlocal function _append_newline(source)\n  return string.sub(source, -1) ~= '\\n' and source .. '\\n' or source\nen","completion":""}
{"prompt":"-- Convert key1=value1,key2=value2,... string into dictionary.\n-- :param strdict: key1=value1,key2=value2\n-- Note: This implementation overrides the original implementation\n-- in the neutronclient such that it is no longer required to append\n-- the key with a = to specify a corresponding empty value. For example,\n-- key1=value1,key2,key3=value3\n-- key1\n-- key1,key2\n-- will also be supported and converted to a dictionary with empty\n-- values for the relevant keys.\nlocal function str2dict(strdict)\n    local dict = {}\n    if strdict ~= nil then\n        for key_value in string.gmatch(strdict, '([^,]+)') do\n            local key,value = string.match(key_value, '(.*)=(.*)')\n            if key ~= nil then\n                dict[key] = value\n            else\n                dict[key_value] = \"\"\n            end\n        end\n    end\n    return dict\nen","completion":""}
{"prompt":"-- Returns the closest value to value in [min_value, max_value].\n-- Args:\n-- value (float): The value to map.\n-- min_value (float): Minimum value of interval.\n-- max_value (float): Maximum value of interval.\n-- Returns:\n-- float: The value clamped between boundaries\nlocal function clamp(value, min_value, max_value)\n  return math.min(max_value, math.max(value, min_value))\nen","completion":""}
{"prompt":"-- Convert from millicents to float\n-- Args:\n-- value: millicent number\n-- Returns: value in float\nlocal function mc_to_float(value)\n\treturn value \/ 100000\nen","completion":""}
{"prompt":"-- Returns the length (number of letters) in the current hand.\n-- hand: dictionary (string int)\n-- returns: integer\nlocal function calculateHandlen(hand)\n  local len = 0\n  for _ in pairs(hand) do\n    len = len + 1\n  end\n  return len\nen","completion":""}
{"prompt":"-- convert from [-1, 1] (the integration range of Gauss-Legendre)\n-- to [a, b] (our general range) through a change of variables z -> x\nlocal function interval_converter(z, a, b)\n    return 0.5 * (z + 1) * (b - a) + a\nen","completion":""}
{"prompt":"-- Funcion que convierte una matriz en su forma transpuesta\n-- (list 2D) -> list 2D\nlocal function matriztranspuesta(m1)\n\tlocal n = #m1\n\tlocal m = #m1[1]\n\tlocal m2 = {}\n\tfor i=1, m do\n\t\tm2[i] = {}\n\t\tfor j=1, n do\n\t\t\tm2[i][j] = m1[j][i]\n\t\tend\n\tend\n\treturn m2\nen","completion":""}
{"prompt":"-- Returns quoted PO term string, with special PO characters escaped\nlocal function quote(s)\n  -- escape special characters with PO special escaping codes\n  s = s:gsub(\"\\\\\", \"\\\\\\\\\")\n  s = s:gsub(\"\\\"\", \"\\\\\\\"\")\n  s = s:gsub(\"\\n\", \"\\\\n\")\n  return \"\\\"\" .. s .. \"\\\"\"\nen","completion":""}
{"prompt":"-- This is effectively a wrapped version of OFS.objectValues, but\n-- checking permission for each object.\nlocal function object_values(ocontainer, otypes)\n    local object_values = {}\n    if ocontainer and otypes then\n        for name in pairs(ocontainer) do\n            if type(name) == \"string\" and not name:match(\"^%d+$\") then\n                local obj = ocontainer[name]\n                if obj ~= nil then\n                    for _,otype in ipairs(otypes) do\n                        if obj.isTypeOf(otype) then\n                            local obj = ocontainer[name]\n                            if obj ~= nil then\n                                table.insert(object_values, obj)\n                            end\n                        end\n                    end\n                end\n            end\n        end\n    end\n    return object_values\nen","completion":""}
{"prompt":"-- Given the name of the app, create the equivalent bash-complete\n-- name. This is the uppercase version of the app name with dashes\n-- replaced by underscores.\n-- :param str app_name: the name of the app\n-- :rtype: str\n-- :returns: app_name uppercased, with dashes replaced by underscores.\nlocal function _bash_complete_name(app_name)\n    return app_name:gsub(\"-\", \"_\"):upper()\nen","completion":""}
{"prompt":"-- Return True if this process is running inside a docker container\nlocal function in_docker()\n  return io.popen(\"docker ps -q -f 'ancestor=alpine:latest'\"):read('*l') ~= ''\nen","completion":""}
{"prompt":"-- Convenience function used to make sure that a sequence is always\n-- represented by a list of symbols. Sometimes a single-symbol\n-- sequence is passed in the form of a string representing the\n-- symbol. This has to be converted to a one-item list for\n-- consistency, as a list of symbols is what many of the following\n-- functions expect.\nlocal function as_list(arg)\n  if type(arg) == \"string\" then\n    return {arg}\n  elseif type(arg) == \"table\" then\n    return arg\n  else\n    error(\"Input must be a string or a table.\")\n  end\nen","completion":""}
{"prompt":"-- Adds a directory to Python's sys.path\n-- Does not add the directory if it does not exist or if it's already on\n-- sys.path. Returns 1 if OK, -1 if new_path does not exist, 0 if it was\n-- already on sys.path.\n-- Based on: https:\/\/www.oreilly.com\/library\/view\/python-cookbook\/0596001673\/ch04s23.html\n-- Challenge: in order to use this function, we need to import the dse_do_utils package\n-- and thus we need to add it's location it to sys.path!\n-- This will work better once we can do a pip install dse-do_utils.\nlocal function add_sys_path(new_path)\n  -- Check if new_path exists\n  local f = io.open(new_path)\n  if f == nil then\n    print(\"add_sys_path: directory \" .. new_path .. \" does not exist\")\n    return -1\n  end\n  f:close()\n  \n  -- Check if new_path is already on sys.path\n  local i = 1\n  while true do\n    local p = package.path:sub(i, -1)\n    if p == \"\" then\n      break\n    end\n    if p == new_path or string.find(p, new_path..\";\") ~= nil then\n      print(\"add_sys_path: directory \" .. new_path .. \" already on sys.path\")\n      return 0\n    end\n    i = i + 1 + string.find(p, \";\")\n  end\n  \n  -- Add new_path to sys.path\n  package.path = package.path .. \";\" .. new_path .. \"\/?.lua\"\n  print(\"add_sys_path: package.path is now \" .. package.path)\n  return 1\nen","completion":""}
{"prompt":"-- Computes a bounding box from a list of coordinates\n-- Parameters\n-- ----------\n-- points : list\n-- List of coordinates in the form of [[x,y], ...]\n-- Returns\n-- -------\n-- list\n-- A 4-tuple consisting of [xmin, ymin, xmax, ymax]\nlocal function bounding_box(points)\n\tlocal min_x = points[1][1]\n\tlocal max_x = points[1][1]\n\tlocal min_y = points[1][2]\n\tlocal max_y = points[1][2]\n\tfor i, point in pairs(points) do\n\t\tif point[1] < min_x then min_x = point[1] end\n\t\tif point[1] > max_x then max_x = point[1] end\n\t\tif point[2] < min_y then min_y = point[2] end\n\t\tif point[2] > max_y then max_y = point[2] end\n\tend\n\treturn {min_x, min_y, max_x, max_y}\nen","completion":""}
{"prompt":"-- Given a numeric string (as defined by fluent spec),\n-- return an int or float\nlocal function numeric_to_native(val)\n  local v = tonumber(val)\n  if v == nil then\n    return val\n  end\n  return v\nen","completion":""}
{"prompt":"-- Parameters\n-- ----------\n-- i : int\n-- State index i.\n-- j : int\n-- State index j.\n-- Returns\n-- -------\n-- int\n-- Kronecker_Delta(i,j).\nlocal function kdelta(i, j)\n   if i == j then\n      return 1\n   else\n      return 0\n   end\nen","completion":""}
{"prompt":"-- Create list of chunk slices [(s_i, e_i), ...]\n-- Parameters\n-- ----------\n-- ds_len : 'int'\n-- Length of dataset axis to chunk\n-- chunk_size : 'int'\n-- Size of chunks\n-- Returns\n-- -------\n-- chunks : 'list'\n-- List of chunk start and end positions\n-- [(s_i, e_i), (s_i+1, e_i+1), ...]\nlocal function get_chunk_slices(ds_dim, chunk_size)\n    local num_chunks = math.ceil(ds_dim \/ chunk_size)\n    local chunks = {}\n    for i=0,num_chunks-1 do\n        chunks[i+1] = {i*chunk_size, math.min(i*chunk_size+chunk_size, ds_dim)}\n    end\n    return chunks\nen","completion":""}
{"prompt":"-- Returns a list of characters used to comment a block of code\n-- @param lang_id: used to select a specific subset of comment pattern(s)\nlocal function CommentPattern(lang_id)\n  if lang_id == 'py' or lang_id == 'python' then\n    return { '#', 'rem' }\n  elseif lang_id == 'lua' then\n    return { '--[[', '--[[' }\n  else\n    return { '--' }\n  end\nen","completion":""}
{"prompt":"-- Check if a given answer matches the label\n-- :param answer: the probability output from the network\n-- :type answer: float\n-- :param label: the label integer as either a 1 or a 0\n-- :type label: float\n-- :return: 1 if classification is correct, 0 if incorrect\n-- :rtype: int\nlocal function check_true(answer, label)\n    if answer > .5 and label == 1 then return 1 end\n    if answer < .5 and label == 0 then return 1 end\n    return 0\nen","completion":""}
{"prompt":"-- Removes extra spaces and new lines from the text.\nlocal function clean_text(text)\n\ttext = text:gsub(\"\\n\", \" \")\n\ttext = text:gsub(\"%s+\", \" \")\n\ttext = text:gsub(\"^%s*(.-)%s*$\", \"%1\")\n\treturn text\nen","completion":""}
{"prompt":"-- Returns the number n after fixing min and max thresholds.\n-- minn and maxn are scalars that represent min and max capacities.\n-- clamp ensures that capacities are within min\/max thresholds\n-- and sets n to minn or maxn if outside of thresholds, such that\n-- minn < n < maxn\nlocal function _clamp(n, minn, maxn)\n  if minn ~= nil and n < minn then n = minn end\n  if maxn ~= nil and n > maxn then n = maxn end\n  return n\nen","completion":""}
{"prompt":"-- A null n by n matrix for n players\n-- Parameters\n-- ----------\n-- nplayers : integer\n-- The number of players in the tournament.\n-- Returns\n-- -------\n-- list\n-- A null n by n matrix where n is the number of players.\nlocal function null_matrix(nplayers)\n\tlocal nullmatrix = {}\n\tfor i = 1, nplayers do\n\t\tlocal row = {}\n\t\tfor j = 1, nplayers do\n\t\t\trow[j] = 0\n\t\tend\n\t\ttable.insert(nullmatrix, row)\n\tend\n\treturn nullmatrix\nen","completion":""}
{"prompt":"-- Algorithm adapted from cpython rangeobject.c\nlocal function _compute_size(start, stop, step)\n   if step == 0 then\n      error('range() arg 3 must not be zero', 2)\n   end\n   if step > 0 then\n      if start >= stop then\n         return 0\n      end\n      return (stop - start - 1) \/\/ step + 1\n   else\n      if start <= stop then\n         return 0\n      end\n      return (start - stop - 1) \/\/ (-step) + 1\n   end\nen","completion":""}
{"prompt":"-- return number\n-- >>> sum_multiples(10)\n-- 23\n-- >>> sum_multiples(100)\n-- 2318\n-- >>> sum_multiples(1000)\n-- 233168\nlocal function sum_multiples(n)\n    local sum = 0\n    local max = n - 1\n    for i = 1, max do\n        if i % 3 == 0 or i % 5 == 0 then\n            sum = sum + i\n        end\n    end\n    return sum\nen","completion":""}
{"prompt":"-- Return one of the classes based on the result.\n-- :return: zero_class when zero result, else nonz_class\nlocal function choose_class(result, zero_class, nonz_class)\n  if result == 0 then return zero_class end\n  return nonz_class\nen","completion":""}
{"prompt":"-- Format a value as a percent of a total.\nlocal function format_percent(d, t)\n   local p = d\/t*100\n   return string.format(\"%.1f%%\", p)\nen","completion":""}
{"prompt":"-- INPUT:\n-- - ``input`` -- a list of lists, each list of the same\n-- length\n-- OUTPUT:\n-- - ``output`` -- a list of lists such that output[i][j]\n-- = input[j][i]\n-- EXAMPLES::\n-- sage: from sage.schemes.hyperelliptic_curves.monsky_washnitzer import transpose_list\n-- sage: L = [[1, 2], [3, 4], [5, 6]]\n-- sage: transpose_list(L)\n-- [[1, 3, 5], [2, 4, 6]]\nlocal function transpose_list(input)\n\tlocal output = {}\n\tfor i = 1, #input[1] do\n\t\toutput[i] = {}\n\t\tfor j = 1, #input do\n\t\t\toutput[i][j] = input[j][i]\n\t\tend\n\tend\n\treturn output\nen","completion":""}
{"prompt":"-- function to get num number of links out of links list\n-- :param links: contain the list of links\n-- :param num: contain the number of links to be extracts out of list\n-- :return links\nlocal function get_links(links, num)\n  local tmp_table = {}\n  for i, v in pairs(links) do\n    if i > num then break end\n    tmp_table[i] = v\n  end\n  return tmp_table\nen","completion":""}
{"prompt":"-- Trim dollar character if present.\nlocal function _trim_dollar(value)\n\tif string.sub(value,1,1) == \"$\" then\n\t\treturn string.sub(value,2)\n\tend\n\treturn value\nen","completion":""}
{"prompt":"-- Top-down solution: Recursion with caching.\n-- Time complexity: O(n). With the caching. Since for the overlapping\n-- subproblems we can access their results in constant time.\n-- Space complexity: O(n). We store values only up to n.\nlocal function num_ways(n)\n    local cache = {}\n    function num_ways_helper(n)\n        if n == 0 or n == 1 then\n            return 1\n        elseif cache[n] then\n            return cache[n]\n        else\n            cache[n] = num_ways_helper(n-1) + num_ways_helper(n-2)\n            return cache[n]\n        end\n    end\n    return num_ways_helper(n)\nen","completion":""}
{"prompt":"-- Returns 1 or 0 if the value is True or False.\n-- None gets interpreted as False.\n-- Otherwise, the original value is returned.\nlocal function encode_boolean(value)\n\tif value == nil then\n\t\treturn 0\n\telseif value == true then\n\t\treturn 1\n\telseif value == false then\n\t\treturn 0\n\telse\n\t\treturn value\n\tend\nen","completion":""}
{"prompt":"-- Return color as #rrggbb for the given color values.\nlocal function rgb_to_hex(red, green, blue)\n    if red then\n        local red_hex = string.format('%02x', red)\n        local green_hex = string.format('%02x', green)\n        local blue_hex = string.format('%02x', blue)\n        return '#' .. red_hex .. green_hex .. blue_hex\n    end\nen","completion":""}
{"prompt":"-- Clean variable names.\n-- Cleaning variable by removing empty list and zero and None and putting\n-- everything to upper case & removing duplicates\n-- Parameters\n-- ----------\n-- var_name : List with variable names\n-- Returns\n-- -------\n-- var_name2 : List with variable names\nlocal function cleaned_var_names(var_name)\n    local var_name2 = {}\n    local seen = {}\n    for k,v in pairs(var_name) do\n        if (v ~= \"0\") and (v ~= \"None\") and (v ~= \"\") and (v ~= \"_\") then\n            v = string.upper(v)\n            if not seen[v] then\n                table.insert(var_name2,v)\n                seen[v] = true\n            end\n        end\n    end\n    return var_name2\nen","completion":""}
{"prompt":"-- Returns interpolated value.\n-- :param diff: difference between values e.g:\n-- temperature from user: 71 (requested value),\n-- temperature previous: 70,\n-- temperature next: 80,\n-- diff = (temperature_from_user - temperature_previous) \/ (temperature_next - temperature_previous)\n-- :param prev_value: previous value\n-- :param current_value: next value\nlocal function interpolate_data(diff, prev_value, current_value)\n  if diff <= 0 then\n    return prev_value\n  elseif diff >= 1 then\n    return current_value\n  else\n    return prev_value + (current_value - prev_value) * diff\n  end\nen","completion":""}
{"prompt":"-- Return number of cells in layer ii\nlocal function cellsInLayer(ii)\n  return 2 * ii + 1\nen","completion":""}
{"prompt":"-- second method with exploating recursion\nlocal function factorial2(x)\n    if x == 0 then\n        return 1\n    else\n        return x * factorial2(x-1)\n    end\nen","completion":""}
{"prompt":"-- Examples:\n-- format_time(10) -> 10s\n-- format_time(100) -> 1m\n-- format_time(10000) -> 2h 47m\n-- format_time(1000000) -> 11d 13h 47m\n-- :param seconds:\n-- :return:\nlocal function format_time(seconds)\n    if seconds < 60 then\n        return seconds .. \"s\"\n    end\n    if seconds < 3600 then\n        return math.floor(seconds \/ 60) .. \"m\"\n    end\n    if seconds < 86400 then\n        return math.floor(seconds \/ 3600) .. \"h \" .. math.floor((seconds \/ 60) % 60) .. \"m\"\n    end\n    return math.floor(seconds \/ 86400) .. \"d \" .. math.floor((seconds \/ 3600) % 24) .. \"h \" .. math.floor((seconds \/ 60) % 60) .. \"m\"\nen","completion":""}
{"prompt":"-- Strip www. from beginning of domain names.\n-- Args:\n-- domain: string with a full domain, eg. www.google.com\n-- Returns:\n-- string: Domain without any www, eg: google.com\nlocal function strip_www_from_domain(domain)\n  return string.gsub(domain, \"^www%.\", \"\")\nen","completion":""}
{"prompt":"-- Return average of all elements in the list.\nlocal function __avg__(list_)\n\tif type(list_) ~= 'table' then\n\t\treturn 0\n\tend\n\t\n\tlocal sum_ = 0\n\tlocal count_ = 0\n\tfor _, v_ in pairs(list_) do\n\t\tsum_ = sum_ + v_\n\t\tcount_ = count_ + 1\n\tend\n\treturn sum_ \/ count_\nen","completion":""}
{"prompt":"-- given a dict object and a key, return the value associated with key; returns None if the\n-- key does not exist in the JSON object.\n-- This is the fastest method for accessing the value of a JSON given a key, but least flexible.\n-- It does not handle hierarchical JSON paths.\n-- :param json: a dict object\n-- :param key: the key (cann't handle a json path)\n-- :return: the value associated with the key, or None\nlocal function getVal(json, key)\n    --print(\"getVal()\")\n    --print(json)\n    --print(key)\n    if type(json) == \"table\" then\n        return json[key]\n    end\nen","completion":""}
{"prompt":"-- convert old format style to new style. Works for digits only\n-- %05d is converted to {:05d}\n-- :param string:\n-- :return:\nlocal function old_str_format_to_new(string)\n\tlocal new_string = string:gsub(\"%%(%d*)d\", \"{:%1d}\")\n\treturn new_string\nen","completion":""}
{"prompt":"-- Turn a namespace\n-- prefixed tag name into a Clark-notation qualified tag name for lxml. For\n-- example, ``qn('p:cSld')`` returns ``'{http:\/\/schemas...\/main}cSld'``.\n-- Source: https:\/\/github.com\/python-openxml\/python-docx\/\nlocal function quote(tag)\n  local tag = tag:gsub('^p:', '{http:\/\/schemas.openxmlformats.org\/presentationml\/2006\/main}'):gsub('^r:', '{http:\/\/schemas.openxmlformats.org\/officeDocument\/2006\/relationships}'):gsub('^a:', '{http:\/\/schemas.openxmlformats.org\/drawingml\/2006\/main}'):gsub('^pic:', '{http:\/\/schemas.openxmlformats.org\/drawingml\/2006\/picture}'):gsub('^v:', '{urn:schemas-microsoft-com:vml}'):gsub('^dgm:', '{http:\/\/schemas.openxmlformats.org\/drawingml\/2006\/diagram}'):gsub('^m:', '{http:\/\/schemas.openxmlformats.org\/officeDocument\/2006\/math}'):gsub('^w:', '{http:\/\/schemas.openxmlformats.org\/wordprocessingml\/2006\/main}'):gsub('^w10:', '{urn:schemas-microsoft-com:office:word}')\n  return tag\nen","completion":""}
{"prompt":"-- Calculate density.\nlocal function density(mass, volume)\n  return mass \/ volume\nen","completion":""}
{"prompt":"-- Extract the organization id (number) from the organization name.\n-- Args:\n-- org_name (str): The name of the organization, formatted as\n-- \"organizations\/${ORGANIZATION_ID}\".\n-- Returns:\n-- str: just the organization_id.\nlocal function org_id_from_org_name(org_name)\n  local _, _, org_id = string.find(org_name, \"organizations\/([^\/]+)\")\n  return org_id\nen","completion":""}
{"prompt":"-- Print a frame report\nlocal function report_as_table(report)\n  local r = report or {}\n  local t = {}\n  for k,v in pairs(r) do\n    if type(v) == 'table' then\n      t[k] = report_as_table(v)\n    else\n      t[k] = v\n    end\n  end\n  return t\nen","completion":""}
{"prompt":"-- Returns the length of the line's leading whitespace, treating tab stops\n-- as being spaced 8 characters apart.\nlocal function _indentation(line)\n    local indent = 0\n    for i = 1, #line do\n        local c = line:sub(i, i)\n        if c == '\\t' then\n            indent = indent + 8 - (indent % 8)\n        elseif c == ' ' then\n            indent = indent + 1\n        else\n            break\n        end\n    end\n    return indent\nen","completion":""}
{"prompt":"-- Convert decibels (dB) to power\n-- .. doctest::\n-- >>> from spectrum import db2pow\n-- >>> p = db2pow(-10)\n-- >>> p\n-- 0.1\n-- .. seealso:: :func:`pow2db`\nlocal function db2pow(xdb)\n    return math.pow(10, xdb\/10.0)\nen","completion":""}
{"prompt":"-- Break url into a dirname\nlocal function get_repo_dname(repo_url)\n    local dname = repo_url:match(\"[^\/]+$\")\n    if not dname then\n        return nil, \"Could not get repo dirname\"\n    end\n    if dname:find(\"%.git$\") then\n        dname = dname:sub(1, -5)\n    end\n    return dname\nen","completion":""}
{"prompt":"-- Return the argument text, unchanged.\n-- (Directive option conversion function.)\n-- No argument implies empty string (\"\").\nlocal function unchanged(argument)\n  if not argument then\n    return \"\"\n  else\n    return argument\n  end\nen","completion":""}
{"prompt":"-- Characteristic wall thicknesses (Table 5-6)\n-- t_1 used where failure is likely to occur in connection with a low\n-- capacity:\n-- - Burst\n-- - Collapse\nlocal function t_1(t_nom, fab_tol, t_cor)\n\treturn t_nom - fab_tol - t_cor\nen","completion":""}
{"prompt":"-- Read the source file, skip the number of given lines.\nlocal function read_source_file(filename, skiplines)\n  local ret = {}\n  local i = 0\n  for line in io.lines(filename) do\n    i = i + 1\n    if i <= skiplines then\n      ret[#ret + 1] = \"\"\n    else\n      ret[#ret + 1] = line\n    end\n  end\n  return table.concat(ret, \"\\n\")\nen","completion":""}
{"prompt":"-- Returns a plural 's' if count is not 1\nlocal function GetPlural(count)\n\tif count == 1 then\n\t\treturn \"\"\n\telse\n\t\treturn \"s\"\n\tend\nen","completion":""}
{"prompt":"-- Computes the number of cartesian functions for a given angular momentum.\n-- Parameters\n-- ----------\n-- L : int\n-- The input angular momentum\n-- Returns\n-- -------\n-- ncartesian : int\n-- The number of cartesian functions\nlocal function ncartesian(L)\n\t-- Initialize the number of cartesian functions\n\tlocal ncartesian = 0\n\t-- Loop over the different angular momentum shells\n\tfor l = 0, L do\n\t\t-- Increment the number of cartesian functions\n\t\tncartesian = ncartesian + (l+1)\n\tend\n\t-- Return the number of cartesian functions\n\treturn ncartesian\nen","completion":""}
{"prompt":"-- Render username and address part.\nlocal function ssh_auth(username, address)\n  local user_auth = username and username .. '@' or ''\n  local host_auth = address:gsub(\"^%[\", \"\"):gsub(\"%]$\", \"\")\n  local auth = user_auth .. host_auth\n  if user_auth == \"\" and host_auth == \"\" then\n    auth = \"~\"\n  end\n  return auth\nen","completion":""}
{"prompt":"-- Limits a value within a given minimum and maximum range.\nlocal function clamp(val, min_val, max_val)\n\treturn math.min(max_val, math.max(min_val, val))\nen","completion":""}
{"prompt":"-- remove \"plugins.\" prefix if it exist\nlocal function _strip_plugin_path(path)\n  if path:find(\"^plugins.\") then\n    path = path:gsub(\"^plugins.\", \"\")\n  end\n  return path\nen","completion":""}
{"prompt":"-- Return relative degree of transfer function from zeros and poles.\n-- This is simply len(p) - len(z), which must be nonnegative.\n-- A ValueError is raised if len(p) < len(z).\nlocal function _relative_degree(z, p)\n    local n = #z\n    local m = #p\n    assert(m >= n, 'len(p) must be at least len(z).')\n    return m - n\nen","completion":""}
{"prompt":"-- This function change tuples to list of dicts using fields\nlocal function create_player_list(records, fields)\n  local result = {}\n  for i,v in ipairs(records) do\n    local player = {}\n    for j,k in ipairs(fields) do\n      player[k] = v[j]\n    end\n    table.insert(result, player)\n  end\n  return result\nen","completion":""}
{"prompt":"-- Function to convert length in inches to cm\nlocal function convert_in_to_cm(inch_len)\n   local cm_len = inch_len * 2.54\n   return cm_len\nen","completion":""}
{"prompt":"-- Clamp a value between a min and max\n-- :param n:\n-- :param minimum:\n-- :param maximum:\n-- :return:\nlocal function clamp_value(n, minimum, maximum)\n    if n < minimum then\n        return minimum\n    end\n    if n > maximum then\n        return maximum\n    end\n    return n\nen","completion":""}
{"prompt":"-- :param number: int - current round number.\n-- :return: list - current round and the two that follow.\nlocal function get_rounds(number)\n  local rounds = {}\n  for i = number, number + 2 do\n    table.insert(rounds, i)\n  end\n  return rounds\nen","completion":""}
{"prompt":"-- Return the tuple whose first element is largest.\nlocal function maxTuple(tuples)\n    local result = tuples[1]\n    for _, tuple in ipairs(tuples) do\n        if tuple[1] > result[1] then result = tuple end\n    end\n    return result\nen","completion":""}
{"prompt":"-- Normalize the address by lowercasing the domain part of the email\n-- address.\n-- Taken from Django.\nlocal function normalize_email(email)\n\tif not email then\n\t\treturn ''\n\tend\n\tlocal atpos = string.find(email, '@')\n\tif atpos then\n\t\temail = string.lower(string.sub(email, 1, atpos-1))\n\t\temail = email .. string.sub(email, atpos)\n\tend\n\treturn email\nen","completion":""}
{"prompt":"-- %timeit find_missing_funcs(funcs, text)\n-- 1 loops, best of 3: 973 ms per loop\nlocal function find_missing_functions(keywords, text)\n    local nFuncs = #keywords\n    local nText = #text\n    local missing = {}\n    for i, func in ipairs(keywords) do\n        if text:find(func) == nil then\n            missing[#missing + 1] = func\n        end\n    end\n    return missing\nen","completion":""}
{"prompt":"-- Returns the dot-product of vectors a and b.\n-- :param a: Vector A\n-- :param b: Vector B\nlocal function dot(a, b)\n  return a[1] * b[1] + a[2] * b[2]\nen","completion":""}
{"prompt":"-- Compute slope window for rays to be within tolerance of supplied point\n-- Computes slope window of 2d cone with base point `(base_x, base_y)` and\n-- which passes through points `(point_x, point_y-tol)` and `(point_x,\n-- point_y+tol)`.\nlocal function tolerance_slope_window(base_x, base_y, point_x, point_y, tol)\n  local lower_y = point_y - tol\n  local upper_y = point_y + tol\n  local lower_y_slope = (lower_y - base_y) \/ (point_x - base_x)\n  local upper_y_slope = (upper_y - base_y) \/ (point_x - base_x)\n  return {lower_y_slope, upper_y_slope}\nen","completion":""}
{"prompt":"-- Template filter to display last two characters only\nlocal function two_digit_year(value)\n  if value then\n    return string.sub(value, 3)\n  end\n  return \"\"\nen","completion":""}
{"prompt":"-- Generate the id for a frontend ip configuration\nlocal function frontend_ip_configuration_id(subscription_id, resource_group_name, appgateway_name, name)\n\treturn \"\/subscriptions\/\" .. subscription_id .. \"\/resourceGroups\/\" .. resource_group_name .. \"\/providers\/Microsoft.Network\/applicationGateways\/\" .. appgateway_name .. \"\/frontendIPConfigurations\/\" .. name\nen","completion":""}
{"prompt":"-- Pull all values of specified key from nested JSON.\nlocal function extract_value(obj, key)\n\tif type(obj) ~= 'table' then\n\t\treturn\n\tend\n\tif obj[key] ~= nil then\n\t\treturn obj[key]\n\tend\n\tfor _, v in pairs(obj) do\n\t\tlocal val = extract_value(v, key)\n\t\tif val ~= nil then\n\t\t\treturn val\n\t\tend\n\tend\nen","completion":""}
{"prompt":"-- Replace text in rendered page with their replacements, for example to ensure\n-- absolute paths, or replace links of the type:\n-- href=\"page\/section1\/page1\/\"\n-- with\n-- href=\"\/page\/section1\/page1\/\"\n-- when 'page' is pathprefix\nlocal function template_replace(content, replacements)\n  local replacements_keys = {}\n  for k in pairs(replacements) do\n    table.insert(replacements_keys, k)\n  end\n  table.sort(replacements_keys)\n  for i = #replacements_keys, 1, -1 do\n    local k = replacements_keys[i]\n    local replacement = replacements[k]\n    replacement = replacement:gsub('%%', '%%%%')\n    content = content:gsub(k, replacement)\n  end\n  return content\nen","completion":""}
{"prompt":"-- Escape backslashes.\n-- #FIXME:  This *may* prove to be a performance bottleneck and should\n-- perhaps be implemented in C (as it was in 4Suite RDF)\n-- Ported from Ft.Lib.DbUtil\nlocal function escape_quotes(qstr)\n    if not qstr then return '' end\n    local escaped, i = qstr:gsub(\"\\\\\", \"\\\\\\\\\")\n    escaped, i = escaped:gsub(\"\\\"\", \"\\\\\\\"\")\n    escaped, i = escaped:gsub(\"'\", \"\\\\'\")\n    escaped, i = escaped:gsub(\"\\n\", \"\\\\n\")\n    escaped, i = escaped:gsub(\"\\r\", \"\\\\r\")\n    return escaped\nen","completion":""}
{"prompt":"-- Get sign value based on threshold that defaults to 0.\n-- :param float value:\n-- :param float threshold:\n-- :return: -1, 0 or 1\nlocal function sign(value, threshold)\n    if threshold == nil then\n        threshold = 0\n    end\n    if value > threshold then\n        return 1\n    elseif value < threshold then\n        return -1\n    else\n        return 0\n    end\nen","completion":""}
{"prompt":"-- Function to combine two orderings. \n-- Example 1:\n-- ordering_1 = ((7,2), 'X')\n-- ordering_2 = ((6,5),)\n-- combined_ordering = ((7,2),(6,5))\n-- Example 2:\n-- ordering_1 = ((7,2), 'X', 'X')\n-- ordering_2 = ((6,5), 'X')\n-- combined_ordering = ((7,2),(6,5), 'X')\n-- Example 3:\n-- ordering_1 = ('X', (7,2), 'X')\n-- ordering_2 = ((6,5), 'X')\n-- combined_ordering = ((6,5),(7,2), 'X')\nlocal function combine_orderings(ordering_1, ordering_2)\n    if ordering_1 == nil then\n        return ordering_2\n    elseif ordering_2 == nil then\n        return ordering_1\n    end\n    \n    local ordering_1_has_empty_table = type(ordering_1) == \"table\" and next(ordering_1) == nil\n    local ordering_2_has_empty_table = type(ordering_2) == \"table\" and next(ordering_2) == nil\n    \n    if ordering_1_has_empty_table then\n        return ordering_2\n    elseif ordering_2_has_empty_table then\n        return ordering_1\n    end\n    \n    local combined_ordering = {}\n    for key, value in pairs(ordering_1) do\n        table.insert(combined_ordering, {key, value})\n    end\n    for key, value in pairs(ordering_2) do\n        table.insert(combined_ordering, {key, value})\n    end\n    \n    return combined_ordering\nen","completion":""}
{"prompt":"-- Returns a sequence name like '20180227_185324'.\nlocal function get_sequence_name(image_file)\n   local sequence_name = image_file:match(\"(%d%d%d%d%d%d%d%d%_%d%d%d%d%d%d)\")\n   assert(sequence_name, \"Could not get sequence name from image file name\")\n   return sequence_name\nen","completion":""}
{"prompt":"-- Checking the new guess alphabet can be found in latest guess or not, and reduce 1 point if its not.\n-- :param life_point: int, the current number of guess left.\n-- :param input_guess: str, the new guess alphabet input.\n-- :param current_guess: str, the replaced hint of latest guess.\n-- :return: the latest number of guess left.\nlocal function check_guess(life_point, input_guess, current_guess)\n\tlocal index = string.find(current_guess, input_guess)\n\tif index ~= nil then\n\t\treturn life_point\n\telse\n\t\tlife_point = life_point - 1\n\t\treturn life_point\n\tend\nen","completion":""}
{"prompt":"-- Rosenbrock test fitness function\nlocal function rosenbrock(x)\n  local y = 100 * (x[2]-x[1]*x[1])^2\n  y = y + (1-x[1])^2\n  return y\nen","completion":""}
{"prompt":"-- returns a string formatted as a title\nlocal function to_title(str)\n  if not str then return \"\" end\n  str = string.gsub(str, \"_\", \" \")\n  str = string.gsub(str, \"%a\", string.upper, 1)\n  return str\nen","completion":""}
{"prompt":"-- Returns the list of placeholder names found in the given string.\n-- Placeholders are of the form `{foo}`.\n-- Args:\n-- s: The string that potentially contains placeholders.\n-- Returns:\n-- A list of placeholder names found in the string, if any.\nlocal function _collect_group_names(s)\n  local r = {}\n  for i in s:gmatch(\"{([^}]*)}\") do\n    table.insert(r, i)\n  end\n  return r\nen","completion":""}
{"prompt":"-- Returns the number of times '\/' appears in string s\n-- Parameter s: the string to search\n-- Precondition: s is a (possibly empty) string\nlocal function count_slash_while(s)\n  local i, count = 1, 0\n  while i <= #s do\n    if s:sub(i, i) == \"\/\" then count = count + 1 end\n    i = i + 1\n  end\n  return count\nen","completion":""}
{"prompt":"-- Recursively returns the factorial of a number\n-- @param {number}\n-- @return {number} factorial value\nlocal function factorial(num)\n  if num == 0 then\n    return 1\n  end\n  return num * factorial(num - 1)\nen","completion":""}
{"prompt":"-- Returns only relevent fields form replication_tasks object\nlocal function shorten_replication_tasks(replication_tasks)\n\tfor k,v in pairs(replication_tasks) do\n\t\tif k == \"task_id\" then\n\t\t\treplication_tasks[k] = v\n\t\telseif k == \"app_name\" then\n\t\t\treplication_tasks[k] = v\n\t\telseif k == \"source_node_uuid\" then\n\t\t\treplication_tasks[k] = v\n\t\telseif k == \"source_node_hostname\" then\n\t\t\treplication_tasks[k] = v\n\t\telseif k == \"source_node_status\" then\n\t\t\treplication_tasks[k] = v\n\t\telseif k == \"target_node_uuid\" then\n\t\t\treplication_tasks[k] = v\n\t\telseif k == \"target_node_hostname\" then\n\t\t\treplication_tasks[k] = v\n\t\telseif k == \"target_node_status\" then\n\t\t\treplication_tasks[k] = v\n\t\telseif k == \"type\" then\n\t\t\treplication_tasks[k] = v\n\t\telseif k == \"state\" then\n\t\t\treplication_tasks[k] = v\n\t\telseif k == \"error_code\" then\n\t\t\treplication_tasks[k] = v\n\t\telseif k == \"error_message\" then\n\t\t\treplication_tasks[k] = v\n\t\telseif k == \"time_last_state_change\" then\n\t\t\treplication_tasks[k] = v\n\t\telseif k == \"time_started\" then\n\t\t\treplication_tasks[k] = v\n\t\telseif k == \"time_ended\" then\n\t\t\treplication_tasks[k] = v\n\t\telseif k == \"last_error\" then\n\t\t\treplication_tasks[k] = v\n\t\tend\n\tend\n\treturn replication_tasks\nen","completion":""}
{"prompt":"-- Check if patch belongs to upstream\/rdo\/downstream gerrit,\n-- :param patch_url: Gerrit URL in a string format\n-- :returns gerrit: return string i.e 'upstream'\/'rdo'\/'downstream'\nlocal function gerrit_check(patch_url)\n\tif string.find(patch_url,\"https:\/\/review.rdoproject.org\") then\n\t\treturn \"rdo\"\n\telseif string.find(patch_url,\"https:\/\/review.opendev.org\") then\n\t\treturn \"upstream\"\n\telse\n\t\treturn \"downstream\"\n\tend\nen","completion":""}
{"prompt":"-- This function converts fahrenheit to rankine, with fahrenheit as parameter.\nlocal function fartorank(fahrenheit)\n\treturn (fahrenheit + 459.67)\nen","completion":""}
{"prompt":"-- By Pierre Vigier https:\/\/github.com\/pvigier\/perlin-numpy\n-- Licence: MIT\nlocal function interpolant(t)\n\tlocal t3 = t * t * t\n\tlocal t4 = t3 * t\n\tlocal t5 = t4 * t\n\treturn 6 * t5 - 15 * t4 + 10 * t3\nen","completion":""}
{"prompt":"-- Make given \"basePath\" a canonical base URL which can be prepended to paths starting with \"\/\".\nlocal function canonical_base_path(base_path)\n  if string.sub(base_path, -1) == '\/' then\n    return string.sub(base_path, 1, -2)\n  else\n    return base_path\n  end\nen","completion":""}
{"prompt":"-- Returns the specific bit of a words value\nlocal function BitValue(value, bitno)\n    return (value % (1 << (bitno + 1))) >= (1 << bitno)\nen","completion":""}
{"prompt":"-- Converts strings \"true\" and \"false\" from XML files to Python bool\nlocal function _bool(xml_boolean)\n    if xml_boolean == 'true' then\n        return true\n    else\n        return false\n    end\nen","completion":""}
{"prompt":"-- Returns Euclidean distance between two points rounded to the nearest\n-- integer.\nlocal function euclidean_distance(x1, y1, x2, y2)\n    local distance = math.sqrt((x2 - x1)^2 + (y2 - y1)^2)\n    return math.floor(distance + 0.5)\nen","completion":""}
{"prompt":"-- Return the mean of grades\nlocal function find_mean(all_grades)\n  local sum = 0\n  for _, grade in ipairs(all_grades) do\n    sum = sum + grade\n  end\n  local mean = sum \/ #all_grades\n  return mean\nen","completion":""}
{"prompt":"-- Returns the systemEventID of a given event\nlocal function getSystemEventID(element)\n\tlocal systemEventID = element.systemEventID\n\treturn systemEventID\nen","completion":""}
{"prompt":"-- Calculates the F-meassure of the supplied data, using the equation as per https:\/\/en.wikipedia.org\/wiki\/Precision_and_recall#F-measure :\n-- F = (1 + beta^2) * (precision * recall)\/(beta^2 * precision + recall)\n-- If the recall and precision is 0, the f-score is set to 0, as no correct true positives are in the analyzed data\n-- Input:\n-- precision: The precision value of the data\n-- recall: The recall value of the data\n-- beta: A weight parameter of the F-Meassure. Default is None, which defaults to the F1 meassure. Should only be set to float values\n-- Output:\n-- F: The F meassure value of the supplied valies\nlocal function calculate_F_score(precision, recall, beta)\n  local beta = beta or 1\n  if (precision == 0 and recall == 0) then\n    return 0\n  else\n    return (1 + beta^2) * (precision * recall)\/(beta^2 * precision + recall)\n  end\nen","completion":""}
{"prompt":"-- >>> handle('https:\/\/github.com\/user\/repo')\n-- 'user\/repo'\n-- >>> handle('user\/repo')\n-- 'user\/repo'\n-- >>> handle('')\n-- ''\nlocal function handle(string)\n    local url = string.match(string, 'github.com\/(.+)') or string\n    return url:gsub('^\/+', ''):gsub('\/+$', '')\nen","completion":""}
{"prompt":"-- Quotes the '\"' and '' characters in a string and surrounds with \"...\"\nlocal function quote(s)\n\treturn \"\\\"\" .. s:gsub(\"\\\\\", \"\\\\\\\\\"):gsub(\"\\\"\", \"\\\\\\\"\"):gsub(\"'\", \"\\\\\\'\") .. \"\\\"\"\nen","completion":""}
{"prompt":"-- remove newlines from a string (and remove extra whitespace)\nlocal function stripnl(s)\n   return (string.gsub(s, \"%s+\", \" \")):gsub(\"^%s*(.-)%s*$\", \"%1\")\nen","completion":""}
{"prompt":"-- Returns a URL without the http:\/\/ or https:\/\/ prefixes\nlocal function without_http_prefix(url)\n\tlocal lower = url:lower()\n\tif string.sub(lower, 1, 7) == \"http:\/\/\" then\n\t\treturn string.sub(lower, 8)\n\telseif string.sub(lower, 1, 8) == \"https:\/\/\" then\n\t\treturn string.sub(lower, 9)\n\telse\n\t\treturn url\n\tend\nen","completion":""}
{"prompt":"-- Convert from seconds to milliseconds.\n-- Args:\n-- s (float, int): Value in seconds.\n-- Returns:\n-- int: Value in milliseconds.\nlocal function to_ms(s)\n  return math.floor(s * 1000)\nen","completion":""}
{"prompt":"-- :type s: str\n-- :rtype: int\nlocal function romanToInt(s)\n    local dict = {\n        ['I'] = 1,\n        ['V'] = 5,\n        ['X'] = 10,\n        ['L'] = 50,\n        ['C'] = 100,\n        ['D'] = 500,\n        ['M'] = 1000\n    }\n    local res = 0\n    local len = #s\n    for i=1,len do\n        local v = dict[s:sub(i,i)]\n        if i ~= len and dict[s:sub(i+1,i+1)] > v then\n            res = res - v\n        else\n            res = res + v\n        end\n    end\n    return res\nen","completion":""}
{"prompt":"-- Add to a CSS class attribute.\n-- The string `add` will be added to the classes already in `class_`, with\n-- a space if needed.  `class_` can be None::\n-- >>> add_class(\"foo\", None)\n-- 'foo'\n-- >>> add_class(\"foo\", \"bar\")\n-- 'bar foo'\n-- Returns the amended class string.\nlocal function add_class(add, class_)\n  if class_ == nil then return add end\n  if add == nil then return class_ end\n  if class_ ~= \"\" and add ~= \"\" then\n    class_ = class_ .. \" \"\n  end\n  return class_ .. add\nen","completion":""}
{"prompt":"-- :param q:           Input q-value\n-- :param intercept:   Intrecept in linear model\n-- :param slope:       Slope in linear model\n-- :return:            Calculated Intensity\nlocal function Iq(q, intercept, slope)\n\tif q < 0 then\n\t\treturn intercept + q * slope\n\telse\n\t\treturn intercept + slope * q\n\tend\nen","completion":""}
{"prompt":"-- a * (x-x0) ** b\nlocal function power_func2(x, x0, a, b)\n\treturn a * (x - x0) ^ b\nen","completion":""}
{"prompt":"-- Given product id number, return product name\nlocal function convert_product_id_to_name(id)\n   local name = id\n   if id == 4020 then\n      name = 'Platinum'\n   elseif id == 4030 then\n      name = 'Gold'\n   elseif id == 4010 then\n      name = 'Silver'\n   elseif id == 4050 then\n      name = 'Diamond'\n   elseif id == 4000 then\n      name = 'Titanium'\n   elseif id == 4040 then\n      name = 'Iridium'\n   end\n   return name\nen","completion":""}
{"prompt":"-- Return the file name in the section header.\n-- A section header is a filename and a section length separated by a\n-- comma.\nlocal function etags_section_filename(header)\n\tlocal comma = string.find(header, \",\")\n\tif comma ~= nil then\n\t\treturn string.sub(header, 1, comma - 1)\n\tend\n\treturn header\nen","completion":""}
{"prompt":"-- Convert sample length in milleconds to number of frames.\nlocal function convert_ms_to_frames(sample_length, framerate)\n    return math.floor(framerate * sample_length \/ 1000)\nen","completion":""}
{"prompt":"-- Returns the root part of the filename\nlocal function get_root(file)\n\treturn file:match(\"^.+[\/\\\\]\") or \"\"\nen","completion":""}
{"prompt":"-- Easing function for animations: Quartic Ease In & Out\nlocal function quartic_easeinout(pos)\n\tif pos < 0.5 then\n\t\treturn 8 * math.pow(pos, 4)\n\telse\n\t\treturn -8 * math.pow(pos - 1, 4) + 1\n\tend\nen","completion":""}
{"prompt":"-- reverse the sequence string in reverse order\nlocal function reverse(s)\n\treturn s:reverse()\nen","completion":""}
{"prompt":"-- Converts 2-D tabular data to clipboard text.\n-- :param table_data: 2D tabular data\n-- :return: clipboard text\nlocal function convert_table_to_clipboard_text(table_data)\n  local rows = {}\n  for _, row in ipairs(table_data) do\n    local line = {}\n    for _, cell in ipairs(row) do\n      local cell_text = cell\n      if type(cell_text) == 'number' then\n        cell_text = string.format('%.2f', cell_text)\n      elseif type(cell_text) == 'boolean' then\n        cell_text = cell and 'true' or 'false'\n      end\n      table.insert(line, cell_text)\n    end\n    table.insert(rows, table.concat(line, '\\t'))\n  end\n  return table.concat(rows, '\\n')\nen","completion":""}
{"prompt":"-- Rotate X left by the given shift value\nlocal function rol32(x, shift)\n\tlocal r = bit32.band(x, 0xFFFFFFFF)\n\treturn bit32.bor(bit32.lshift(r, shift), bit32.rshift(r, 32-shift))\nen","completion":""}
{"prompt":"-- Takes a number n and returns n + n-2 + n-4 + n-6 + ... + 0.\n-- >>> skip_add(5)  # 5 + 3 + 1 + 0\n-- 9\n-- >>> skip_add(10) # 10 + 8 + 6 + 4 + 2 + 0\n-- 30\n-- >>> # Do not use while\/for loops!\n-- >>> from construct_check import check\n-- >>> # ban iteration\n-- >>> check(this_file, 'skip_add',\n-- ...       ['While', 'For'])\n-- True\nlocal function skip_add(n)\n  local result = 0\n  for i = n, 0, -2 do\n    result = result + i\n  end\n  return result\nen","completion":""}
{"prompt":"-- Helper function that separates uri descriptors from the mixture \n-- of text and uris that is returned from Agritriop\n-- Parameters\n-- ----------\n-- dl : list\n-- Descriptor list.\n-- Returns\n-- -------\n-- list\n-- list of uri descritors only.\nlocal function get_agrovoc_uris(dl)\n  local uris = {}\n  for i, e in ipairs(dl) do\n    if type(e) == \"string\" then\n      if string.find(e, 'http') then\n        table.insert(uris, e)\n      end\n    end\n  end\n  return uris\nen","completion":""}
{"prompt":"-- Return the extension only for a name (like a filename)\n-- >>> get_ext('foo.bar')\n-- 'bar'\n-- >>> get_ext('.only')\n-- 'only'\n-- >>> get_ext('')\n-- ''\n-- >>> get_ext('noext')\n-- ''\n-- >>> get_ext('emptyext.')\n-- ''\n-- Note that for any non-empty string, the result will never be the\n-- same as the input. This is a useful property for basepack.\nlocal function get_ext(name)\n    if name == '' then\n        return ''\n    else\n        local ext = name:match('.*%.(.*)$')\n        if not ext then return '' end\n        return ext\n    end\nen","completion":""}
{"prompt":"-- Normalize an input string\nlocal function normalize_str(input_str)\n  if type(input_str) == 'string' then\n    -- Remove all the leading and trailing whitespaces from the input string\n    local trimmed_str = string.gsub(string.gsub(input_str, \"^%s*(.-)%s*$\", \"%1\"), \"%s+\", \" \")\n    -- Convert the input string to lowercase\n    trimmed_str = string.lower(trimmed_str)\n    -- Return the trimmed and lowercase string\n    return trimmed_str\n  else\n    error(\"Input must be a string\")\n  end\nen","completion":""}
{"prompt":"-- Converts an int value to ASCII hex, as used by LifeSOS.\n-- Unlike regular hex, it uses the first 6 characters that follow\n-- numerics on the ASCII table instead of A - F.\nlocal function to_ascii_hex(value, digits)\n  local result = ''\n  digits = digits or 1\n  for i = 1, digits do\n    local digit = math.floor(value % 16)\n    result = string.char(digit < 10 and digit + 48 or digit + 55) .. result\n    value = math.floor(value \/ 16)\n  end\n  return result\nen","completion":""}
{"prompt":"-- If a string has single or double quotes around it, remove them.\n-- Make sure the pair of quotes match.\n-- If a matching pair of quotes is not found, return the string unchanged.\nlocal function dequote(s)\n  if s == nil or s == '' then return s end\n  local slen = #s\n  if slen < 2 then return s end\n  local c0 = s:sub(1, 1)\n  local c1 = s:sub(slen, slen)\n  if c0 == '\"' and c1 == '\"' then\n    return s:sub(2, slen - 1)\n  elseif c0 == \"'\" and c1 == \"'\" then\n    return s:sub(2, slen - 1)\n  else\n    return s\n  end\nen","completion":""}
{"prompt":"-- Transcribes a DNA sequence to RNA.\n-- Input: string of A's, T's, G's, and C's\n-- Output: string of RNA basd on input DNA.\n-- Converts using the following rules:\n-- A->U, T->A, G->C, C->G\nlocal function transcribe(seq)\n\tlocal rna = \"\"\n\tfor i = 1, string.len(seq) do\n\t\tlocal amino = string.sub(seq, i, i)\n\t\tlocal rna_codon = \"\"\n\t\tif amino == \"A\" then\n\t\t\trna_codon = \"U\"\n\t\telseif amino == \"T\" then\n\t\t\trna_codon = \"A\"\n\t\telseif amino == \"G\" then\n\t\t\trna_codon = \"C\"\n\t\telseif amino == \"C\" then\n\t\t\trna_codon = \"G\"\n\t\telse\n\t\t\trna_codon = \"X\"\n\t\tend\n\t\trna = rna .. rna_codon\n\tend\n\treturn rna\nen","completion":""}
{"prompt":"-- Returns a triangular wave evaluated at x, given its period and amplitude.\n-- Equation source: https:\/\/en.wikipedia.org\/wiki\/Triangle_wave\nlocal function triangular_wave(x, period, amplitude)\n  return amplitude * (2 * (x \/ period) - math.floor(2 * (x \/ period) + 0.5))\nen","completion":""}
{"prompt":"-- Change \" to \\\".\nlocal function quote(text)\n    return text:gsub('\"', '\\\\\"')\nen","completion":""}
{"prompt":"-- Implements the derivative of the logistic function.\n-- Parameters\n-- ----------\n-- x: array-like, shape (M, N)\n-- Returns\n-- -------\n-- x_new: array-like, shape (M, N)\nlocal function _d_logistic(X)\n    return X * (1 - X)\nen","completion":""}
{"prompt":"-- Guess identifier format.\n-- :param str identifier_str: Chemical identifier string.\n-- :return: 'inchi' or 'smiles' string.\n-- :rtype: :py:class:`str`\nlocal function guess_identifier_format(identifier_str)\n  -- TODO: check whether this is robust enough\n  return identifier_str:find(\"InChI\") and \"inchi\" or \"smiles\"\nen","completion":""}
{"prompt":"-- Fetch the symbol entry in the elements dictionary in Aiida.\nlocal function fetch_symbols_from_elements(elmnts)\n\tlocal elmnts_symbols = {}\n\tfor k,v in pairs(elmnts) do\n\t\telmnts_symbols[k] = v.symbol\n\tend\n\treturn elmnts_symbols\nen","completion":""}
{"prompt":"-- This function converts Reaumur to celsius, with Reaumur as parameter.\nlocal function reautocels(reaumur)\n\treturn ((reaumur*5)\/4)\nen","completion":""}
{"prompt":"-- Calculate a similarity measure from an edit distance.\n-- **Args**:\n-- * distance (int): The edit distance between two strings.\n-- * length (int): The length of the longer of the two strings the        edit distance is from.\n-- **Returns**:\n-- A similarity value from 0 to 1.0 (1 - (length \/ distance)), -1 if        distance is negative\nlocal function to_similarity(distance, length)\n  if distance < 0 then\n    return -1\n  end\n  if distance == 0 then\n    return 1.0\n  end\n  return 1.0 - distance \/ length\nen","completion":""}
{"prompt":"-- Whitespace normalization:\n-- - Strip empty lines\n-- - Strip trailing whitespace\nlocal function text_remove_empty_lines(text)\n   local lines = {}\n   for line in text:gmatch(\"[^\\r\\n]+\") do\n      local trimmed_line = line:gsub(\"%s*$\", \"\")\n      if trimmed_line ~= \"\" then\n         lines[#lines+1] = trimmed_line\n      end\n   end\n   return table.concat(lines, \"\\n\")\nen","completion":""}
{"prompt":"-- Calculates the fuel necessary for the provided mass.\nlocal function calculate_fuel(mass)\n  return math.floor(mass \/ 3) - 2\nen","completion":""}
{"prompt":"-- Clamp the value to the the given minimum and maximum.\nlocal function clamp(value, mn, mx)\n  return math.max(math.min(value, mx), mn)\nen","completion":""}
{"prompt":"-- This is a helper function that removes duplicate phonetic breakups\n-- that comes from pronouncing library.\n-- Ex: [['S N OW1'], ['B IY1', 'B IY0']] --> [['S N OW1'], ['B IY1']]\nlocal function removeSyllableDuplicates(syllableList)\n  local i, j, k = 1, 1, 1\n  local tempList = {}\n  while i <= #syllableList do\n    if j <= #syllableList and i ~= j then\n      if #syllableList[i] == #syllableList[j] then\n        local equal = true\n        for k = 1, #syllableList[i] do\n          if syllableList[i][k] ~= syllableList[j][k] then\n            equal = false\n            break\n          end\n        end\n        if equal then\n          i = i + 1\n        end\n      end\n    end\n    tempList[k] = syllableList[i]\n    i = i + 1\n    j = j + 1\n    k = k + 1\n  end\n  return tempList\nen","completion":""}
{"prompt":"-- Strategy for deepmerge that will zip merge two lists. Assumes lists of equal length.\nlocal function zipmerge(the_merger, path, base, nxt)\n  local zipped = {}\n  for i = 1, #base do\n    zipped[i] = the_merger(path..\".[\"..i..\"]\", base[i], nxt[i])\n  end\n  return zipped\nen","completion":""}
{"prompt":"-- Prefix each non-empty line in the given text with the given prefix.\n-- >>> prefix_lines('',' ')\n-- ''\n-- >>> prefix_lines(' ',' ')\n-- '  '\n-- >>> prefix_lines('\\n',' ')\n-- '\\n'\n-- >>> prefix_lines('x',' ')\n-- ' x'\n-- >>> prefix_lines('x\\n',' ')\n-- ' x\\n'\n-- >>> prefix_lines('x\\ny\\n', ' ' )\n-- ' x\\n y\\n'\n-- >>> prefix_lines('x\\ny', ' ' )\n-- ' x\\n y'\nlocal function prefix_lines(text, prefix)\n  local first_line = true\n  return string.gsub(text, '(.-\\n?)', function (line)\n    if first_line then first_line = false; return line end\n    return prefix..line\n  end)\nen","completion":""}
{"prompt":"-- This function computes the sigmoid_derivative of x\nlocal function sigmoid_derivative(x)\n\treturn x * (1 - x)\nen","completion":""}
{"prompt":"-- :param binary: value to extract a bit from\n-- :param n: nth bit to extract (0 indexed)\n-- :return: nth bit from right\nlocal function get_nth_bit_from_right(binary, n)\n  return bit32.band(bit32.rshift(binary, n), 1)\nen","completion":""}
{"prompt":"-- Securely converts a non-numeric value to float.\nlocal function parse_float(n)\n\tlocal float = tonumber(n)\n\tif float == nil then\n\t\tfloat = 0\n\tend\n\treturn float\nen","completion":""}
{"prompt":"-- Write a recursive Python function that returns the sum of the first n integers.\nlocal function exercise2(n)\n\tif n == 0 then return 0\n\telse return n + exercise2(n-1) end\nen","completion":""}
{"prompt":"-- Time interpolation at date 'date' of two arrays with dates \n-- 'date0' (before') and 'date1' (after).\n-- Returns the interpolated array.\nlocal function time_interpolation(array0, array1, date0, date, date1)\n    local ratio = (date - date0) \/ (date1 - date0)\n    return (array0 * (1-ratio) + array1 * ratio)\nen","completion":""}
{"prompt":"-- Convert the given Vantage (0.0-100.0) light level to HASS (0-255).\nlocal function to_hass_level(level)\n  return math.floor((level \/ 100.0) * 255.0)\nen","completion":""}
{"prompt":"-- Paranoid HTML escape method. (Python version independent)\nlocal function escape(text)\n\tif type(text) ~= 'string' then\n\t\treturn ''\n\tend\n\tlocal s = text:gsub('&', '&amp;'):gsub('\"', '&quot;'):gsub('\\'', '&apos;'):gsub('<', '&lt;'):gsub('>', '&gt;')\n\treturn s\nen","completion":""}
{"prompt":"-- This function reverses the bit order for a single byte.\nlocal function swap_bits(original)\n    local swapped = 0\n    for i=0,7 do\n        swapped = swapped + bit32.extract(original, i, 1) * 2^(7-i)\n    end\n    return swapped\nen","completion":""}
{"prompt":"-- Returns the square of the distance between two points.\nlocal function _dsq(x0, y0, x1, y1)\n    local dx = x1 - x0\n    local dy = y1 - y0\n    return dx * dx + dy * dy\nen","completion":""}
{"prompt":"-- Return a new list with x removed from xs\nlocal function listsdelete(x, xs)\n    local ys = {}\n    local found = false\n    for _, v in ipairs(xs) do\n        if not found and v == x then\n            found = true\n        else\n            table.insert(ys, v)\n        end\n    end\n    return ys\nen","completion":""}
{"prompt":"-- Returns the area of a rhombus\nlocal function rhombus_area(diagonal_1, diagonal_2)\n  return diagonal_1 * diagonal_2 \/ 2\nen","completion":""}
{"prompt":"-- Round X to nearest odd integer.\nlocal function round_odd(x)\n    return math.floor(x \/ 2) * 2 + 1\nen","completion":""}
{"prompt":"-- Turn a non-negative integer into a string.\nlocal function int_to_charset(val, charset)\n  if val < 0 then error(\"int_to_charset expected a positive number, got \" .. val) end\n  local len = #charset\n  if val < len then return string.char(charset:byte(val + 1)) end\n  local res = string.char(charset:byte(val % len + 1))\n  val = math.floor(val \/ len)\n  while val > 0 do\n    res = string.char(charset:byte(val % len + 1)) .. res\n    val = math.floor(val \/ len)\n  end\n  return res\nen","completion":""}
{"prompt":"-- Argument parsing and error handling\nlocal function handle_arg(var, alt, error)\n\tif not var or var == \"\" then\n\t\tvar = alt\n\tend\n\tif not var then\n\t\tprint(\"Error: \" .. error)\n\t\treturn os.exit(1)\n\tend\n\treturn var\nen","completion":""}
{"prompt":"-- converts time to number of sample\n-- Args:\n-- time (float): time in seconds to be converted into samples\n-- sample_rate (int): sample rate to use\n-- Returns:\n-- int: sample\nlocal function time2sample(time, sample_rate)\n  local samples = time * sample_rate\n  local sample = math.floor(samples + 0.5)\n  return sample\nen","completion":""}
{"prompt":"-- http:\/\/stackoverflow.com\/questions\/6937525\/escaping-xpath-literal-with-python\nlocal function xpath_literal(s)\n    return \"'\" .. string.gsub(string.gsub(s, \"'\", \"',\\\"'\\\",'\"), \"\\n\", \"'\\n'\") .. \"'\"\nen","completion":""}
{"prompt":"-- Returns determinant of three points\nlocal function determinant(xa, ya, xb, yb, xc, yc)\n  return ((xb - xa) * (yc - ya) - (xc - xa) * (yb - ya))\nen","completion":""}
{"prompt":"-- Modular binary exponentiation.\n-- https:\/\/cp-algorithms.com\/algebra\/binary-exp.html\n-- Parameters\n-- ----------\n-- base: int\n-- exp: int\n-- exponent\n-- mod: int\n-- module\n-- Return\n-- ------\n-- int\n-- (base ** exp) % mod\nlocal function mod_pow(base, exp, mod)\n    base = base % mod\n    local res = 1\n    while exp > 0 do\n        if (exp % 2) == 1 then\n            res = (res * base) % mod\n        end\n        exp = exp \/\/ 2\n        base = (base * base) % mod\n    end\n    return res\nen","completion":""}
{"prompt":"-- Returns the nth triangle number, starting with 1.\n-- The resulting value is also the sum of the first n natural numbers.\nlocal function triangular(n)\n    return n * (n + 1) \/ 2\nen","completion":""}
{"prompt":"-- This function evaluates the quadratic equation\n-- a * x**2 + b*x + c\nlocal function evalQuad(a, b, c, x)\n\treturn (a * x * x) + (b * x) + c\nen","completion":""}
{"prompt":"-- Zig-zag encode a parameter to turn signed ints into unsigned ints.\n-- Zig-zag encoding is required by Geometry commands that require parameters,\n-- and the number of parameters will be (number_of_commands * number_of_arguments).\n-- For more information about this technique, check out:\n-- https:\/\/developers.google.com\/protocol-buffers\/docs\/encoding#types\n-- Args:\n-- value: the integer value to encode\n-- Returns:\n-- The encoded representation of the value.\nlocal function zigzag(value)\n    if value < 0 then\n        return (value * -2) - 1\n    end\n    return value * 2\nen","completion":""}
{"prompt":"-- Convenience function that returns\n-- 1 if next < current,\n-- 0 if next == current,\n-- -1 if next > current\nlocal function change_direction(current, next)\n\tif next < current then\n\t\treturn 1\n\telseif next == current then\n\t\treturn 0\n\telse\n\t\treturn -1\n\tend\nen","completion":""}
{"prompt":"-- Remove invalid characters <>:\"\/\\|?* from the filename.\nlocal function sanitizeFilename(filename)\n\treturn filename:gsub(\"[<>:\\\"\/\\\\|?*]\", \"\")\nen","completion":""}
{"prompt":"-- Estimate mean daily temperature from the daily minimum and maximum\n-- temperatures.\n-- :param tmin: Minimum daily temperature [deg C]\n-- :param tmax: Maximum daily temperature [deg C]\n-- :return: Mean daily temperature [deg C]\n-- :rtype: float\nlocal function daily_mean_t(tmin, tmax)\n   return 0.5 * (tmin + tmax)\nen","completion":""}
{"prompt":"-- Convert time in HTK (100 ns) units to ms\nlocal function htk_to_ms(htk_time)\n   return htk_time \/ 10000;\nen","completion":""}
{"prompt":"-- This is a very slow implementation\n-- the fibonacci sequence because we are generating\n-- a tree recursion, which means a lot of\n-- redundant computations are happening.\nlocal function slow_fib(n)\n    if n < 2 then\n        return n\n    else\n        return slow_fib(n - 1) + slow_fib(n - 2)\n    end\nen","completion":""}
{"prompt":"-- for markdown\nlocal function line_sep_before_code(ls)\n\tlocal r = {}\n\tfor _, l in ipairs(ls) do\n\t\tif l.type == 'code' then\n\t\t\ttable.insert(r, {type = 'line_sep'})\n\t\tend\n\t\ttable.insert(r, l)\n\tend\n\treturn r\nen","completion":""}
{"prompt":"-- replace special characters with html entities\nlocal function replace_special_chars(html_str)\n\treturn html_str:gsub(\"&\", \"&amp;\"):gsub(\"<\", \"&lt;\"):gsub(\">\", \"&gt;\"):gsub(\"'\", \"&#39;\"):gsub('\"', \"&quot;\")\nen","completion":""}
{"prompt":"-- Results structures from nested Gibbs samplers sometimes\n-- need flattening for writing out purposes.\nlocal function flatten_results(results)\n  local flattened_results = {}\n  local function flatten(d)\n    if type(d) == \"table\" then\n      for _, v in pairs(d) do\n        flatten(v)\n      end\n    else\n      flattened_results[#flattened_results+1] = d\n    end\n  end\n  flatten(results)\n  return flattened_results\nen","completion":""}
{"prompt":"-- Inverta a lista\nlocal function ordenamento_contrario(lista)\n    local resultado = {}\n    for i = #lista, 1, -1 do\n        resultado[#resultado + 1] = lista[i]\n    end\n    return resultado\nen","completion":""}
{"prompt":"-- (list) -> float \n-- Sum up the values in a nested numbers list\nlocal function r_sum(nested_num_list)\n    local sum = 0\n    for _, v in ipairs(nested_num_list) do\n        if type(v) == 'table' then\n            sum = sum + r_sum(v)\n        else\n            sum = sum + v\n        end\n    end\n    return sum\nen","completion":""}
{"prompt":"-- Remove the header of the images base64 string from front-end\n-- :param images: the input should be the base64 string of the image\n-- :raises TypeError: if input is not a string\n-- :returns: base64 string without data header\n-- :rtype: string\nlocal function rm_strheader(images)\n  local type = type(images)\n  if type ~= \"string\" then\n    error(\"invalid input, expect string but got: \"..type)\n  end\n  local str_prefix = 'data:image\/png;base64,'\n  if string.sub(images,1,string.len(str_prefix)) == str_prefix then\n    images = string.sub(images,string.len(str_prefix)+1)\n  end\n  return images\nen","completion":""}
{"prompt":"-- Maps Cyberpion severity to Cortex XSOAR severity\n-- Converts the Cyberpion alert severity level (1 to 10, float) to Cortex XSOAR incident severity (1 to 4)\n-- for mapping.\n-- :type severity: ``float``\n-- :param severity: severity as returned from the Cyberpion API (float)\n-- :return: Cortex XSOAR Severity (1 to 4)\n-- :rtype: ``int``\nlocal function convert_to_demisto_severity(severity)\n    if not severity then\n        return 0\n    elseif severity <= 2.5 then\n        return 1\n    elseif severity <= 5 then\n        return 2\n    elseif severity <= 7.5 then\n        return 3\n    else\n        return 4\n    end\nen","completion":""}
{"prompt":"-- Get the next power of 2. (for 64 bit range ints).\n-- 0 is a special case, to have non-empty defaults.\n-- Examples:\n-- 0 -> 1, 1 -> 1, 2 -> 2, 3 -> 4, 32 -> 32, 33 -> 64\nlocal function next_power_of_two(v)\n    if v <= 0 then return 1 end\n    local p = 1\n    while p < v do\n        p = p * 2\n    end\n    return p\nen","completion":""}
{"prompt":"-- Return x clipped to the range [lowest..highest].\nlocal function clip(x, lowest, highest)\n    return math.max(math.min(x, highest), lowest)\nen","completion":""}
{"prompt":"-- Convert an OS dependent library name to the base name::\n-- libfoo.so.0.1 => foo\n-- foo.dll       => foo\nlocal function lib2name(lib)\n\treturn lib:match(\"([^%.]*).*\")\nen","completion":""}
{"prompt":"-- Accelerate until halfway, then decelerate.\nlocal function cubic_ease_in_ease_out(t, b, c, d)\n\tt = t \/ d * 2\n\tif t < 1 then\n\t\treturn c \/ 2 * t^3 + b\n\tend\n\tt = t - 2\n\treturn c \/ 2 * (t^3 + 2) + b\nen","completion":""}
{"prompt":"-- :param coords: list of lists or tuples [(lon1, lat1), ...(lonN, latN)]\n-- :return: dict {lat: xxx, lon: yyy}\nlocal function avg_coords_list(coords)\n  local sum_lat = 0.0\n  local sum_lon = 0.0\n  for _,coord in pairs(coords) do\n    sum_lat = sum_lat + coord[2]\n    sum_lon = sum_lon + coord[1]\n  end\n  local avg_lat = sum_lat \/ #coords\n  local avg_lon = sum_lon \/ #coords\n  return {lat = avg_lat, lon = avg_lon}\nen","completion":""}
{"prompt":"-- Returns list of list of ints\nlocal function format_lines(text)\n  local out = {}\n  for line in text:gmatch(\"[^\\r\\n]+\") do\n    local l = {}\n    for num in line:gmatch(\"%d+\") do\n      l[#l+1] = tonumber(num)\n    end\n    out[#out+1] = l\n  end\n  return out\nen","completion":""}
{"prompt":"-- 3 floats to #rrggbb\nlocal function formatColor3f(r, g, b)\n\tlocal rr = math.floor(r * 255 + 0.5)\n\tlocal gg = math.floor(g * 255 + 0.5)\n\tlocal bb = math.floor(b * 255 + 0.5)\n\tlocal str = string.format(\"#%02x%02x%02x\", rr, gg, bb)\n\treturn str\nen","completion":""}
{"prompt":"-- Return the n^th least significant bit of val.\nlocal function bittest(val, n)\n\treturn bit32.band(bit32.rshift(val, n), 1)\nen","completion":""}
{"prompt":"-- Helper function to emulate numpy.clip for the specific\n-- use case of preventing math domain errors on the \n-- acos function by \"clipping\" values that are > abs(1).\n-- e.g. _clip(1.001) == 1\n-- _clip(-1.5) == -1\n-- _clip(0.80) == 0.80\nlocal function _clip(n)\n    if n >= 0 then\n        return math.min(n,1)\n    else\n        return math.max(n,-1)\n    end\nen","completion":""}
{"prompt":"-- Convert a section header name (\"CMP 0\" in DipTrace)\n-- to an identifier (e.g. 0)\nlocal function component_name_to_id(name)\n    if name:sub(1, 3) == \"CMP\" then\n        return tonumber(name:sub(4, -1))\n    else\n        return name\n    end\nen","completion":""}
{"prompt":"-- Returns the max subarray of the given list of numbers.\n-- Returns 0 if  nums is None or an empty list.\n-- Time Complexity: ?\n-- Space Complexity: ?\nlocal function max_sub_array(nums)\n  if nums == nil or #nums == 0 then return 0 end\n  local max = nums[1]\n  local cur = max\n  local i = 2\n  while i <= #nums do\n    cur = math.max(nums[i], cur + nums[i])\n    max = math.max(cur, max)\n    i = i + 1\n  end\n  return max\nen","completion":""}
{"prompt":"-- Add id to root, e.g.,root={'name': 'Module', 'children': [{'name': 'Import', 'children': [{'name': 'sss'}]}]}\n-- this function will change root to {'name': 'Module', 'id':1,'children': [{'name': 'Import', 'id':2,'children': [{'name': 'sss','id':3}]}]}\nlocal function add_node_id(root, id)\n    local next_id = id\n    if root and type(root) == 'table' then\n        root.id = next_id\n        next_id = next_id + 1\n        if root.children then\n            for _, child in ipairs(root.children) do\n                next_id = add_node_id(child, next_id)\n            end\n        end\n    end\n    return next_id\nen","completion":""}
{"prompt":"-- Converts a given object to a tuple object\n-- If the object is a tuple, the function returns the input,\n-- otherwise creates a single dimensional tuple\n-- Parameters\n-- ----------\n-- obj : Object\n-- Object that is converted to a tuple\n-- Returns\n-- -------\n-- t : tuple\n-- Tuple that includes the original object\nlocal function pack_to_tuple(obj)\n    if type(obj) == \"table\" then\n        return obj\n    end\n    return {obj}\nen","completion":""}
{"prompt":"-- Converts temperature in Kelvin to Celsius\nlocal function to_celsius(temp)\n\ttemp = temp - 273.15\n\treturn math.floor(temp + 0.5)\nen","completion":""}
{"prompt":"-- Replace any periods in a string with blank spaces\nlocal function replacePeriod(x)\n  return x:gsub('%.', '')\nen","completion":""}
{"prompt":"-- Convert time in this format hhmm into minutes passed sind 0000\n-- 0830->510\n-- 1345->825\nlocal function time_to_min(time)\n\tlocal hour = math.floor(time\/100)\n\tlocal min = time-hour*100\n\treturn hour*60 + min\nen","completion":""}
{"prompt":"-- return number of days in the month\nlocal function daysInMonth(month, year)\n    local days = 0\n    if month == 2 then\n        if (year % 4 == 0 and year % 100 ~= 0) or year % 400 == 0 then\n            days = 29\n        else\n            days = 28\n        end\n    elseif month == 4 or month == 6 or month == 9 or month == 11 then\n        days = 30\n    else\n        days = 31\n    end\n    return days\nen","completion":""}
{"prompt":"-- Take yaourt -Qi or yaourt -Si output and get the Version\nlocal function get_version(yaourt_output)\n  local version = \"nil\"\n  local version_pattern = '^Version%s*:%s*(.*)$'\n  for line in yaourt_output:gmatch(\"[^\\n]+\") do\n    local match = line:match(version_pattern)\n    if match then\n      version = match\n      break\n    end\n  end\n  return version\nen","completion":""}
{"prompt":"-- This function takes two vectors, a and b, and finds the dot\n-- product,c.\nlocal function dot_prod(a, b)\n\tlocal sum = 0\n\tfor i = 1, #a do\n\t\tsum = sum + a[i] * b[i]\n\tend\n\treturn sum\nen","completion":""}
{"prompt":"-- Encases addresses in [ ] per RFC 2732.  Generally used to deal with ':'\n-- characters which are also often used as delimiters.\n-- Returns the addr string if it doesn't contain any ':' characters.\n-- If addr contains ':' and also contains a '[' then the addr string is\n-- simply returned under the assumption that it is already escaped as needed.\n-- Otherwise return a new string from addr by adding '[' prefix and ']' suffix.\n-- Examples\n-- --------\n-- >>> canonicalize_address('myhost')\n-- 'myhost'\n-- >>> canonicalize_address('127.0.0.1')\n-- '127.0.0.1'\n-- >>> canonicalize_address('::1')\n-- '[::1]'\n-- >>> canonicalize_address('[::1]')\n-- '[::1]'\n-- >>> canonicalize_address('2620:0:170:610::13')\n-- '[2620:0:170:610::13]'\n-- >>> canonicalize_address('[2620:0:170:610::13]')\n-- '[2620:0:170:610::13]'\n-- @param addr: the address to possibly encase in [ ]\n-- @returns:    the address, encased in [] if necessary\nlocal function canonicalize_address(addr)\n  local len = #addr\n  if addr:find(\":\") then\n    -- addr contains a ':'\n    if addr:find(\"[\", 1, true) then\n      -- addr contains a '[' already\n      return addr\n    else\n      -- addr contains a ':' but no '['\n      return \"[\" .. addr .. \"]\"\n    end\n  else\n    -- addr contains no ':'\n    return addr\n  end\nen","completion":""}
{"prompt":"-- returns documentation for the current api\nlocal function documentation(default, api_version, api)\n  if api_version then\n    default = default[api_version] or default[\"latest\"]\n  end\n  if api then\n    default = default[api] or default[\"latest\"]\n  end\n  return default\nen","completion":""}
{"prompt":"-- Given a list or a value transforms it to a list\n-- Arguments:\n-- list_or_value (str or list): List or a value\n-- Returns:\n-- A list\nlocal function listify(list_or_value)\n  if type(list_or_value) == \"table\" then\n    return list_or_value\n  else\n    return {list_or_value}\n  end\nen","completion":""}
{"prompt":"-- Returns the SQL representation of the given string,\n-- by escaping all single-quotes with two single-quotes\n-- and surrounding the string with single-quotes.\nlocal function escape(string)\n    return \"'\" .. string:gsub(\"'\", \"''\") .. \"'\"\nen","completion":""}
{"prompt":"-- \nlocal function transform_genres(genres)\n\tif not genres then\n\t\treturn nil\n\tend\n\t\n\tlocal transformed = {}\n\tfor i,v in ipairs(genres) do\n\t\tif v then\n\t\t\ttransformed[#transformed+1] = v.name\n\t\tend\n\tend\n\t\n\treturn transformed\nen","completion":""}
{"prompt":"-- Build a JSON response\n-- Args:\n-- rpc_id (int): The request id \n-- result : Json serializable data\n-- Returns:\n-- dict the json_rpc success response as dict\nlocal function _build_response(rpc_id, result)\n  return {\n    jsonrpc = \"2.0\",\n    id = rpc_id,\n    result = result,\n  }\nen","completion":""}
{"prompt":"-- Get continued fraction representation of a\/b.\nlocal function continued_fraction(a, b)\n    local terms = {}\n    while a ~= 0 and b ~= 0 do\n        terms[#terms + 1] = a \/\/ b\n        a, b = b, a % b\n    end\n    return terms\nen","completion":""}
{"prompt":"-- Searches the list of keyval pairs for a matching key. If found, associates the value with the key. Otherwise, appends the key\/val pair to the list. Returns the updated keyval list.\nlocal function assoc(keyvals, key, val)\n    for i, keyval in ipairs(keyvals) do\n        if keyval[1] == key then\n            keyval[2] = val\n            return keyvals\n        end\n    end\n    table.insert(keyvals, {key, val})\n    return keyvals\nen","completion":""}
{"prompt":"-- Return the lowest x such that x is at least the number\n-- and x modulo divisor == 0\nlocal function round_to_next_multiple_of(number, divisor)\n\tlocal mod = number % divisor\n\tif mod == 0 then\n\t\treturn number\n\telse\n\t\treturn number + (divisor - mod)\n\tend\nen","completion":""}
{"prompt":"-- Sums all multiples of 3 and 5 under `limit`\n-- Args:\n-- limit (int): The limit that the sums will be calculated up to\n-- Returns:\n-- int : The sum of all multiples of 3 and 5 up to `limit`\nlocal function sum_multiples(limit)\n    local result = 0\n    for i = 1, limit - 1 do\n        if i % 3 == 0 or i % 5 == 0 then\n            result = result + i\n        end\n    end\n    return result\nen","completion":""}
{"prompt":"-- Slope between the two points only if the pixel is higher\n-- than the other\n-- 20150603 Scott Havens\nlocal function _slope(xi, zi, xj, zj)\n  if zi < zj then\n    return (zj - zi) \/ (xj - xi)\n  else\n    return 0\n  end\nen","completion":""}
{"prompt":"-- repeat last item in listin, until len(listin) = numfields\nlocal function _repeatlast(numfields, listin)\n    local repeatlist = {}\n    for i, field in ipairs(listin) do\n        repeatlist[i] = field\n    end\n    while #repeatlist < numfields do\n        repeatlist[#repeatlist + 1] = repeatlist[#repeatlist]\n    end\n    return repeatlist\nen","completion":""}
{"prompt":"-- Assigns score to document based on multiplication of probabilities. Probability is token frequency devided by length of document.\n-- In this metric only documents containing all query words have positive probability.\n-- Args:\n-- probability (float): Previously calculated probability.\n-- token_frequency (float):  Number of appearances of token in text.\n-- n (int): Length of text.\n-- Returns:\n-- probability_value (float): New caclculated probability.\nlocal function probability_multiply(probability, token_frequency, n)\n    return probability * token_frequency\/n\nen","completion":""}
{"prompt":"-- Turns '-' into '_' for accumulo table names\nlocal function sanitize(string)\n\treturn string.gsub(string, '-', '_')\nen","completion":""}
{"prompt":"-- Returns the nth square number.\nlocal function squareNum(n)\n\treturn n * n\nen","completion":""}
{"prompt":"-- Calculate the Levenshtein distance between two normalised strings\n-- Adopted from example in https:\/\/stackoverflow.com\/questions\/2460177\/edit-distance-in-python\n-- See https:\/\/en.wikipedia.org\/wiki\/Edit_distance\n-- @param s1: the first string to compare\n-- @param s2: the second string to compare\n-- @returns: an integer giving the edit distance\nlocal function get_edit_distance(s1, s2)\n    local len1 = string.len(s1)\n    local len2 = string.len(s2)\n    local arr = {}\n    for i = 0, len1 do\n        arr[i] = {}\n        for j = 0, len2 do\n            if i == 0 then arr[i][j] = j end\n            if j == 0 then arr[i][j] = i end\n        end\n    end\n    for i = 1, len1 do\n        for j = 1, len2 do\n            if s1:byte(i) == s2:byte(j) then\n                arr[i][j] = arr[i-1][j-1]\n            else\n                arr[i][j] = math.min(arr[i-1][j-1] + 1, math.min(arr[i-1][j] + 1, arr[i][j-1] + 1))\n            end\n        end\n    end\n    return arr[len1][len2]\nen","completion":""}
{"prompt":"-- POSIX is stupid so these are reversed.\nlocal function reverse_gmt(timezone)\n\tlocal gmt = timezone:match(\"%((%d%d?%d?%d)%)\")\n\tif not gmt then\n\t\treturn timezone\n\tend\n\tlocal sign = timezone:match(\"([-+])\")\n\tlocal offset = 0\n\tfor sign2, h, m in gmt:gmatch(\"([-+])(%d?%d)(%d?%d)\") do\n\t\toffset = offset * 60 + tonumber(h) * 60 + tonumber(m)\n\tend\n\treturn sign == \"-\" and \"-\"..(offset * -1) or \"+\"..offset\nen","completion":""}
{"prompt":"-- nxm array with labeled coordinates ... pretty superfluous\nlocal function make_grid(n, m)\n  local grid = {}\n  for i = 0, n do\n    local row = {}\n    for j = 0, m do\n      table.insert(row, {i,j})\n    end\n    table.insert(grid, row)\n  end\n  return grid\nen","completion":""}
{"prompt":"-- remove overlapped spans greedily for flat-ner\n-- Args:\n-- spans: list of tuple (start, end), which means [start, end] is a ner-span\n-- Returns:\n-- spans without overlap\nlocal function remove_overlap(spans)\n    local res = {}\n    table.sort(spans, function(a, b)\n        return a[1] < b[1]\n    end)\n    local cur = spans[1]\n    for i = 2, #spans do\n        if spans[i][1] <= cur[2] then\n            -- overlapped, merge span\n            if spans[i][2] > cur[2] then\n                cur[2] = spans[i][2]\n            end\n        else\n            table.insert(res, cur)\n            cur = spans[i]\n        end\n    end\n    table.insert(res, cur)\n    return res\nen","completion":""}
{"prompt":"-- Return a string or blank for None.\nlocal function str_or_blank(val)\n    return (val ~= nil) and tostring(val) or ''\nen","completion":""}
{"prompt":"-- Swap bytes in 32 bit integer.\nlocal function swap32(x) return ((x & 0xff000000) >> 24) | ((x & 0xff0000) >> 8) | ((x & 0xff00) << 8) | ((x & 0xff) << 24) en","completion":""}
{"prompt":"-- This function converts fahrenheit to celsius, with fahrenheit as parameter.\nlocal function fartocels(fahrenheit)\n\tlocal celcius = (fahrenheit - 32) * 5 \/ 9\n\treturn celcius\nen","completion":""}
{"prompt":"-- Returns the area of a triangle\nlocal function triangle_area(base, height)\n  return 0.5 * base * height\nen","completion":""}
{"prompt":"-- Finds the 'svg' layer associated with a specific master ID\n-- Arguments:\n-- layers {arr} -- array of GSLayers of a glyph\n-- masterId {str} -- unique ID of master\n-- Returns: layer object\nlocal function findSvgLayer(layers, masterId)\n\tfor i,v in ipairs(layers) do\n\t\tif v:master() and v:master().id == masterId then\n\t\t\treturn v\n\t\tend\n\tend\n\treturn nil\nen","completion":""}
{"prompt":"-- Make sure 'parameter' is a list.\nlocal function get_as_list(parameter)\n\tif type(parameter) == \"table\" then\n\t\treturn parameter\n\telse\n\t\treturn { parameter }\n\tend\nen","completion":""}
{"prompt":"-- Returns the rectangles corresponding to the faces detected by Azure\n-- :param azure_response: Response from Azure Face request as dictionary.\n-- :return: The rectangles of any detected face with the format: (width, height, left, top)\nlocal function get_face_rectangles(azure_response)\n\tif azure_response == nil then\n\t\treturn {}\n\tend\n\tlocal rectangles = {}\n\tif azure_response['faces'] ~= nil then\n\t\tfor _, face in pairs(azure_response['faces']) do\n\t\t\ttable.insert(rectangles, {face['faceRectangle']['width'], face['faceRectangle']['height'], face['faceRectangle']['left'], face['faceRectangle']['top']})\n\t\tend\n\tend\n\treturn rectangles\nen","completion":""}
{"prompt":"-- Convert a string to a list.\n-- An input \"a,b,c\" would be converted to ['a', 'b', 'c'].\n-- Commas separate different entries.\n-- Type conversion is not done.\nlocal function str2list(s)\n   s = string.gsub(s, \"%s+\", \"\")  -- remove all whitespace characters\n   local arr = {}\n   for elem in string.gmatch(s, \"([^,]+)\") do\n      table.insert(arr, elem)\n   end\n   return arr\nen","completion":""}
{"prompt":"-- Convert a time in seconds to a mm:ss string\nlocal function seconds_to_string(duration)\n  if not duration then\n    return '00:00'\n  end\n  local seconds = math.floor(duration % 60)\n  local minutes = math.floor(duration \/ 60)\n  return string.format('%02d:%02d', minutes, seconds)\nen","completion":""}
{"prompt":"-- Fibonacci series by bottom-up dynamic programming.\n-- - Time complexity: O(n).\n-- - Space complexity: O(n).\nlocal function fibonacci_dp(n)\n  local dp = {}\n  dp[1] = 1\n  dp[2] = 1\n  for i = 3, n do\n    dp[i] = dp[i - 1] + dp[i - 2]\n  end\n  return dp[n]\nen","completion":""}
{"prompt":"-- Calculate the integrated area of the Gaussian function.\n-- area_gauss = amp * fwhm \/ ((1. \/ np.sqrt(2*np.pi)) * 2*np.sqrt(2*np.log(2)))\n-- combining all constants in the denominator yields a factor of 0.93943727869965132\n-- Parameters\n-- ----------\n-- amp : float\n-- Amplitude value of the Gaussian component.\n-- fwhm : float\n-- FWHM value of the Gaussian component.\nlocal function area_of_gaussian(amp, fwhm)\n    local area = amp * (0.93943727869965132 * (fwhm * fwhm))\n    return area\nen","completion":""}
{"prompt":"-- Calculate the maximum power dissipation in Rload.\nlocal function calc_rload_power(i_out_max, r_load)\n\treturn i_out_max^2 * r_load\nen","completion":""}
{"prompt":"-- da Is 80% Of Basic Salary\nlocal function da(basic)\n    return basic * 0.80\nen","completion":""}
{"prompt":"-- Parabola\n-- Args:\n-- t (numpy.array): [description]\n-- D ([type]): [description]\n-- V ([type]): [description]\n-- Returns:\n-- [type]: [description]\nlocal function parabola_function(t, D, V)\n  return V + (D*t)\nen","completion":""}
{"prompt":"-- Given a number of bytes, determines the correct suffix and formats it\n-- Args:\n-- num (float): The number of bytes\n-- divisor (int, optional): The cutoff before the next suffix is used\n-- Returns:\n-- str: `num` formatted with a suffix\n-- Examples:\n-- >>> pretty_size(1023)\n-- '1023.0bytes'\n-- >>> pretty_size(1024)\n-- '1.0KB'\n-- >>> pretty_size(5368709120)\n-- '5.0GB'\n-- >>> pretty_size(5368709120, 100.0)\n-- '53.7TB'\n-- >>> pretty_size(-5368709120, 100.0)\n-- '-53.7TB'\nlocal function pretty_size(num, divisor)\n\tlocal suffixes = {'bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'}\n\tlocal suffix = 1\n\tif type(num) == 'number' and num >= 0 then\n\t\tif divisor == nil then\n\t\t\tdivisor = 1024\n\t\tend\n\t\twhile num >= divisor and suffix < #suffixes do\n\t\t\tnum = num \/ divisor\n\t\t\tsuffix = suffix + 1\n\t\tend\n\t\treturn string.format('%.1f%s', num, suffixes[suffix])\n\telse\n\t\treturn '-'..pretty_size(-num, divisor)\n\tend\nen","completion":""}
{"prompt":"-- Return a result for operation between num1 and num2\n-- Examples and Doctest :\n-- >>> calc(2, \"+\", 3)\n-- 5\n-- >>> calc(2, \"-\", 3)\n-- -1\n-- >>> calc(2, \"*\", 3)\n-- 6\n-- >>> calc(2, \"\/\", 2)\n-- 1.0\nlocal function calc(num1, op, num2)\n    if op == \"+\" then\n        return num1 + num2\n    elseif op == \"-\" then\n        return num1 - num2\n    elseif op == \"*\" then\n        return num1 * num2\n    elseif op == \"\/\" then\n        return num1 \/ num2\n    end\nen","completion":""}
{"prompt":"-- Verifies if the supplied column and increment are valid.\nlocal function verify_integer(parser, arg, htzero)\n    if arg == nil or arg == \"\" then return 0 end\n    local n = tonumber(arg)\n    if n == nil then\n        parser:error(\"invalid value '\" .. arg .. \"' for option \" .. parser.options.name)\n    end\n    if htzero and n < 0 then\n        parser:error(\"invalid value '\" .. arg .. \"' for option \" .. parser.options.name .. \": value cannot be negative\")\n    end\n    return n\nen","completion":""}
{"prompt":"-- Return a^-1 mod m (modular inverse)\nlocal function mod_inverse(a, m)\n\tlocal t = 0\n\tlocal newt = 1\n\tlocal r = m\n\tlocal newr = a\n\twhile newr ~= 0 do\n\t\tlocal q = math.floor(r \/ newr)\n\t\tlocal tmp = newt\n\t\tnewt = t - q * newt\n\t\tt = tmp\n\t\ttmp = newr\n\t\tnewr = r - q * newr\n\t\tr = tmp\n\tend\n\tif r > 1 then\n\t\treturn nil -- no inverse\n\tend\n\tif t < 0 then\n\t\tt = t + m\n\tend\n\treturn t\nen","completion":""}
{"prompt":"-- Group rows by variable id.\n-- @return a dict where\n-- key = variable id\n-- value = list of matching rows\nlocal function make_dict_from_sheet(spreadsheet)\n    local dict = {}\n    for i, row in ipairs(spreadsheet) do\n        local key = row[1]\n        if key ~= nil then\n            if dict[key] == nil then\n                dict[key] = {}\n            end\n            table.insert(dict[key], row)\n        end\n    end\n    return dict\nen","completion":""}
{"prompt":"-- Strip ^ and $ from pattern begining and end.\n-- According to http:\/\/www.w3.org\/TR\/xmlschema-0\/#regexAppendix XMLSchema\n-- expression language does not contain the metacharacters ^ and $.\n-- :returns: stripped pattern string\nlocal function strip_regex_metachars(pattern)\n\treturn pattern:gsub(\"^%^\", \"\"):gsub(\"%$$\", \"\")\nen","completion":""}
{"prompt":"-- The fibonacci numbers are [0, 1, 1, 2, 3, 5, 8, 13, ....]. Except the first 2\n-- terms in this sequence, every term = the sum of the 2 previous terms, for example\n-- 13 = 8 + 5.\n-- In this algorithm, we store the results we obtain in order not to compute them again\n-- this technique is called dynamic programming\n-- this algorithm works in O(n).\n-- This solution is much faster than the solution that uses divide and conquer technique\n-- (which you can view in 'Divide & Conquer' folder). That algorithm works roughly in O(2 ^ n)\nlocal function fib(n)\n    if n == 0 then\n        return 0\n    elseif n == 1 then\n        return 1\n    else\n        return fib(n - 1) + fib(n - 2)\n    end\nen","completion":""}
{"prompt":"-- Replace dashes with spaces.\n-- Parameters\n-- ----------\n-- s : str\n-- String that may contain \"-\" characters.\nlocal function unkebab(s)\n  return s:gsub(\"-\", \" \")\nen","completion":""}
{"prompt":"-- Replace all 'id' in data by '@id'.\n-- It seems that connexion converts '@id' to 'id'. \n-- To make thing consistent for further processing, we revert this.\n-- This function can handle all kind of input data (full factoids but also single sources etc.)\nlocal function fix_ids(data)\n  local new_data = {}\n  for i, v in pairs(data) do\n    if i == \"id\" then\n      new_data[\"@id\"] = v\n      new_data[\"id\"] = nil\n    elseif type(v) == \"table\" then\n      new_data[i] = fix_ids(v)\n    else\n      new_data[i] = v\n    end\n  end\n  return new_data\nen","completion":""}
{"prompt":"-- Escapes HTML characters in the given message.\nlocal function escape_html(message)\n  return message:gsub(\"[<>&]\", {\n    ['<'] = \"&lt;\",\n    ['>'] = \"&gt;\",\n    ['&'] = \"&amp;\",\n  })\nen","completion":""}
{"prompt":"-- Convert to int or float if possible, otherwise return string\nlocal function _autoconvert(value)\n  local nvalue = tonumber(value)\n  if nvalue == nil then\n    return value\n  else\n    return nvalue\n  end\nen","completion":""}
{"prompt":"-- Take a list of element node indexes deliminated by -1 and convert\n-- it into a list element node indexes list.\nlocal function _convertToElementList(elements_list)\n  local elements = {}\n  local idx = 1\n  for i = 1, #elements_list do\n    if elements_list[i] == -1 then\n      elements[idx] = {}\n      idx = idx + 1\n    else\n      elements[idx] = elements_list[i]\n    end\n  end\n  return elements\nen","completion":""}
{"prompt":"-- Function to parse the json response from the references_plus collection\n-- in Solr (which is being built using this program). It returns the num_results\n-- only. As the same annotation is present in multiple refs files, we want to only\n-- search for it once in the papers index (we add everything in this one time). So,\n-- searching again will result in duplicate values getting inserted. So this returns 0 if\n-- it is indeed a new record, a number greater than 0 (num_responses) otherwise\nlocal function parse_references_plus_json(data)\n  local num_results = data.response.numFound\n  return num_results\nen","completion":""}
{"prompt":"-- Return node ID of node with smallest _ID identifier.\n-- :param nodes: graph 'nodes' object\n-- :return:      node ID\nlocal function initial_node(nodes)\n  local min_id = 0\n  local min_node = nil\n  for node_id, node in pairs(nodes) do\n    if not node.visited then\n      if not min_node or node._id < min_id then\n        min_node = node_id\n        min_id = node._id\n      end\n    end\n  end\n  return min_node\nen","completion":""}
{"prompt":"-- Some doc\nlocal function fib(n)\n  if n < 2 then return 1 else return fib(n - 1) + fib(n - 2) end\nen","completion":""}
{"prompt":"-- Convert the given Lutron (0-100) light level to Home Assistant (0-255).\nlocal function to_hass_level(level)\n  return math.floor(level \/ 100 * 255)\nen","completion":""}
{"prompt":"-- Clips value to range <minimal, maximal>\n-- :param value: ? - value\n-- :param minimal: ? - minimal value\n-- :param maximal: ? - maximal value\n-- :return: ? - clipped value\nlocal function clip(value, minimal, maximal)\n\treturn math.min(maximal, math.max(minimal, value))\nen","completion":""}
{"prompt":"-- A  method to determine the maximum value of the items included in the\n-- knapsack without exceeding the capacity  C\n-- Args:\n-- capacity(int): full capacity of the bag can fit\n-- items(tuple of tuples): items with its capacity and value\n-- n(int): number of items, bag can have\n-- Returns:\n-- Max value(int) :\nlocal function knapsack(capacity, items, n)\n  if capacity == 0 or n == 0 then\n    return 0\n  end\n  if items[n][2] > capacity then\n    return knapsack(capacity, items, n - 1)\n  else\n    return math.max(\n      knapsack(capacity, items, n - 1),\n      knapsack(capacity - items[n][2], items, n - 1) + items[n][3])\n  end\nen","completion":""}
{"prompt":"-- Bounce out. Amplitude of bounce decreases.\nlocal function bounce_out(t)\n\tif t < (1 \/ 2.75) then\n\t\treturn (7.5625 * t * t)\n\telseif t < (2 \/ 2.75) then\n\t\tt = t - (1.5 \/ 2.75)\n\t\treturn (7.5625 * t * t + 0.75)\n\telseif t < (2.5 \/ 2.75) then\n\t\tt = t - (2.25 \/ 2.75)\n\t\treturn (7.5625 * t * t + 0.9375)\n\telse\n\t\tt = t - (2.625 \/ 2.75)\n\t\treturn (7.5625 * t * t + 0.984375)\n\tend\nen","completion":""}
{"prompt":"-- Change a sentence in to lowercase and remove punctuation\n-- :param str_in (str): the process sentence\n-- :return: str: the processed sentence\nlocal function string_process(str_in)\n  str_in = string.lower(str_in)\n  -- remove all non-alphanumeric characters\n  str_in = string.gsub(str_in, \"%W\", \" \")\n  -- remove all white spaces\n  str_in = string.gsub(str_in, \"%s+\", \" \")\n  -- trim leading and trailing whitespace\n  str_in = string.gsub(str_in, \"^%s*(.-)%s*$\", \"%1\")\n  return str_in\nen","completion":""}
{"prompt":"-- Return the nth line in Pascal's triangle.\nlocal function pascal_triangle(n)\n  local row = {1}\n  for i = 1, n - 1 do\n    local prev = row\n    row = {1}\n    for j = 1, #prev - 1 do\n      row[#row+1] = prev[j] + prev[j+1]\n    end\n    row[#row+1] = 1\n  end\n  return row\nen","completion":""}
{"prompt":"-- Converts h parameters into Z-parameters. h-parameters should be in the form [[f,h11,h12,h21,h22],...]\n-- Returns data in the form\n-- [[f,Z11,Z12,Z21,Z22],...]\nlocal function HFrequencyList_to_ZFrequencyList(h_frequency_list)\n\tlocal Z_frequency_list = {}\n\tfor i,h in ipairs(h_frequency_list) do\n\t\tlocal f = h[1]\n\t\tlocal Z11 = h[2]\n\t\tlocal Z12 = h[3]\n\t\tlocal Z21 = h[4]\n\t\tlocal Z22 = h[5]\n\t\ttable.insert(Z_frequency_list, {f,Z11,Z12,Z21,Z22})\n\tend\n\treturn Z_frequency_list\nen","completion":""}
{"prompt":"-- Returns a list with the 8 neighbor positions of (x, y)\nlocal function get_neighbors(x, y)\n\treturn {\n\t\t{x, y-1}, -- up\n\t\t{x, y+1}, -- down\n\t\t{x-1, y}, -- left\n\t\t{x+1, y}, -- right\n\t\t{x-1, y-1}, -- up left\n\t\t{x+1, y-1}, -- up right\n\t\t{x-1, y+1}, -- down left\n\t\t{x+1, y+1}, -- down right\n\t}\nen","completion":""}
{"prompt":"-- map with high and low bound handling.\nlocal function map_bound(value, in_low, in_high, out_low, out_high)\n  local v = value\n  if v <= in_low then\n    return out_low\n  elseif v >= in_high then\n    return out_high\n  else\n    return out_low + (out_high - out_low) * ((v - in_low) \/ (in_high - in_low))\n  end\nen","completion":""}
{"prompt":"-- Return the maximum angular momentum based on the input atomic charge.\n-- This function is designed to return LMAX in a CPMD input file.\n-- Args:\n-- charge (int): Atomic charge.\n-- Returns:\n-- 'S' for H or He; 'P' for second row elements; and 'D' for heavier elements.\nlocal function get_lmax_from_atomic_charge(charge)\n    if charge == 1 or charge == 2 then\n        return 'S'\n    elseif charge > 2 and charge < 11 then\n        return 'P'\n    else\n        return 'D'\n    end\nen","completion":""}
{"prompt":"-- If for some reason the matplotlib backend doesn't visualize your mouse position replace ax.format_coord with \n-- this function. According to the internet this should fix the problem anyway.\n-- Code modifed from user tacaswell on Stack Overflow post:\n-- https:\/\/stackoverflow.com\/questions\/15876011\/add-information-to-matplotlib-navigation-toolbar-status-bar\nlocal function format_coord(x, y)\n  local ix, iy = math.floor(x + 0.5), math.floor(y + 0.5)\n  local value = string.format(\"x=%1.4f, y=%1.4f\", x, y)\n  return value, ix, iy\nen","completion":""}
{"prompt":"-- Transform data in dB scale into amplitude\n-- A gain (db_gain) could be added at the end.    \n-- Parameters\n-- ----------\n-- x : array-like or scalar\n-- data in dB to rescale in amplitude \n-- db_gain : scalar, optional, default is 0\n-- Gain that was added to the result \n-- --> 20*log10(x) + db_gain\n-- Returns\n-- -------\n-- y : array-like or scalar\n-- output in amplitude unit\n-- Examples\n-- --------\n-- >>> a = np.array([ 0.        ,  6.02059991,  9.54242509, 12.04119983, 13.97940009])\n-- >>> maad.util.dB2amplitude(a)\n-- array([1., 2., 3., 4., 5.])\nlocal function dB2amplitude(x, db_gain)\n  -- 20*log10(x)\n  if db_gain == nil then db_gain = 0 end\n  return 10.0^(x\/10.0+db_gain\/20.0)\nen","completion":""}
{"prompt":"-- intToDigit :: int -> str\n-- Convert an Int in the range 0..15 to the corresponding single digit Char.\n-- This function fails on other inputs, and generates lower-case hexadecimal\n-- digits.\nlocal function intToDigit(s)\n\tif (s < 0 or s > 15) then\n\t\treturn nil\n\tend\n\tif (s < 10) then\n\t\treturn string.format('%d', s)\n\tend\n\treturn string.format('%c', s-10 + string.byte('a'))\nen","completion":""}
{"prompt":"-- set telegram client configuration.\nlocal function telegram_settings()\n    local settings = {}\n    settings.api_id = tonumber(os.getenv(\"TG_API_ID\"))\n    settings.api_hash = os.getenv(\"TG_API_HASH\")\n    settings.bot_token = os.getenv(\"TG_BOT_TOKEN\")\n    if not settings.api_id then\n        print(\"API_ID is missing!\")\n        os.exit()\n    end\n    if not settings.api_hash then\n        print(\"API_HASH is missing!\")\n        os.exit()\n    end\n    if not settings.bot_token then\n        print(\"BOT_TOKEN is missing!\")\n        os.exit()\n    end\n    return settings\nen","completion":""}
{"prompt":"-- Computes the Fibonacci sequence at point v.\nlocal function fibonacci_py(v)\n  if v == 0 then\n    return 0\n  elseif v == 1 then\n    return 1\n  else\n    return fibonacci_py(v - 1) + fibonacci_py(v - 2)\n  end\nen","completion":""}
{"prompt":"-- Converts string to int, float or leaves  it as a string\n-- :param x:\n-- :return:\nlocal function convert(x)\n  if x == \"\" then return x end\n  local x2 = tonumber(x)\n  if x2 then\n    return x2\n  end\n  return x\nen","completion":""}
{"prompt":"-- z_score\nlocal function z_score(x, mean, std)\n\tif std ~= 0 then\n\t\tlocal ret = (x - mean) \/ std\n\t\treturn ret\n\telse\n\t\treturn x\n\tend\nen","completion":""}
{"prompt":"-- return the absolute value of the difference between x and y\n-- >>> absolute_difference(3, 5)\n-- 2\n-- >>> absolute_difference(10, 7)\n-- 3\nlocal function absolute_difference(x, y)\n  return math.abs(x - y)\nen","completion":""}
{"prompt":"-- Replace flags with parameter names.\n-- This is a simple operation where we replace the command line flags\n-- with the attribute names.\n-- Parameters\n-- ----------\n-- rep_doc : string\n-- Documentation string\n-- opts : dict\n-- Dictionary of option attributes and keys.  Use reverse_opt_map\n-- to reverse flags and attrs from opt_map class attribute.\n-- Returns\n-- -------\n-- rep_doc : string\n-- New docstring with flags replaces with attribute names.\n-- Examples\n-- --------\n-- doc = grab_doc('bet')\n-- opts = reverse_opt_map(fsl.Bet.opt_map)\n-- rep_doc = replace_opts(doc, opts)\nlocal function replace_opts(rep_doc, opts)\n   for key, value in pairs(opts) do\n      rep_doc = rep_doc:gsub(key, value)\n   end\n   return rep_doc\nen","completion":""}
{"prompt":"-- Get level height: number of notes in a certain level.\nlocal function level_width(root, level)\n\tlocal total_width = 0\n\tlocal node = root\n\twhile node do\n\t\tif node.level == level then\n\t\t\ttotal_width = total_width + 1\n\t\tend\n\t\tnode = node.next\n\tend\n\treturn total_width\nen","completion":""}
{"prompt":"-- Calculates the lande g factor given L, S and J\n-- .. math::\n-- g = 1 + \\frac{J(J+1) + S(S+1) - L(L+1)}{2J(J+1)}\n-- Reference: Sobel'man, I.I. Introduction to the \n-- Theory of Atomic Spectra. 1972. pp. 277\n-- Args:\n-- L (float): L number\n-- S (float): S number\n-- J (float): J number\n-- Returns:\n-- float: lande g factor\nlocal function lande_g(L, S, J)\n  return (1 + ((J * (J + 1)) + (S * (S + 1)) - (L * (L + 1))) \/ (2 * J * (J + 1)))\nen","completion":""}
{"prompt":"-- Problem 1: Calculates the sum of all multiples of 3 or 5 below limit.\n-- Args:\n-- limit (int): The limit below which numbers are checked.\nlocal function problem_01_multiples_3_5(limit)\n    local sum = 0\n    for n = 0, limit - 1 do\n        if (n % 3 == 0 or n % 5 == 0) then\n            sum = sum + n\n        end\n    end\n    return sum\nen","completion":""}
{"prompt":"-- Rounds num to next lowest multiple of factor.\nlocal function round_down(num, factor)\n\treturn math.floor(num\/factor)*factor\nen","completion":""}
{"prompt":"-- convert a midi note to its frequency in hertz\n-- https:\/\/en.wikipedia.org\/wiki\/Scientific_pitch_notation\nlocal function midi2freq(note)\n  return 440.0 * 2.0 ^ ((note - 69) \/ 12.0)\nen","completion":""}
{"prompt":"-- Returns GC content of a DNA strand as a percentage\nlocal function gc_content(dna_seq)\n\tlocal gc_count = 0\n\tfor i=1, #dna_seq do\n\t\tlocal base = string.sub(dna_seq, i, i)\n\t\tif base == \"C\" or base == \"G\" then gc_count = gc_count + 1 end\n\tend\n\treturn gc_count\/string.len(dna_seq)*100\nen","completion":""}
{"prompt":"-- Increases size of axis aligned bounding box (aabb).\nlocal function expand_aabb(left, right, top, bottom, delta_pixel)\n    return {left - delta_pixel, right + delta_pixel, top - delta_pixel, bottom + delta_pixel}\nen","completion":""}
{"prompt":"-- Conjugate of a quaternion.\n-- Parameters\n-- ----------\n-- q : list\n-- Quaternion as a list of four real values ``[w, x, y, z]``.\n-- Returns\n-- -------\n-- list\n-- Conjugate quaternion as a list of four real values ``[cw, cx, cy, cz]``.\n-- References\n-- ----------\n-- .. _mathworld quaternion conjugate: http:\/\/mathworld.wolfram.com\/QuaternionConjugate.html\nlocal function quaternion_conjugate(q)\n    return {q[1], -q[2], -q[3], -q[4]}\nen","completion":""}
{"prompt":"-- Convert iface string like 'any', 'eth', 'eth0' to route iface naming like *, eth+, eth0.\nlocal function convert_iface(iface)\n  local ifaces = {\n    any = \"*\",\n    eth = \"eth+\",\n    eth0 = \"eth0\"\n  }\n  return ifaces[iface] or iface\nen","completion":""}
{"prompt":"-- If an article has overlapping spans, they are merged\nlocal function merge_spans(span_intervals)\n\tlocal spans = {}\n\tlocal n = 0\n\tfor i=1, #span_intervals do\n\t\tn = n + 1\n\t\tspans[n] = {span_intervals[i][1], span_intervals[i][2]}\n\tend\n\ttable.sort(spans, function(a, b)\n\t\tif a[1] ~= b[1] then\n\t\t\treturn a[1] < b[1]\n\t\tend\n\t\treturn a[2] < b[2]\n\tend)\n\tlocal res = {}\n\tlocal n = 0\n\tfor i=1, #spans do\n\t\tif #res > 0 and spans[i][1] <= res[#res][2] then\n\t\t\tres[#res][2] = math.max(res[#res][2], spans[i][2])\n\t\telse\n\t\t\tn = n + 1\n\t\t\tres[n] = {spans[i][1], spans[i][2]}\n\t\tend\n\tend\n\treturn res\nen","completion":""}
{"prompt":"-- Defines the damped harmonic oscillator model for S(q,w)\/S(q)\n-- This is to be used at a specific q, which can then be used to build all\n-- the parameters as functions of q\n-- S(q,w)         1\/2 Gamma0(q)                   Omega(q) Gamma^2(q)\n-- ----- = I0(q)----------------- + I(q)-------------------------------------\n-- S(q)        w^2 + (Gamma0\/2)^2      (w^2 - Omega^2(q))^2 + (w Gamma(q))^2\nlocal function dhoModel(w, Gamma0, I0, Gamma, I, Omega)\n  local Omega2 = Omega^2\n  local Gamma2 = Gamma^2\n  local w2 = w^2\n  local w2mOmega2 = w2 - Omega2\n  return I0*Gamma0\/2\/(w^2 + Gamma0^2) + I*Gamma\/(w2mOmega2^2 + (Gamma*w)^2)\nen","completion":""}
{"prompt":"-- Return the value of G(n), computed recursively.\n-- >>> g(1)\n-- 1\n-- >>> g(2)\n-- 2\n-- >>> g(3)\n-- 3\n-- >>> g(4)\n-- 10\n-- >>> g(5)\n-- 22\n-- >>> from construct_check import check\n-- >>> # ban iteration\n-- >>> check(HW_SOURCE_FILE, 'g', ['While', 'For'])\n-- True\nlocal function g(n)\n    if n == 1 then\n        return 1\n    elseif n == 2 then\n        return 2\n    elseif n == 3 then\n        return 3\n    else\n        return g(n - 1) + 2 * g(n - 2) + 3 * g(n - 3)\n    end\nen","completion":""}
{"prompt":"-- Parabola for fitting to chisq curve.\n-- Arguments:\n-- x -- numpy array of x coordinates of fit\n-- A -- \n-- x0 -- x coordinate of parabola extremum\n-- C -- y coordinate of extremum\nlocal function chi_par(x, A, x0, C)\n    return A*(x-x0)^2 + C\nen","completion":""}
{"prompt":"-- Add an s, like rows, if the count is not 1.\nlocal function _s(count)\n\treturn count == 1 and \"\" or \"s\"\nen","completion":""}
{"prompt":"-- Return the hemisphere (N, S or '' for 0) for the given latitude.\nlocal function _lat_heimisphere(latitude)\n  return latitude > 0 and 'N' or latitude < 0 and 'S' or ''\nen","completion":""}
{"prompt":"-- Get real length from padded sequence\nlocal function non_zero_length(l)\n  local count = 0\n  for i = 1, #l do\n    if l[i] > 0 then\n      count = count + 1\n    end\n  end\n  return count\nen","completion":""}
{"prompt":"-- Return proficiency bonus for a given level to apply to a skill.\nlocal function proficiencyBonus(level, expertise)\n  -- Base proficiency bonus is 2 + your character level divided by 4, rounded down.\n  local base = 2 + math.floor(level \/ 4)\n  local bonus = base\n  if expertise then\n    bonus = math.floor((base + 2) * 1.3)\n  end\n  return bonus\nen","completion":""}
{"prompt":"-- Returns the distance between two points.\n-- params:\n-- point1 (int tuple): first  point\n-- point2 (int tuple): second point\n-- return:\n-- dist (int): Manhattan (aka L) distance between the points\nlocal function heuristic(point1, point2)\n  return math.abs(point1[1] - point2[1]) + math.abs(point1[2] - point2[2])\nen","completion":""}
{"prompt":"-- Normalizes component scale.\n-- * **value** must be a `tuple`` or ``list``.\n-- * **value** must have exactly two items.\n-- These items must be instances of :ref:`type-int-float`.\n-- * Returned value is a ``tuple`` of two ``float``\\s.\nlocal function normalizeComponentScale(value)\n  local x = value[1]\n  local y = value[2]\n  x = tonumber(x)\n  y = tonumber(y)\n  if not x then\n    error(\"The first component scale value must be a number.\", 2)\n  end\n  if not y then\n    error(\"The second component scale value must be a number.\", 2)\n  end\n  return {x, y}\nen","completion":""}
{"prompt":"-- Right-aligns the value in a field of a given width\n-- Argument: field size\nlocal function rjust(value, arg)\n\treturn string.rep(\" \", arg - #value) .. value\nen","completion":""}
{"prompt":"-- Return the value of G(n), computed recursively.\n-- >>> g(1)\n-- 1\n-- >>> g(2)\n-- 2\n-- >>> g(3)\n-- 3\n-- >>> g(4)\n-- 10\n-- >>> g(5)\n-- 22\n-- >>> from construct_check import check\n-- >>> check(HW_SOURCE_FILE, 'g', ['While', 'For'])\n-- True\nlocal function g(n)\n  if n == 1 then return 1\n  elseif n == 2 then return 2\n  elseif n == 3 then return 3\n  elseif n == 4 then return 10\n  elseif n == 5 then return 22\n  else return g(n-1) + 2*g(n-2) + 3*g(n-3)\n  end\nen","completion":""}
{"prompt":"-- >>> duration('1')\n-- 1.0\n-- >>> duration('1s')\n-- 1.0\n-- >>> duration('1 s')\n-- 1.0\n-- >>> duration('1h')\n-- 3600.0\n-- >>> duration('1d')\n-- 86400.0\n-- >>> duration('1m')\n-- 60.0\nlocal function duration(spec)\n  if type(spec) == \"number\" then\n    return spec\n  end\n  local s = string.lower(spec)\n  if s == \"\" then\n    return nil, \"empty string\"\n  end\n  if s:match(\"h$\") then\n    return tonumber(s:sub(1, -2)) * 3600\n  end\n  if s:match(\"m$\") then\n    return tonumber(s:sub(1, -2)) * 60\n  end\n  if s:match(\"s$\") then\n    return tonumber(s:sub(1, -2))\n  end\n  if s:match(\"d$\") then\n    return tonumber(s:sub(1, -2)) * 86400\n  end\n  return tonumber(s)\nen","completion":""}
{"prompt":"-- Generate a gradient of 1 for each loss specified in 'loss_blobs'\nlocal function get_loss_gradients_weighted(model, loss_blobs, loss_weight)\n  local loss_gradients = {}\n  for _, blob_name in ipairs(loss_blobs) do\n    local blob, grad_blob = model:blob(blob_name)\n    loss_gradients[blob_name] = loss_weight * grad_blob\n  end\n  return loss_gradients\nen","completion":""}
{"prompt":"-- slope is a float of slope\n-- point is a tuple of ...\n-- returns tuple of slope and y intercept\nlocal function lineFromSlope(slope, point)\n\tlocal yIntercept = point[2] - (slope * point[1])\n\treturn {slope, yIntercept}\nen","completion":""}
{"prompt":"-- Gets count of jobs who have 'status' of 'failed'\n-- :param jobslist:\n-- :type jobslist: list of dict\n-- :return: count of failed jobs\n-- :rtype: int\nlocal function get_failed_jobs(jobslist)\n    local failed_jobs = 0\n    if jobslist ~= nil then\n        for _, value in ipairs(jobslist) do\n            if value.status == 'failed' then\n                failed_jobs = failed_jobs + 1\n            end\n        end\n    end\n    return failed_jobs\nen","completion":""}
{"prompt":"-- Generate rainbow colors across 0-255 positions.\nlocal function wheel(pos)\n  if pos < 85 then return {pos * 3, 255 - pos * 3, 0}\n  elseif pos < 170 then pos = pos - 85; return {255 - pos * 3, 0, pos * 3}\n  else pos = pos - 170; return {0, pos * 3, 255 - pos * 3}\n  end\nen","completion":""}
{"prompt":"-- Safe conversion to int (can handle None)\nlocal function int_conv(value)\n    if value == nil then\n        return 0\n    end\n    return math.floor(tonumber(value) or 0)\nen","completion":""}
{"prompt":"-- Check Timeout Argument.\n-- Checks timeout for validity.\n-- Keyword Arguments:\n-- value                  -- Time in seconds to wait before timing out request.\n-- Return Value:\n-- Floating point number representing the time (in seconds) that should be\n-- used for the timeout.\n-- NOTE:  Will raise an exception if the timeout in invalid.\nlocal function timeout_check(value)\n    if value == nil then\n        return nil\n    end\n    local timeout = tonumber(value)\n    if timeout == nil then\n        error('Invalid value provided for \"timeout\" argument.', 2)\n    end\n    return timeout\nen","completion":""}
{"prompt":"-- Returns the prob that a unitform random variable is <=x\nlocal function uniform_cdf(x)\n  if x<0 then\n    return 0\n  elseif x>=1 then\n    return 1\n  else\n    return x\n  end\nen","completion":""}
{"prompt":"-- Return the contents of the first markdown heading in md, which we\n-- assume to be the title of the document.\nlocal function title(md)\n\tfor line in md:gmatch(\"([^\\n]+)\\n?\") do\n\t\tlocal level, title = line:match(\"^(%#+) *(.*)\")\n\t\tif level and level ~= \"\" then\n\t\t\treturn title\n\t\tend\n\tend\n\treturn nil\nen","completion":""}
{"prompt":"-- Returns a dictionary with localizable attributes of `obj`.\nlocal function get_localizable_attributes(obj)\n    local result = {}\n    local mt = getmetatable(obj)\n    while mt ~= nil do\n        for _, a in ipairs(mt.localizable) do\n            result[a] = mt[a]\n        end\n        mt = getmetatable(mt)\n    end\n    return result\nen","completion":""}
{"prompt":"-- Convert signed value into unsigned\n-- :param x: original value\n-- :param width in bits\nlocal function to_unsigned(x, width)\n   local width = width or 32\n   local max = 2 ^ width\n   return x % max\nen","completion":""}
{"prompt":"-- Creates a double-quoted string for AppleScript\n-- :param string:\n-- A unicode string to quote\n-- :return:\n-- A unicode string quoted for AppleScript\nlocal function _applescript_quote(string)\n  return \"\\\"\" .. string:gsub(\"\\\"\",\"\\\\\\\"\") .. \"\\\"\"\nen","completion":""}
{"prompt":"-- Function to generate fizz buzz sequence\nlocal function generate_fizz_buzz_sequence(n_max)\n    local sequence = {}\n    for n = 1, n_max do\n        local fizz = n % 3 == 0\n        local buzz = n % 5 == 0\n        if fizz and buzz then\n            table.insert(sequence, 'fizzbuzz')\n        elseif fizz then\n            table.insert(sequence, 'fizz')\n        elseif buzz then\n            table.insert(sequence, 'buzz')\n        else\n            table.insert(sequence, tostring(n))\n        end\n    end\n    return sequence\nen","completion":""}
{"prompt":"-- Dimensionless production rate for a gene regulated by two\n-- activators with AND logic in the absence of leakage.\n-- Parameters\n-- ----------\n-- x : float or NumPy array\n-- Concentration of first activator.\n-- y : float or NumPy array\n-- Concentration of second activator.\n-- nx : float\n-- Hill coefficient for first activator.\n-- ny : float\n-- Hill coefficient for second activator.\n-- Returns\n-- -------\n-- output : NumPy array or float\n-- x**nx * y**ny \/ (1 + x**nx) \/ (1 + y**ny)\nlocal function aa_and(x, y, nx, ny)\n    local xn = math.pow(x, nx)\n    local yn = math.pow(y, ny)\n    return xn * yn \/ (1 + xn) \/ (1 + yn)\nen","completion":""}
{"prompt":"-- Returns the fmeasure (or F1-score)\n-- http:\/\/en.wikipedia.org\/wiki\/F1_score\nlocal function fmeasure(precision, recall)\n\tif precision+recall == 0 then return 0 end\n\treturn 2*precision*recall\/(precision+recall)\nen","completion":""}
{"prompt":"-- Calculates the Manhattan distance between two pairs of grid coordinates.\nlocal function heuristic(a, b)\n    return math.abs(a[1] - b[1]) + math.abs(a[2] - b[2])\nen","completion":""}
{"prompt":"-- Returns the position of the last set bit (1-indexed)\n-- eg. find_last_set(0x8012) == 16\nlocal function find_last_set(value)\n\tif value == 0 then\n\t\treturn 0\n\tend\n\treturn math.floor(math.log(value) \/ math.log(2)) + 1\nen","completion":""}
{"prompt":"-- Method returns the start of the annotation. Used for sorting the annotations before reannotating.\n-- :param annotation: Annotation\n-- :return: Start of the annotation\nlocal function get_start(annotation)\n  return annotation.start\nen","completion":""}
{"prompt":"-- Parse strings like 40.3k and get the no. of stars as a number\nlocal function parse_star_count(stars_str)\n  local stars = 0\n  if stars_str ~= nil then\n    stars = tonumber(string.match(stars_str, \"%d+%.?%d*\"))\n    local stars_str = string.lower(stars_str)\n    if string.match(stars_str, \"k\") then\n      stars = stars * 1000\n    end\n  end\n  return stars\nen","completion":""}
{"prompt":"-- Convert window length (units of samples) and window overlap ratio to stride\n-- length (number of samples between windows). This assumes uniform sampling.\nlocal function computeStrideLength(window_length, overlap_ratio)\n    -- Compute number of overlapping samples\n    local num_overlapping_samples = math.ceil(window_length * overlap_ratio)\n    -- Compute stride length (number of samples between windows)\n    local stride_length = window_length - num_overlapping_samples\n    -- Return stride length\n    return stride_length\nen","completion":""}
{"prompt":"-- Transpose e.g. [[1,2,3], [4,5,6]] to [[1,4], [2,5], [3,6]]\nlocal function transpose(matrix)\n    local result = {}\n    for i, row in ipairs(matrix) do\n        for j, value in ipairs(row) do\n            if not result[j] then\n                result[j] = {}\n            end\n            result[j][i] = value\n        end\n    end\n    return result\nen","completion":""}
{"prompt":"-- Get unique namedtuple fields, despite potential duplicates in lists of fields.\nlocal function get_unique_fields(fld_lists)\n    local res = {}\n    local seen = {}\n    for i = 1, #fld_lists do\n        local fld_list = fld_lists[i]\n        for j = 1, #fld_list do\n            local fld = fld_list[j]\n            if not seen[fld] then\n                table.insert(res, fld)\n                seen[fld] = true\n            end\n        end\n    end\n    return res\nen","completion":""}
{"prompt":"-- Prepare the ``fixed_image_masks`` argument of SyN.\n-- Example\n-- -------\n-- >>> _fixed_masks_arg(\"atlas_mask.nii.gz\")\n-- ['NULL', 'atlas_mask.nii.gz']\nlocal function _fixed_masks_arg(mask)\n  return {'NULL', mask}\nen","completion":""}
{"prompt":"-- Return all parent reference nodes of reference node\n-- Args:\n-- ref (str): reference node.\n-- Returns:\n-- list: The upstream parent reference nodes.\nlocal function get_reference_node_parents(ref)\n    local parents = {}\n    if type(ref) == \"string\" and ref ~= \"\" then\n        local parent = ref:match(\".*@([^:]+):.*\")\n        if parent then\n            table.insert(parents, parent)\n            local next_parent = get_reference_node_parents(parent)\n            for i = 1, #next_parent do\n                table.insert(parents, next_parent[i])\n            end\n        end\n    end\n    return parents\nen","completion":""}
{"prompt":"-- Algorithm Paradigmn: Greedy\n-- Complexity:\n-- a) Time : O(n)\n-- Args:\n-- start_times(list):\n-- finish_times_sorted(list):\n-- Returns:\n-- int: N of activities\nlocal function activity_selection_finish_time_sorted(start_times, finish_times_sorted)\n  local i = 1\n  local N = #start_times\n  local activities = {}\n  local time = 0\n  while i <= N do\n    local start_time = start_times[i]\n    local finish_time = finish_times_sorted[i]\n    if start_time > time then\n      activities[#activities + 1] = finish_time\n      time = finish_time\n    end\n    i = i + 1\n  end\n  return #activities\nen","completion":""}
{"prompt":"-- Cost function for a sequence of control messages, lower is better.\n-- :param pos_neg: count of forward<->reverse transitions, cost=10\n-- :param off_on: count of off->on transitions, cost=5\n-- :return: cost\nlocal function cost_function(pos_neg, off_on)\n  return 10 * pos_neg + 5 * off_on\nen","completion":""}
{"prompt":"-- Console script for python_template.\nlocal function main()\n    -- print(\"Hello World\")\n    print(string.format(\"Hello %s\", \"World\"))\n    return 0\nen","completion":""}
{"prompt":"-- if the code starts with a single term on the first line, assume it's\n-- a language and remove it. We will need to test this to see if it works\n-- in practice.\nlocal function remove_language(code)\n  local first_line = code:match('^\\n*%s*([%w_%-]+).*$')\n  if first_line then\n    return code:gsub('^' .. first_line .. '\\n', '', 1)\n  end\n  return code\nen","completion":""}
{"prompt":"-- strip the units of a quantity\nlocal function array_strip_units(data)\n    local function strip_units(data)\n        if type(data) == 'table' and data.units then\n            data.units = nil\n            return data\n        elseif type(data) == 'table' then\n            for k, v in pairs(data) do\n                data[k] = strip_units(v)\n            end\n            return data\n        else\n            return data\n        end\n    end\n    return strip_units(data)\nen","completion":""}
{"prompt":"-- :param pdf_file_path: file path of a pdf to convert into a string\n-- :return: string of the parsed pdf\nlocal function parse_pdf_to_string(pdf_file_path)\n  local output = {}\n  local cmd = string.format(\"pdftotext -layout -nopgbrk -enc UTF-8 \\\"%s\\\" -\", pdf_file_path)\n  local f = io.popen(cmd)\n  if f then\n    for line in f:lines() do\n      table.insert(output, line)\n    end\n  end\n  return table.concat(output, \"\\n\")\nen","completion":""}
{"prompt":"-- Flatten List of Lists to List\nlocal function flatten(l)\n    local flat = {}\n    for _, v in ipairs(l) do\n        for _, x in ipairs(v) do\n            flat[#flat+1] = x\n        end\n    end\n    return flat\nen","completion":""}
{"prompt":"-- Calc the dwelling risk\n-- Parameters: \n-- cas rate (float): The rate to be applied\n-- First app (float): The time of first in attendance in decimalised mins\n-- Second app (float): The time of second in attendance in decimalised mins\n-- Returns: \n-- Calculated lives lost\nlocal function _calc_dwelling_fatalities(cas_rate, first_appliance_time, second_appliance_time)\n\tlocal lives_lost = 0\n\t-- Get number of lives lost in case of casualty\n\t-- Apply cas rate if there is a second appliance\n\t-- Otherwise, apply the cas rate to the first appliance\n\tif second_appliance_time ~= nil then\n\t\tlives_lost = (second_appliance_time - first_appliance_time) * cas_rate\n\telse\n\t\tlives_lost = (1440 - first_appliance_time) * cas_rate\n\tend\n\t-- Return lives lost\n\treturn lives_lost\nen","completion":""}
{"prompt":"-- Flips tuple elements.\n-- This is useful for list to screen coordinates translation.\n-- In list of lists: x = rows = vertical\n-- whereas on screen: x = horizontal\nlocal function tflip(tup)\n  return {tup[2], tup[1]}\nen","completion":""}
{"prompt":"-- Find properties with a given name.\nlocal function _find_properties(parent, name)\n    local properties = {}\n    for property, data in pairs(parent) do\n        if data.name == name then\n            table.insert(properties, property)\n        end\n    end\n    return properties\nen","completion":""}
{"prompt":"-- Detects if string is integer, float or string.\n-- Parameters\n-- ----------\n-- string : string\n-- An input string to be tested.\n-- Returns\n-- -------\n-- string\n-- A string with value 'int' if input is an integer,\n-- 'float' if the input is a float and 'string' if it\n-- is just a regular string.\nlocal function test_string_content(string)\n    local test = tonumber(string)\n    if test == nil then\n        return 'string'\n    elseif test % 1 ~= 0 then\n        return 'float'\n    else\n        return 'int'\n    end\nen","completion":""}
{"prompt":"-- Creates a null matrix.\n-- Args:\n-- n (int)\n-- Number of rows of the matrix\n-- m (int, optional): \n-- Number of columns of the matrix. Defaults to the number of rows.\n-- Returns\n-- -------\n-- Matrix\n-- A null matrix of order N x M.\nlocal function null(n, m)\n  m = m or n\n  local row = {}\n  for _ = 1, m do\n    table.insert(row, 0)\n  end\n  local matrix = {}\n  for _ = 1, n do\n    table.insert(matrix, row)\n  end\n  return matrix\nen","completion":""}
{"prompt":"-- Linear interpolation.\nlocal function lerp(a, b, x)\n  return a + (b - a) * x\nen","completion":""}
{"prompt":"-- Learning Rate Schedule\n-- Learning rate is scheduled to be reduced after 51, 101, 201 epochs.\n-- Called automatically every epoch as part of callbacks during training.\n-- # Arguments\n-- epoch (int): The number of epochs\n-- # Returns\n-- learning rate(float32)\nlocal function scheduler(epoch)\n   if epoch < 51 then\n      return 1e-1\n   elseif epoch < 101 then\n      return 1e-2\n   elseif epoch < 201 then\n      return 1e-3\n   else\n      return 1e-4\n   end\nen","completion":""}
{"prompt":"-- Function to apply to a pixel value to make a threshold operation\n-- args : int\n-- returns int equal to 0 or 255\nlocal function threshold(x)\n    return x > 0 and 255 or 0\nen","completion":""}
{"prompt":"-- Return list of random segments (r, s) where low <= r < s <= high. \n-- Number of segments returned is (high-low).\n-- Since r<s, does not return segments of the form (k, k).\n-- Intent is that cids are integers in range low <= cid <= high,\n-- and each segment yields a contest group covering cids r..s (inclusive).\n-- The segments \"nest\" -- given any two segments, either they\n-- are disjoint, or they are equal, or one contains the other.\nlocal function generate_segments(e, syn, low, high)\n\tif high <= low then return {} end\n\tlocal segs = {}\n\tlocal r = low + math.random(e.segment_size)\n\tlocal s = r + math.random(e.segment_size-1)\n\t-- If the segments are equal, then just add one\n\tif r == s then\n\t\tsegs[#segs+1] = {r, s}\n\t-- If the segments are disjoint, then add them both\n\telseif s < r then\n\t\tsegs[#segs+1] = {r, s}\n\t\tsegs[#segs+1] = {s+1, r}\n\t-- If one segment contains the other, then add the smaller one\n\telse\n\t\tif r < low+e.segment_size\/2 then\n\t\t\tsegs[#segs+1] = {r, high}\n\t\telse\n\t\t\tsegs[#segs+1] = {low, s}\n\t\tend\n\tend\n\t-- Return segments\n\treturn segs\nen","completion":""}
{"prompt":"-- :param values: Either a single numeric value or a sequence of numeric values\n-- :return: A sequence, possibly of length one, of all the values in ``values``\nlocal function _to_value_seq(values)\n    if values == nil or values == '' or values == 'nil' then\n        return { 0 }\n    elseif type(values) == 'string' then\n        return { tonumber(values) }\n    elseif type(values) == 'table' then\n        return values\n    else\n        return { values }\n    end\nen","completion":""}
{"prompt":"-- :param value:\n-- :param n:\n-- :return:\nlocal function get_bit(value, n)\n  return math.floor(value \/ math.pow(2, n)) % 2\nen","completion":""}
{"prompt":"-- Escapes slashes in the given message.\nlocal function escape_slashes(message)\n    return message:gsub(\"\\\\\", \"\\\\\\\\\"):gsub(\"\/\", \"\\\\\/\")\nen","completion":""}
{"prompt":"-- Calculates billable hours from an array of entry dictionaries\nlocal function calc_billable_hours(entries)\n  local hours = 0\n  for _, e in pairs(entries) do\n    hours = hours + (e.time or 0)\n  end\n  return hours\nen","completion":""}
{"prompt":"-- Removes a suffix from a string if it exists\nlocal function trim_suffix(s, suffix)\n   if s:sub(-suffix:len()) == suffix then\n      return s:sub(1, -suffix:len() - 1)\n   end\n   return s\nen","completion":""}
{"prompt":"-- Apply the compound interest formula to p\n-- to produce the final amount.\nlocal function final_amt(p, r, n, t)\n  return p * (1 + r\/n)^(n*t)\nen","completion":""}
{"prompt":"-- Turns an arrow hash back into the array of arrow directions.\n-- Args:\n-- anum (int): The arrow hash number.\n-- num_of_arrows (int): The number of arrows in the system.\n-- dim (int): The number of directions the arrows can point.\n-- Returns:\n-- arrows (list): The arrow labeling.\nlocal function _ainvhash(anum, num_of_arrows, dim)\n  local arrows = {}\n  for i = 1,num_of_arrows do\n    arrows[i] = anum % dim\n    anum = (anum - arrows[i]) \/ dim\n  end\n  return arrows\nen","completion":""}
{"prompt":"-- Helper function to format individual time frames.\n-- :param x: Integer\n-- :param frame: Time frame\n-- :return: Formatted time string\nlocal function format_string(x, frame)\n    if x < 1 then\n        return \"\"\n    else\n        return string.format(\"%d %s%s\", x, frame, x > 1 and \"s\" or \"\")\n    end\nen","completion":""}
{"prompt":"-- Ensure that x is between 0 and 1.\nlocal function as_valid_fraction(x)\n  if x <= 0 then return 0\n  elseif x >= 1 then return 1\n  else return x\n  end\nen","completion":""}
{"prompt":"-- Use the plural or singular form based on some count.\nlocal function pluralize(n, singular, plural)\n    if n == 1 then\n        return singular\n    else\n        return plural\n    end\nen","completion":""}
{"prompt":"-- convert [hostname, port]  to a http url\nlocal function to_http_url(list)\n    return string.format(\"http:\/\/%s:%s\", list[1], list[2])\nen","completion":""}
{"prompt":"-- Returns 1 if x is positive, 0 if x is 0, and -1 otherwise\nlocal function sign(x)\n    return x > 0 and 1 or (x < 0 and -1 or 0)\nen","completion":""}
{"prompt":"-- f(e) from Peters and Mathews (1963) Eq.17\n-- This function gives the integrated enhancement factor of gravitational radiation from an eccentric\n-- source compared to an equivalent circular source.\n-- Parameters\n-- ----------\n-- e : `float\/array`\n-- Eccentricity\n-- Returns\n-- -------\n-- f : `float\/array`\n-- Enhancement factor\n-- Notes\n-- -----\n-- Note that this function represents an infinite sum of g(n, e) - :meth:`legwork.utils.peters_g`\nlocal function peters_f(e)\n\tlocal f = (1 - e^2)^1.5\n\treturn f\nen","completion":""}
{"prompt":"-- assumes num is a positive int\n-- returns an int, num! (the factorial of n)\nlocal function iterativeFactorial(num)\n  local product = 1\n  for i=2,num do product = product * i end\n  return product\nen","completion":""}
{"prompt":"-- add_leading_zero function\n-- Args:\n-- number (int): number that you want to add leading zero\n-- digit_num (int): number of digits that you want fill up to. Defaults to 2.\n-- Returns:\n-- str: number that has the leading zero\n-- Examples:\n-- >>> add_leading_zero(5, 3)\n-- \"005\"\nlocal function add_leading_zero(number, digit_num)\n  digit_num = digit_num or 2\n  return string.format(\"%0\" .. digit_num .. \"d\", number)\nen","completion":""}
{"prompt":"-- Accepts two positive int arguments and returns the sum. \n-- The magnitude of both integers must be less than 100.\n-- :param x: first positive integer to sum\n-- :param y: second positive integer to sum\nlocal function compute(x, y)\n   if x < 0 or x > 100 or y < 0 or y > 100 then\n      error(\"x and y must be positive integers less than 100\")\n   end\n   return x + y\nen","completion":""}
{"prompt":"-- document = \"545,32 8:1 18:2\"\n-- extract_classes(document) => returns \"545,32\"\nlocal function extract_classes(document)\n\treturn document:match(\"%d+,[0-9]+\")\nen","completion":""}
{"prompt":"-- Inputs:\n-- u1 : first column\n-- u2 : second column\n-- Outputs:\n-- y : binary variable (1 or 0) ; 1 if x2 is preferred ; 0 if x1 is preferred\n-- p: actual preference probability\nlocal function gen_output(u1, u2)\n\tif u2 > u1 then\n\t\treturn 1, u2\/(u2+u1)\n\telse\n\t\treturn 0, u1\/(u2+u1)\n\tend\nen","completion":""}
{"prompt":"-- Given a URI like host.tld\/bla\/fah\/jah or host.tld\/bla\/fah\/jah\/, returns jah.\nlocal function guess_name_from_uri(uri)\n\turi = string.gsub(uri, \"^.*\/([^\/]+).*$\", \"%1\")\n\treturn uri\nen","completion":""}
{"prompt":"-- Create a sensor class for each i2c sensor listed in the i2c_bus list.\n-- Return a list containing all the classes.\n-- Note that each sensor class adds 0, 1, or more sensor reading values \n-- to the sensor_readings array and these classes remember the indexes of their\n-- values so that they can update them with new sensor readings as\n-- they become available.\nlocal function make_sensor_list(args, sensor_readings)\n\tlocal sensor_list = {}\n\tlocal sensor_names = args.sensors or {\"ALL\"}\n\tfor name, _ in pairs(sensor_names) do\n\t\tlocal sensor_class\n\t\tif name == \"ALL\" then\n\t\t\tsensor_class = make_all_sensor_class(args, sensor_readings)\n\t\telseif name == \"DHT22\" then\n\t\t\tsensor_class = make_dht22_sensor_class(args, sensor_readings)\n\t\telseif name == \"BME280\" then\n\t\t\tsensor_class = make_bme280_sensor_class(args, sensor_readings)\n\t\telseif name == \"BMP280\" then\n\t\t\tsensor_class = make_bmp280_sensor_class(args, sensor_readings)\n\t\telseif name == \"BH1750\" then\n\t\t\tsensor_class = make_bh1750_sensor_class(args, sensor_readings)\n\t\telseif name == \"TSL2591\" then\n\t\t\tsensor_class = make_tsl2591_sensor_class(args, sensor_readings)\n\t\telseif name == \"HCSR04\" then\n\t\t\tsensor_class = make_hc_sr04_sensor_class(args, sensor_readings)\n\t\telseif name == \"MCP9808\" then\n\t\t\tsensor_class = make_mcp9808_sensor_class(args, sensor_readings)\n\t\tend\n\t\tif sensor_class then\n\t\t\ttable.insert(sensor_list, sensor_class)\n\t\telse\n\t\t\tprint(\"WARNING: unknown sensor name: \" .. name)\n\t\tend\n\tend\n\treturn sensor_list\nen","completion":""}
{"prompt":"-- Returns all factors of n\nlocal function factors(n)\n  local ret = {}\n  for i = 1, math.floor(math.sqrt(n)) do\n    if n % i == 0 then\n      table.insert(ret, i)\n      if i ~= n \/ i then\n        table.insert(ret, n \/ i)\n      end\n    end\n  end\n  return ret\nen","completion":""}
{"prompt":"-- Given the length of a sorted list of joltages with joltage difference 1,\n-- calculate the number of ways to combine them.\n-- e.g. [4, 5, 6, 7] can be combined as\n-- [4, 5, 6, 7]\n-- [4, 6, 7]\n-- [4, 5, 7]\n-- [4, 7]\n-- = 4 ways\n-- The answers to the first few are known:\n-- n   | Paths\n-- --- | ---\n-- 1   | 1\n-- 2   | 1\n-- 3   | 2\n-- 4   | 4\n-- After this, the answer is double the previous answer, minus the answer\n-- from 4 answers ago\n-- n   | Paths\n-- --- | ---\n-- 5   | 7 (4 * 2 - 1)\n-- 6   | 13 (7 * 2 - 1)\n-- 7   | 24 (13 * 2 - 2)\n-- 8   | 44 (24 * 2 - 4)\nlocal function path_count(n)\n  local paths = table.pack(1, 1, 2, 4)\n  for i = 5, n do\n    paths[i] = paths[i - 1] * 2 - paths[i - 4]\n  end\n  return paths[n]\nen","completion":""}
{"prompt":"-- Abbreviate a string. For use as a .represent\n-- see also: vita.truncate(self, text, length=48, nice=True)\nlocal function shn_abbreviate(word, size)\n  size = size or 48\n  if not word then\n    return nil\n  end\n  if #word > size then\n    word = word:sub(1, size) .. \"...\"\n  end\n  return word\nen","completion":""}
{"prompt":"-- Parameters\n-- ----------\n-- category_str: str of nominal values from dataset meta information\n-- Returns\n-- -------\n-- dict of the nominal values and their one letter encoding\n-- Example\n-- -------\n-- \"bell=b, convex=x\" -> {\"bell\": \"b\", \"convex\": \"x\"}\nlocal function txt_category_to_dict(category_str)\n    local category_dict = {}\n    if category_str ~= nil then\n        local categories = {}\n        for i in category_str:gmatch(\"[^, ]+\") do\n            categories[#categories + 1] = i\n        end\n        for i, v in pairs(categories) do\n            local key, value = v:match(\"([^=]+)=(.+)\")\n            category_dict[key] = value\n        end\n    end\n    return category_dict\nen","completion":""}
{"prompt":"-- :rtype: str\nlocal function str_attr(attr_dict, attr_dict_key)\n    if attr_dict and attr_dict[attr_dict_key] then\n        return attr_dict[attr_dict_key]\n    end\n    return ''\nen","completion":""}
{"prompt":"-- Return a stripped, uppercase string.\nlocal function _clean(item)\n\treturn string.upper(string.match(item, \"^%s*(.-)%s*$\"))\nen","completion":""}
{"prompt":"-- Double brackets in regex of url_path for escape string formatting\nlocal function escape_curly_brackets(url_path)\n  return url_path:gsub(\"{\", \"{{\"):gsub(\"}\", \"}}\")\nen","completion":""}
{"prompt":"-- Replace double quotes if it's necessary\nlocal function _doublequote(str)\n  return (str:find('\"') and str:gsub('\"', '\\\\\"')) or str\nen","completion":""}
{"prompt":"-- Add two numbers x and y\n-- >>> add(2, 3)\n-- 5\n-- >>> add(5, 7)\n-- 12\nlocal function add(x, y)\n    return x + y\nen","completion":""}
{"prompt":"-- Simple implementation of math.comb for python 3.7 compatibility.\nlocal function choose(n, k)\n\tif k == 0 then\n\t\treturn 1\n\telseif k > n or k < 0 then\n\t\treturn 0\n\telse\n\t\tlocal res = 1\n\t\tfor i=1,k do\n\t\t\tres = res * (n-i+1)\/i\n\t\tend\n\t\treturn res\n\tend\nen","completion":""}
{"prompt":"-- return x, y, if row == True else y,x\nlocal function _sargs(row, x, y)\n\treturn row and {x, y} or {y, x}\nen","completion":""}
{"prompt":"-- check if input is of alphanumeric characters\nlocal function sanitize_input(input_data)\n  -- check if input is empty\n  if input_data == nil or input_data == '' then\n    return false, 'Input cannot be empty'\n  end\n  -- check if input has any non-alphanumeric characters\n  for char in input_data:gmatch(\"[%a%d%s%p]\") do\n    -- if any non-alphanumeric character found\n    if char ~= ' ' and char ~= '-' and char ~= '_' and char ~= '+' and char ~= '\/' then\n      -- input is not of alphanumeric characters\n      return false, 'Input cannot contain special characters, except space'\n    end\n  end\n  -- input is of alphanumeric characters\n  return true\nen","completion":""}
{"prompt":"-- Longest substring is returned as its string length in numeric.\nlocal function lengthOfLongestSubstring(s)\n    local max = 0\n    local temp = ''\n    for i = 1, #s do\n        local c = string.sub(s,i,i)\n        local index = string.find(temp,c)\n        if index then\n            temp = string.sub(temp, index+1)\n        end\n        temp = temp .. c\n        if max < #temp then\n            max = #temp\n        end\n    end\n    return max\nen","completion":""}
{"prompt":"-- Find root x1,x2 by using interpolation.\n-- @param x1: left border of range\n-- @type x1: float\n-- @param x2: right border of range\n-- @type x2: float\n-- @param f1: value for x1\n-- @type f1: float\n-- @param f2: value for x2\n-- @type f2: float\n-- @return: M{x} where M{f(x)=0}\n-- @rtype: float\nlocal function _find_root_linear(x1, x2, f1, f2)\n\tif f1 == f2 then\n\t\treturn math.nan\n\telse\n\t\treturn -f1 * (x2 - x1) \/ (f2 - f1) + x1\n\tend\nen","completion":""}
{"prompt":"-- defines the shortcut withing one residual block in the generator\n-- if bn=True: for a pre-trained network that used BN, an AffineChannel op replaces BN\n-- during fine-tuning.\nlocal function generator_shortcut(model, blob_in, dim_in, dim_out, prefix, stride, bn)\n   local dim_diff = dim_out - dim_in\n   if dim_diff == 0 then\n      -- identity shortcut\n      return blob_in\n   elseif dim_diff > 0 then\n      -- projection shortcut (dim_diff == 2^n, stride=2)\n      return cudnn.SpatialConvolution(\n         model.mlpnet, blob_in, dim_out, dim_out, 1, 1, 0, 0, 0, 0, stride)\n   else\n      -- down-sampling shortcut (stride=2)\n      assert(dim_diff < 0)\n      if bn then\n         -- for pre-trained network that used BN, an AffineChannel op replaces BN\n         return nn.SpatialBatchNormalization(\n            model.mlpnet, prefix .. '_shortcut', dim_out, 1, 1, 0, 1):annotate{\n            name = prefix .. '_shortcut.affine'\n         }(nn.SpatialConvolution(\n            model.mlpnet, blob_in, dim_out, dim_out, 1, 1, 0, 0, 0, 0, stride))\n      else\n         return nn.SpatialConvolution(\n            model.mlpnet, blob_in, dim_out, dim_out, 1, 1, 0, 0, 0, 0, stride)\n      end\n   end\nen","completion":""}
{"prompt":"-- One-hot encode position\n-- Args:\n-- position (int): Which entry to set to 1\n-- count (int): Max number of entries.\n-- Returns:\n-- list: list with zeroes and 1 in <position>\nlocal function onehot_encode(position, count)\n  local list = {}\n  for i=1, count do\n    if i == position then\n      table.insert(list, 1)\n    else\n      table.insert(list, 0)\n    end\n  end\n  return list\nen","completion":""}
{"prompt":"-- Get a single test module's config\nlocal function get_test_config(config, test)\n    return config.modules[test]\nen","completion":""}
{"prompt":"-- Return the geometry type from a __geo_interface__ dictionary\nlocal function get_geometry_type(gi)\n    if gi.type == \"Feature\" then\n        return get_geometry_type(gi.geometry)\n    end\n    if gi.type == \"GeometryCollection\" then\n        for _,v in ipairs(gi.geometries) do\n            return get_geometry_type(v)\n        end\n    end\n    return gi.type\nen","completion":""}
{"prompt":"-- Generates a Uniform rnd variate in *(a,b)*.\n-- Must be a < b.\n-- :param a: (float) lower bound.\n-- :param b: (float) upper bound.\n-- :param u: (float) rnd number in (0,1).\n-- :return: (float) the Uniform(a,b) rnd variate.\nlocal function uniform(a, b, u)\n    local c = b - a\n    return a + c * u\nen","completion":""}
{"prompt":"-- Retrieves a value from a JSON object (dict).\n-- Args:\n-- json_obj (dict): The JSON file to retrieve a value from.\n-- attribute_name (str): The attribute to look up. If there are nested\n-- structures expressed within the attribute_name, they should be\n-- separated by periods. Consequently, attribute names and nested\n-- names cannot contain periods.\n-- json_filename (Optional[str]): The name of the JSON file the attribute\n-- is read from. This will be included in error messages. Default is\n-- `None`.\n-- suppress_err_msg (Optional[bool]): Specifies whether an error message\n-- will be printed to stdout if an error condition is met. By default,\n-- error messages will be printed.\n-- Raises:\n-- KeyError: If the specified `attribute_name` does not exist in the JSON.\nlocal function get_json_field(json_obj, attribute_name, json_filename, suppress_err_msg)\n    if (type(json_obj) ~= \"table\") then\n        if not suppress_err_msg then\n            print(\"The JSON object read from \" .. json_filename .. \" is not a table.\")\n        end\n        error(\"The JSON object read from \" .. json_filename .. \" is not a table.\")\n    end\n    local attribute_parts = {}\n    for part in attribute_name:gmatch(\"[^%.]+\") do\n        table.insert(attribute_parts, part)\n    end\n    local attribute_value = json_obj\n    for i = 1, #attribute_parts do\n        local part = attribute_parts[i]\n        attribute_value = attribute_value[part]\n        if attribute_value == nil then\n            if not suppress_err_msg then\n                print(\"The attribute name \" .. attribute_name .. \" could not be found in the JSON object.\")\n            end\n            error(\"The attribute name \" .. attribute_name .. \" could not be found in the JSON object.\")\n        end\n    end\n    return attribute_value\nen","completion":""}
{"prompt":"-- compare two input numbers, and return smaller one.\n-- :param current_min: int, the current min score.\n-- :param input_score: int, the score just input.\n-- :return: int, compare two numbers and return smaller one.\nlocal function get_min(current_min, input_score)\n    if current_min == 0 or (input_score < current_min) then\n        return input_score\n    end\n    return current_min\nen","completion":""}
{"prompt":"-- Utility fixture for handling both batched and non-batched modes.\nlocal function bsize(batch_size)\n  return batch_size and batch_size or 1\nen","completion":""}
{"prompt":"-- Clips off a value which exceeds the lower or upper bounds.\nlocal function bound(value, lower, upper)\n\tlocal result = value\n\tif value < lower then\n\t\tresult = lower\n\telseif value > upper then\n\t\tresult = upper\n\tend\n\treturn result\nen","completion":""}
{"prompt":"-- transpose matrix\nlocal function transpose(table)\n\tlocal ret = {}\n\tfor i = 1, #table[1] do\n\t\tret[i] = {}\n\t\tfor j = 1, #table do\n\t\t\tret[i][j] = table[j][i]\n\t\tend\n\tend\n\treturn ret\nen","completion":""}
{"prompt":"-- Make indentation use 4 spaces, rather than the 2 spaces GraphQL normally uses.\nlocal function fix_indentation_depth(query)\n  query = query:gsub(\"  \", \"    \")\n  return query\nen","completion":""}
{"prompt":"-- Returns the ceiling function of a division between `num` and `div`.\n-- Usage::\n-- >>> ceil_div(100, 7)\n-- 15\n-- >>> ceil_div(100, 10)\n-- 10\n-- >>> ceil_div(1, 4)\n-- 1\n-- :param num: Division's numerator, a number\n-- :param div: Division's divisor, a number\n-- :return: Rounded up result of the division between the parameters.\nlocal function ceil_div(num, div)\n    return math.ceil(num \/ div)\nen","completion":""}
{"prompt":"-- Return a value from nested dicts by the order of the given keys tuple.\n-- Parameters\n-- ----------\n-- key_tuple : tuple\n-- The keys to use for extraction, in order.\n-- dict_obj : dict\n-- The outer-most dict to extract from.\n-- Returns\n-- -------\n-- value : object\n-- The extracted value, if exists. Otherwise, raises KeyError.\n-- Example\n-- -------\n-- >>> dict_obj = {'a': {'b': 7}}\n-- >>> get_nested_val(('a', 'b'), dict_obj)\n-- 7\nlocal function get_nested_val(key_tuple, dict_obj)\n    local val = dict_obj\n    for _, key in ipairs(key_tuple) do\n        val = val[key]\n    end\n    return val\nen","completion":""}
{"prompt":"-- Return all parts of a bundle's \"key\" as used in a timestamp file,\n-- given its full filename.\n-- >>> getBundleKey(\"\/bundleinfo\/tor-browser\/win32\/some-file-name.txt\")\n-- '\/bundleinfo\/tor-browser\/win32\/'\nlocal function getBundleKey(bundlePath)\n  local _, _, bundleKey = string.find(bundlePath, \"^(.*\/)([^\/]*)$\")\n  return bundleKey\nen","completion":""}
{"prompt":"-- Convert brightness from absolute 0..255 to percentage.\nlocal function brightness_to_percentage(byt)\n    return math.floor((byt \/ 255) * 100)\nen","completion":""}
{"prompt":"-- Input list of parameters\n-- Turn this into a string for display\n-- E.g.\nlocal function parameter_list_as_string(parameters)\n   if not parameters then\n      return ''\n   end\n   local result = ''\n   for i = 1, #parameters do\n      if i > 1 then\n         result = result .. ', '\n      end\n      result = result .. parameters[i]\n   end\n   return result\nen","completion":""}
{"prompt":"-- 90 degree counter-clockwise rotation.\n-- Parameters:\n-- board (list): game board\n-- Returns:\n-- b (list): new game board after rotation\nlocal function rotateLeft(board)\n    local b = {}\n    for i = 1, #board[1] do\n        b[i] = {}\n        for j = 1, #board do\n            b[i][j] = board[j][#board[1]-i+1]\n        end\n    end\n    return b\nen","completion":""}
{"prompt":"-- Flatten a singly nested list.\n-- Examples\n-- --------\n-- >>> flatten([[0,1,2], [4,5]])\n-- [0, 1, 2, 4, 5]\nlocal function flatten(l)\n  local function flatten_internal(acc, xs)\n    for _, x in ipairs(xs) do\n      if type(x) == \"table\" then\n        flatten_internal(acc, x)\n      else\n        table.insert(acc, x)\n      end\n    end\n    return acc\n  end\n  return flatten_internal({}, l)\nen","completion":""}
{"prompt":"-- if the href is not prefaced with a protocol, add one\nlocal function enhance_xlink_href(href)\n\tif href ~= nil then\n\t\tlocal _, _, protocol = string.find(href, \"^(%w+):\/\/\")\n\t\tif protocol == nil then\n\t\t\thref = \"http:\/\/\" .. href\n\t\tend\n\tend\n\treturn href\nen","completion":""}
{"prompt":"-- Parameters\n-- ----------\n-- s : string\n-- Song lyrics string\n-- Returns\n-- -------\n-- converted : string\n-- A copy of s with removed punctuation and all letters turned to lowercase.\nlocal function removePunctuation(s)\n    local remove_punc = string.gsub(s, '[^a-zA-Z ]+', '')\n    return string.lower(remove_punc)\nen","completion":""}
{"prompt":"-- Regexifies pattern against which tokens will be matched (i.e. the left-\n-- hand side of the rule usually).\nlocal function _regexify_matching_pattern(rule_pattern, wildcard_optional)\n  if wildcard_optional then\n    return rule_pattern\n      :gsub(\"%*%*?\", \"(.-)\")\n      :gsub(\"%*\", \"[^%.]+\")\n  else\n    return rule_pattern\n      :gsub(\"%*\", \"[^%.]+\")\n  end\nen","completion":""}
{"prompt":"-- get_keys of nested dictionary\n-- >>> a = {\"a\": 1, \"b\": {\"c\": 2}}\n-- >>> get_keys(a)\n-- ['\/a', '\/b\/c']\nlocal function get_keys(dic, key_path)\n    if dic == nil then\n        return {}\n    end\n    local keys = {}\n    for k, v in pairs(dic) do\n        local new_path = (key_path or \"\") .. \"\/\" .. k\n        if type(v) == \"table\" then\n            local new_keys = get_keys(v, new_path)\n            for i, j in pairs(new_keys) do\n                table.insert(keys, j)\n            end\n        else\n            table.insert(keys, new_path)\n        end\n    end\n    return keys\nen","completion":""}
{"prompt":"-- todo: Update Documentation\n-- :param arg:\n-- :type arg:\n-- :return:\n-- :rtype:\nlocal function make_list(arg)\n  if type(arg) == \"table\" then\n    return arg\n  else\n    return {arg}\n  end\nen","completion":""}
{"prompt":"-- Computes the nth Fibonacci number. For example::\n-- >>> map(fibonacci,range(10))\n-- [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n-- Utilizes modified code from `this answer on Stack Overflow\n-- <http:\/\/stackoverflow.com\/a\/14782458\/786020>`_ based upon the concept\n-- explained `here on Wikipedia <http:\/\/en.wikipedia.org\/wiki\/Fibonacci_sequence#Matrix_form>`_\n-- along with concurrent caching from :class:`concurrent.Cache` for\n-- branching and repeated parameter optimization.\n-- This function is mostly intended to demonstrate the uses of apply_async, and could\n-- easily be improved.\nlocal function fibonacci(n)\n    if n == 0 then\n        return 0\n    elseif n == 1 or n == 2 then\n        return 1\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2)\n    end\nen","completion":""}
{"prompt":"-- Squared error on the trapezoidal rule for two points.\n-- For errors dy1 and dy2 and spacing dx.\nlocal function _trapz_2pt_error2(dy1, dy2, dx)\n  -- Return the squared error.\n  return (dy1 * dy1 + dy2 * dy2) * dx \/ 4.\nen","completion":""}
{"prompt":"-- This function ...\n-- :param entry:\n-- :return:\nlocal function get_int(entry)\n\treturn tonumber(string.match(entry, \"%d+\"))\nen","completion":""}
{"prompt":"-- Appends an item to a comma-separated string.\n-- If the comma-separated string is empty\/None, just returns item.\nlocal function csv_append(csv_string, item)\n  if not csv_string or csv_string == \"\" then\n    return item\n  else\n    return csv_string .. \",\" .. item\n  end\nen","completion":""}
{"prompt":"-- Reference frame rotation so that MuellerMatrixCompton holds\n-- Args:\n-- azimuth(num): scattering azimuth (degree)\n-- Returns:\n-- angle: rotation of the axes in degrees\nlocal function ComptonRotationAngle(azimuth)\n    return azimuth - 90\nen","completion":""}
{"prompt":"-- Returns the length (number of letters) in the current hand.\n-- hand: dictionary (string int)\n-- returns: integer\nlocal function calculateHandlen(hand)\n    local handlen = 0\n    for k,v in pairs(hand) do\n        handlen = handlen + v\n    end\n    return handlen\nen","completion":""}
{"prompt":"-- Take health and damage and return difference or zero.\nlocal function combat(health, damage)\n\thealth = health - damage\n\tif health < 0 then health = 0 end\n\treturn health\nen","completion":""}
{"prompt":"-- Return a version of name suitable for placement in a newick file\n-- :param name: The name to clean up\n-- :return: a name with no colons, spaces, etc\nlocal function clean_newick_id(name)\n  return name:gsub('[:\\\\%s]', '_')\nen","completion":""}
{"prompt":"-- Compute the matrix transpose\n-- :param matrix: the matrix to be transposed,\n-- the transposing will not modify the input matrix\n-- :return: the transposed of matrix\nlocal function transpose(matrix)\n    local m = {}\n    for i = 1, #matrix do\n        m[i] = {}\n        for j = 1, #matrix[1] do\n            m[i][j] = matrix[j][i]\n        end\n    end\n    return m\nen","completion":""}
{"prompt":"-- This provides a small increment to a pole located mid stream\n-- For use with variable elevation data\nlocal function pole_increment(x, y, t)\n  if x < 50 then return 0, 0 end\n  local l = math.abs(y - 100)\n  local b = math.abs(x - 50)\n  return (y > 100) and 5*b\/l + 10, (x < 50) and 5*b\/l + 10 or 5*b\/l - 10\nen","completion":""}
{"prompt":"-- Returns the ASCII decoded version of the given HTML string. This does\n-- NOT remove normal HTML tags like <p>.\nlocal function html_decode(s)\n  s = s:gsub(\"&amp;\", \"&\")\n  s = s:gsub(\"&lt;\", \"<\")\n  s = s:gsub(\"&gt;\", \">\")\n  s = s:gsub(\"&quot;\", '\"')\n  s = s:gsub(\"&#39;\", \"'\")\n  return s\nen","completion":""}
{"prompt":"-- Returns OK (in green) if supported evaluates to True, otherwise NOT OK (in red).\nlocal function show_supported(supported)\n    if supported then\n        return \"OK\"\n    else\n        return \"NOT OK\"\n    end\nen","completion":""}
{"prompt":"-- Abbreviates descriptions.\n-- >>> _strip_after_punct('Utah: SLC metro')\n-- 'Utah'\nlocal function _strip_after_punct(s)\n    local pattern = '%s*%p+.*$'\n    if string.match(s, pattern) ~= nil then\n        return string.gsub(s, pattern, '')\n    else\n        return s\n    end\nen","completion":""}
{"prompt":"-- Returns the Finabocci's value for 'n' using recursion.\n-- Args:\n-- n (int): number of interactions.\n-- Returns:\n-- int: Fibonacci's value.\nlocal function fib_recursive(n)\n    if n <= 1 then return 1 end\n    return fib_recursive(n - 1) + fib_recursive(n - 2)\nen","completion":""}
{"prompt":"-- Implement `tuple_setitem`.\nlocal function tuple_setitem(data, item, value)\n\tif item == #data then\n\t\tdata[#data + 1] = value\n\telse\n\t\tdata[item + 1] = value\n\tend\n\treturn data\nen","completion":""}
{"prompt":"-- Map entry IDs to human-readable labels.\n-- :arg link_display_label: Marker, which contains the label.\n-- :arg entries: Collection of entries.\nlocal function make_label_index(link_display_label, entries)\n  local id_index = {}\n  local label_index = {}\n  local label_next_id = 1\n  local id_label_pairs = {}\n  local last_id = 0\n  for i, entry in ipairs(entries) do\n    local id = tonumber(entry[link_display_label])\n    if not id then\n      if entry[link_display_label] == '' then\n        id = last_id + 1\n      else\n        error(\"Invalid ID: \" .. tostring(entry[link_display_label]) ..\n              \" for \" .. tostring(entry))\n      end\n    end\n    last_id = id\n    id_index[id] = i\n    id_label_pairs[#id_label_pairs + 1] = {id, entry[link_display_label]}\n  end\n  table.sort(id_label_pairs, function(a, b) return a[1] < b[1] end)\n  for i, pair in ipairs(id_label_pairs) do\n    local id = pair[1]\n    local label = pair[2]\n    label_index[id] = label\n    label_next_id = math.max(label_next_id, id + 1)\n  end\n  return id_index, label_index, label_next_id\nen","completion":""}
{"prompt":"-- Return text_content with leading and trailing whitespace removed\nlocal function _strip_whitespace(text_content)\n\treturn (text_content:gsub(\"^%s*(.-)%s*$\", \"%1\"))\nen","completion":""}
{"prompt":"-- similar to modulo, but 0 and 9 are taken as 9\nlocal function digital_root(num, modulo)\n    if not num or type(num) ~= 'number' then return nil end\n    if modulo == nil or modulo < 2 then modulo = 9 end\n    local remainder = num % modulo\n    if remainder == 0 then\n        return 9\n    else\n        return remainder\n    end\nen","completion":""}
{"prompt":"-- Converts 0 to x, 1 to y, 2 to z, or raises an exception.\nlocal function _named_idx(idx)\n  if idx == 0 then return \"x\"\n  elseif idx == 1 then return \"y\"\n  elseif idx == 2 then return \"z\"\n  else error(\"invalid index: \" .. tostring(idx))\n  end\nen","completion":""}
{"prompt":"-- >>> _prepare_tags({'protocol': 'http'})\n-- ['protocol:http']\nlocal function _prepare_tags(tags)\n\tlocal res = {}\n\tif tags then\n\t\tfor k, v in pairs(tags) do\n\t\t\tres[#res + 1] = k .. \":\" .. v\n\t\tend\n\tend\n\treturn res\nen","completion":""}
{"prompt":"-- Rotate a number num of num_size bits by shift_bits bits. See\n-- https:\/\/en.wikipedia.org\/wiki\/Bitwise_operation#Rotate_no_carry for more information.\n-- :param num: the number to rotate\n-- :param num_size: the size of the number in bits\n-- :param shift_bits: the number of bits the number is rotated by\n-- :return: the rotated number\nlocal function rotate_left(num, num_size, shift_bits)\n    assert(num_size >= shift_bits)\n    local num_mask = (1 << num_size) - 1\n    local shift_mask = (1 << shift_bits) - 1\n    local rotated_num = (num & num_mask) << shift_bits\n    return (rotated_num | (num >> num_size - shift_bits)) & num_mask\nen","completion":""}
{"prompt":"-- Compute needed ribbon for one present.\n-- Arguments l, w, and h are expected to be sorted for a correct result.\nlocal function one_ribbon(l, w, h)\n    local sides = 2 * (w + l)\n    local bow = l * w * h\n    return sides + bow\nen","completion":""}
{"prompt":"-- Removes integers\nlocal function removeNumbers(text)\n\ttext = text:gsub(\"%d+\", \"\")\n\treturn text\nen","completion":""}
{"prompt":"-- yy = yyyy2yy(YYYY)\n-- return the yy form of YYYY\n-- yy - last two digits of YYYY\n-- - returned as an int\n-- very messy hack\nlocal function yyyy2yy(year)\n  year = string.gsub(year, \"%-\",\"\")\n  year = string.gsub(year, \"%.\",\"\")\n  year = string.gsub(year, \"%(\",\"\")\n  year = string.gsub(year, \"%)\",\"\")\n  return tonumber(string.sub(year, 3, 4))\nen","completion":""}
{"prompt":"-- Get parameters from comet_experiment\n-- these parameters are corresponds to hp mentioned in configs\nlocal function get_parameters(comet_experiment, configs)\n    local params = {}\n    for param_name, param_table in pairs(configs) do\n        if type(param_table) == 'table' and param_table.type == 'range' then\n            params[param_name] = comet_experiment:get_parameter(param_name)\n        else\n            params[param_name] = param_table\n        end\n    end\n    return params\nen","completion":""}
{"prompt":"-- Remove CDATA wrapping from `value` if present\nlocal function unwrap_cdata(value)\n  if value:sub(1, 9) == \"<![CDATA[\" and value:sub(-3) == \"]]>\" then\n    return value:sub(10, -4)\n  else\n    return value\n  end\nen","completion":""}
{"prompt":"-- Return a normalized string for use by the template engine\n-- Different sources of data (i.e. the given resource.md files, the jekyll\n-- templates, etc.) expect and use different ways of encoding the names of\n-- various components of the resource object. This function just normalizes\n-- resource fields of the form \"I Have Capital Letters and Spaces\" to the form\n-- \"i_have_capital_letters_and_spaces\" so that the jinja template can properly\n-- render anything thrown at it.\nlocal function normalize_string(s)\n  if type(s) == \"string\" then\n    return s:lower():gsub(\"%s+\", \"_\")\n  end\n  return s\nen","completion":""}
{"prompt":"-- Remaps the value to a new min and max value\n-- Args:\n-- value: value to remap\n-- old_min: old min of range\n-- old_max: old max of range\n-- new_min: new min of range\n-- new_max: new max of range\n-- Returns:\n-- The remapped value in the new range\nlocal function remap(value, old_min, old_max, new_min, new_max)\n\treturn new_min + (new_max - new_min) * (value - old_min) \/ (old_max - old_min)\nen","completion":""}
{"prompt":"-- Problem 6: Determines the difference between the sum of squares and square of sum of defined count of numbers.\n-- Args:\n-- count (int): The count of natural numbers, beginning from 1.\nlocal function project_06_sum_square_difference(count)\n    assert(type(count) == \"number\")\n    local sum_square_total = 0\n    local sum_total = 0\n    for i = 1, count do\n        sum_square_total = sum_square_total + i * i\n        sum_total = sum_total + i\n    end\n    return math.abs(sum_square_total - sum_total * sum_total)\nen","completion":""}
{"prompt":"-- Compute the Damerau-Levenshtein distance between two given strings (s1 and s2)\nlocal function damerau_levenshtein_distance(s1, s2)\n\tlocal m, n = s1:len(), s2:len()\n\tlocal d = {} -- 2D matrix\n\tlocal t = {} -- traceback\n\tlocal cost = 0\n\tfor i = 0, m do\n\t\td[i] = {}\n\t\tt[i] = {}\n\t\tfor j = 0, n do\n\t\t\td[i][j] = 0\n\t\tend\n\tend\n\tfor i = 1, m do\n\t\td[i][0] = i\n\tend\n\tfor j = 1, n do\n\t\td[0][j] = j\n\tend\n\tfor i = 1, m do\n\t\tfor j = 1, n do\n\t\t\tcost = 0\n\t\t\tif s1:sub(i, i) ~= s2:sub(j, j) then\n\t\t\t\tcost = 1\n\t\t\tend\n\t\t\td[i][j] = math.min(d[i-1][j] + 1, d[i][j-1] + 1, d[i-1][j-1] + cost)\n\t\t\tif i > 1 and j > 1 and s1:sub(i, i) == s2:sub(j-1, j-1) and s1:sub(i-1, i-1) == s2:sub(j, j) then\n\t\t\t\td[i][j] = math.min(d[i][j], d[i-2][j-2] + cost)\n\t\t\tend\n\t\tend\n\tend\n\treturn d[m][n]\nen","completion":""}
{"prompt":"-- Nth number of factorial series by bottom-up DP.\n-- - Time complexity: O(n).\n-- - Space complexity: O(n).\nlocal function factorial_dp(n)\n    local dp = {1}\n    for i = 2, n do\n        dp[i] = i * dp[i - 1]\n    end\n    return dp[n]\nen","completion":""}
{"prompt":"-- Simulate a Lorentzian lineshape with unit height at the center.\n-- Simulates discrete points of the continuous Cauchy-Lorentz (Breit-Wigner)\n-- distribution with unit height at the center.  FWHM (full-width at\n-- half-maximum) is used as the scale parameter.\n-- Functional form:\n-- f(x; x0, fwhm) = (0.5 * fwhm)^2 \/ ((x-x0)^2 + (0.5 * fwhm)^2)\n-- Parameters\n-- ----------\n-- x : ndarray\n-- Array of values at which to evaluate distribution.\n-- x0 : float\n-- Center of the distribution.\n-- fwhm : float\n-- Full-width at half-maximum of distribution.\n-- Returns\n-- -------\n-- f : ndarray\n-- Distribution evaluated at points in x.\nlocal function sim_lorentz_fwhm(x, x0, fwhm)\n    return (0.5 * fwhm)^2 \/ ((x-x0)^2 + (0.5 * fwhm)^2)\nen","completion":""}
{"prompt":"-- Go 1 unit in negative y-direction\n-- :param x: x-coordinate of the node\n-- :param y: y-coordinate of the node\n-- :return: new coordinates of the node after moving a unit in the negative y-direction\nlocal function go_down(x, y)\n  return {x, y - 1}\nen","completion":""}
{"prompt":"-- Sharply goes from low to high\nlocal function linear(low, high, x) return (1 - x) * low + x * high en","completion":""}
{"prompt":"-- Return an hour_spec given the start_hour.\n-- Ex. 0 -> H_0000_2000, 22 -> H_2200_0000\nlocal function make_hour_spec(start_hour)\n  local h = (start_hour < 0 and start_hour + 24) or (start_hour % 24)\n  return string.format(\"H_%02d00_%02d00\", h, (h + 2) % 24)\nen","completion":""}
{"prompt":"-- Gets the last component of a path.\n-- Arguments:\n-- path -- File path.\nlocal function basename(path)\n    return (path:gsub('^.*[\\\\\/]', ''))\nen","completion":""}
{"prompt":"-- assumes x an int >= 0:\n-- returns Fibonacci of x:\nlocal function fib(x)\n    if x == 0 or x == 1 then\n        return 1\n    else\n        return fib(x-1) + fib(x-2)\n    end\nen","completion":""}
{"prompt":"-- returns (t,z,y,z) dimensions of a spim stack\nlocal function parseIndexFile(fname)\n  local f = io.open(fname, \"r\")\n  if not f then return nil end\n  local d = f:read(\"*n\") -- read first line\n  f:close()\n  if d == nil then return nil end\n  return d, d, d, d\nen","completion":""}
{"prompt":"-- Combine a list of regexes into one that matches any of them.\nlocal function join_regex(regexes)\n  local regex = '(?:' .. table.concat(regexes, ')|(?:') .. ')'\n  return regex\nen","completion":""}
{"prompt":"-- Returns the net open and closed parentheses.\nlocal function countParen(line)\n\tlocal paren = 0\n\tfor c in line:gmatch\".\" do\n\t\tif c == \"(\" then paren = paren + 1\n\t\telseif c == \")\" then paren = paren - 1 end\n\tend\n\treturn paren\nen","completion":""}
{"prompt":"-- Fuction to get ceil number.\nlocal function ceil_div_mul(value, factor)\n    return math.ceil(value \/ factor) * factor\nen","completion":""}
{"prompt":"-- Creates a single flat list out of a given list containing nested lists.\n-- Examples:\n-- >>> nested_list = [1, [2], [[3], 4], 5]\n-- >>> flatten_nested_arrays(nested_list)\n-- [1, 2, 3, 4, 5]\n-- >>> more_nesting = [1, [2], [[3,[7,8,9]], 4], 5]\n-- >>> flatten_nested_arrays(more_nesting)\n-- [1, 2, 3, 7, 8, 9, 4, 5]\n-- References:\n-- https:\/\/www.youtube.com\/watch?v=pG3L2Ojh1UE\nlocal function flatten_nested_arrays(lst)\n  local flat = {}\n  local function flatten(lst)\n    for _,v in ipairs(lst) do\n      if type(v) == \"table\" then\n        flatten(v)\n      else\n        flat[#flat + 1] = v\n      end\n    end\n  end\n  flatten(lst)\n  return flat\nen","completion":""}
{"prompt":"-- Map in value range to another range\nlocal function translate(x, lowerIn, upperIn, lowerOut, upperOut)\n  return lowerOut + (upperOut - lowerOut) * (x - lowerIn) \/ (upperIn - lowerIn)\nen","completion":""}
{"prompt":"-- Get list of items from `list_str`\n-- >>> list_from_string(None)\n-- []\n-- >>> list_from_string(\"\")\n-- []\n-- >>> list_from_string(\"  \")\n-- []\n-- >>> list_from_string(\"a\")\n-- ['a']\n-- >>> list_from_string(\"a  \")\n-- ['a']\n-- >>> list_from_string(\"a b  c\")\n-- ['a', 'b', 'c']\nlocal function list_from_string(list_str)\n    if list_str == nil or list_str == \"\" then\n        return {}\n    end\n    local list = {}\n    for word in list_str:gmatch('([^%s]+)') do\n        table.insert(list, word)\n    end\n    return list\nen","completion":""}
{"prompt":"-- horsepower Function\n-- Calculates the power (in horsepower) given\n-- the power in watts.\n-- Parameters\n-- ----------\n-- watts:      float\n-- The wattage to compute.\n-- Returns\n-- -------\n-- hp:         float\n-- The power in horsepower.\nlocal function horsepower(watts)\n  return watts \/ 745.699872\nen","completion":""}
{"prompt":"-- Normalizes transformation matrix.\n-- * **value** must be an ``tuple`` or ``list``.\n-- * **value** must have exactly six items. Each of these\n-- items must be an instance of :ref:`type-int-float`.\n-- * Returned value is a ``tuple`` of six ``float``.\nlocal function normalizeTransformationMatrix(value)\n  if type(value) == \"table\" then\n    local tuple = {}\n    local length = #value\n    if length == 6 then\n      for index, item in ipairs(value) do\n        if type(item) == \"number\" then\n          tuple[index] = item\n        else\n          return false\n        end\n      end\n      return tuple\n    else\n      return false\n    end\n  else\n    return false\n  end\nen","completion":""}
{"prompt":"-- Returns a float from a string\nlocal function as_float(s)\n\treturn tonumber(s) or 0\nen","completion":""}
{"prompt":"-- Find factors of a number.\nlocal function find_factors(b)\n  local factors = {}\n  for i = 1, b do\n    if b % i == 0 then table.insert(factors, i) end\n  end\n  return factors\nen","completion":""}
{"prompt":"-- Crops address and returns new variant\n-- >>> crop_address(\"Jo's Cafe, San Marcos, Texas, USA\")\n-- ' San Marcos, Texas, USA'\n-- >>> crop_address(\"San Marcos, Texas, USA\")\n-- ' Texas, USA'\n-- >>> crop_address(\" Texas, USA\")\n-- ' USA'\nlocal function crop_address(place)\n   local addr = string.gsub(place, \",%s*\", \", \")\n   local pos = string.find(addr, \", \")\n   if pos then\n      return string.sub(addr, pos + 1)\n   end\n   return \"\"\nen","completion":""}
{"prompt":"-- :param d: Distance from v1 to the side of v2, from 0.0 to 1.0\nlocal function _inter_cubic_inner(d, v0, v1, v2, v3)\n    local d2 = d * d\n    local d3 = d2 * d\n    return v1 + 0.5 * d * (v2 - v0 + d * (2.0 * v0 - 5.0 * v1 + 4.0 * v2 - v3 + d * (3.0 * (v1 - v2) + v3 - v0)))\nen","completion":""}
{"prompt":"-- Fast implimentation of a function to strip out non-unique entries in a Python list, but preserving list order.\n-- Usage:\n-- >>> print(uniquify( [1,4,2,4,7,2,1,1,1,'s','a',0.1] ) )\n-- [1, 4, 2, 7, 's', 'a', 0.10000000000000001]\nlocal function uniquify(seq)\n  local hash = {}\n  local unique = {}\n  for _,v in ipairs(seq) do\n    if ( hash[v] == nil ) then\n      hash[v] = true\n      unique[#unique+1] = v\n    end\n  end\n  return unique\nen","completion":""}
{"prompt":"-- Find the maximum prime factor.\nlocal function max_factor(num)\n  local f = 2\n  while f^2 <= num do\n    if num % f == 0 then\n      num = num \/ f\n      if f > 2 then\n        f = 2\n      end\n    else\n      f = f + 1\n    end\n  end\n  return num\nen","completion":""}
{"prompt":"-- Debe regresar la lista con los primeros n numeros de fibonacci.\n-- Para n<1, regresar [].\n-- Para n=1, regresar [1].\n-- Para n=2, regresar [1,1].\n-- Para n=3, regresar [1,1,2].\n-- Para n=4, regresar [1,1,2,3].\n-- Y sucesivamente\nlocal function fibonacci(n)\n  local fib = {}\n  if n < 1 then\n    return fib\n  elseif n == 1 then\n    return {1}\n  elseif n == 2 then\n    return {1,1}\n  elseif n == 3 then\n    return {1,1,2}\n  elseif n == 4 then\n    return {1,1,2,3}\n  else\n    fib = {1,1,2,3}\n    for i = 4,n do\n      fib[i] = fib[i-1] + fib[i-2]\n    end\n    return fib\n  end\nen","completion":""}
{"prompt":"-- Will return a string representation of the num with 2 digits. e.g. 6 => 06\nlocal function twoDigit(num)\n\treturn string.format(\"%02d\", num)\nen","completion":""}
{"prompt":"-- Returns the date from a commit JSON object.\nlocal function get_commit_date(commit)\n  return commit.commit.author.date\nen","completion":""}
{"prompt":"-- Binomial coefficients, thanks to Andrew Dalke.\nlocal function binomial(n, k)\n    if (k < 0 or k > n) then return 0 end\n    if (k == 0 or k == n) then return 1 end\n    local r = 1\n    for i = 1, k do\n        r = (r * (n - k + i)) \/ i\n    end\n    return r\nen","completion":""}
{"prompt":"-- Parses the parameters given from POST or websocket reqs\n-- expecting the parameters as:  \"11|par1='asd'|6|par2=1\"\n-- returns a dict like {par1:'asd',par2:1}\nlocal function parse_parametrs(p)\n    local parameters = {}\n    for name, value in string.gmatch(p, '([^|]+)=([^|]+)') do\n        parameters[name] = value\n    end\n    return parameters\nen","completion":""}
{"prompt":"-- Computes the index of the optimal (p_vars) in the optimal solution of the Exponential Cone Programming\n-- Args:\n-- i: int\n-- Returns:\n-- int\nlocal function sp_vidx(i)\n\treturn (i * 3) + 1\nen","completion":""}
{"prompt":"-- calculates the number of pages required for the image\nlocal function get_number_of_pages(image_size, page_size)\n    return math.ceil(image_size \/ page_size)\nen","completion":""}
{"prompt":"-- Wrapper to quickly change the rectified linear unit function\nlocal function relu_f(vec)\n\tif vec > 0 then\n\t\treturn vec\n\tend\n\treturn 0\nen","completion":""}
{"prompt":"-- Bulds a matrix of size rows x columns, with val values in cells\n-- NOTE: Does not checks negative values\n-- Parameters\n-- ----------\n-- rows(int) : The number of rows of the matrix\n-- columns(int) : The number of columns of the matrix\n-- val(int) : The value in every cell of the matrix\n-- Returns\n-- -------\n-- list : The matrix\nlocal function matrix(rows, columns, val)\n    local matrix = {}\n    for i = 1, rows do\n        matrix[i] = {}\n        for j = 1, columns do\n            matrix[i][j] = val\n        end\n    end\n    return matrix\nen","completion":""}
{"prompt":"-- A list of cooperation ratings for each player\n-- Parameters\n-- ----------\n-- cooperation : list\n-- The cooperation matrix\n-- nplayers : integer\n-- The number of players in the tournament.\n-- turns : integer\n-- The number of turns in each round robin.\n-- repetitions : integer\n-- The number of repetitions in the tournament.\n-- Returns\n-- -------\n-- list\n-- a list of cooperation rates ordered by player index\nlocal function cooperating_rating(cooperation, nplayers, turns, repetitions)\n    local player_ratings = {}\n    local nratings = repetitions * turns\n    for player_index = 1, nplayers do\n        local rating = 0\n        for repetition = 1, repetitions do\n            local cooperative_count = 0\n            for turn = 1, turns do\n                if cooperation[turn][player_index] == 1 then\n                    cooperative_count = cooperative_count + 1\n                end\n            end\n            rating = rating + cooperative_count\n        end\n        player_ratings[player_index] = rating \/ nratings\n    end\n    return player_ratings\nen","completion":""}
{"prompt":"-- The color white.\n-- HEX = #FFFFFF\n-- RGB = 255, 255, 255\n-- CMYK = 0, 0, 0, 0\nlocal function white()\n    return { 1, 1, 1 }\nen","completion":""}
{"prompt":"-- int array to #rrggbb\nlocal function formatColoria(a)\n    return string.format(\"#%02x%02x%02x\",a[1],a[2],a[3])\nen","completion":""}
{"prompt":"-- fct to convert angles from meteorological convention to\n-- oceanographic\/nautical and vice versa.\nlocal function convert_meteorologic_oceanographic(alpha)\n    return (alpha + 180) % 360\nen","completion":""}
{"prompt":"-- Compute a beta model\n-- Parameters\n-- ----------\n-- - r3d_kpc: array of radius in kpc\n-- - r_c : core radius parameter\n-- - n_0  : normalization\n-- - beta : slope of the profile\n-- Outputs\n-- --------\n-- - beta model profile as a function of the input radius vector\nlocal function beta_model(r3d_kpc, n0, r_c, beta)\n    local beta_model_f = function (r3d_kpc, n0, r_c, beta)\n        local r3d = r3d_kpc * 1000\n        return n0 * (1 + r3d \/ r_c)^beta\n    end\n    return beta_model_f(r3d_kpc, n0, r_c, beta)\nen","completion":""}
{"prompt":"-- Get a class module from its name.\nlocal function get_class(class_name)\n  return class_name and class_module(class_name) or nil\nen","completion":""}
{"prompt":"-- Adjust B-allele frequencies for sample purity.\n-- Math::\n-- t_baf*purity + n_baf*(1-purity) = obs_baf\n-- obs_baf - n_baf * (1-purity) = t_baf * purity\n-- t_baf = (obs_baf - n_baf * (1-purity))\/purity\nlocal function rescale_baf(purity, observed_baf, normal_baf)\n  if not purity or not observed_baf then\n    return nil\n  end\n  if not normal_baf then\n    return observed_baf\n  end\n  return (observed_baf - normal_baf * (1 - purity)) \/ purity\nen","completion":""}
{"prompt":"-- rotates the direction counter-clockwise\nlocal function left(direction)\n\treturn (direction - 1) % 4\nen","completion":""}
{"prompt":"-- takes a number (essentially base 4)\n-- and returns the kmer it corresponds to in alphabetical order\n-- eg.\n-- AAAA = 0*1\n-- CA = 4*4 + 0*1\n-- GC = 3*4 + 1 * 1\nlocal function get_kmer_from_index(kmax, index)\n  local kmer = \"\"\n  for i=1,kmax do\n    local val = math.floor(index\/math.pow(4,kmax-i)) % 4\n    if val == 0 then\n      kmer = kmer .. \"A\"\n    elseif val == 1 then\n      kmer = kmer .. \"C\"\n    elseif val == 2 then\n      kmer = kmer .. \"G\"\n    elseif val == 3 then\n      kmer = kmer .. \"T\"\n    end\n  end\n  return kmer\nen","completion":""}
{"prompt":"-- This function takes in a pair of coordinates (either from the latitude or longitude) and breaks the entire range\n-- into multiple intervals, whereby each interval is the size of one side of the query box. The coordinates marking\n-- each interval is then stored in a list and returned as an output.\nlocal function generate_coordinate_list(min_coordinate, max_coordinate, num_box)\n\tlocal increment = (max_coordinate - min_coordinate) \/ num_box\n\tlocal list = {}\n\tfor i = 0, num_box do\n\t\ttable.insert(list, min_coordinate + (increment * i))\n\tend\n\treturn list\nen","completion":""}
{"prompt":"-- \"Linear intrpolation between v1, v2\nlocal function lerp(r, v1, v2)\n    local v = {}\n    for i = 1, #v1 do\n        v[i] = v1[i] + r * (v2[i] - v1[i])\n    end\n    return v\nen","completion":""}
{"prompt":"-- Set a bit to on `1`\nlocal function set_bit(bb, bit)\n   return bb | (1 << bit)\nen","completion":""}
{"prompt":"-- Return line with $ notation replaced by dictionary reference\nlocal function dollarsign(line)\n    -- $1 is a simple variable reference, $2 is a variable with a default,\n    -- $[1-9] is a reference to a capture group, ${1-9} is a reference to a named capture group\n    -- $n where n is greater than the number of captured sub-expressions is an error\n    -- $0 refers to the whole matched string, $' refers to the whole matched string\n    -- $& refers to the whole matched string\n    -- $+ refers to the last group that matched\n    -- $` refers to the string preceding the matched string\n    -- $' refers to the string following the matched string\n    return line:gsub(\"[$%`%&%'+%.%(%)%[%^%$%%]%d%a%W]\", \" \")\nen","completion":""}
{"prompt":"-- greatest common divisor\n-- :param a:\n-- :param b:\n-- :return:\nlocal function gcd1(a, b)\n    if b == 0 then\n        return a\n    end\n    return gcd1(b, a % b)\nen","completion":""}
{"prompt":"-- Generates the first n Fibonacci numbers.\n-- Adopted from: https:\/\/docs.python.org\/3\/tutorial\/modules.html\nlocal function fibonacci(n)\n  local result = {}\n  local a = 0\n  local b = 1\n  for i = 1, n do\n    table.insert(result, b)\n    local c = a + b\n    a = b\n    b = c\n  end\n  return result\nen","completion":""}
{"prompt":"-- Return the number of positive factors that n has.\n-- >>> count_factors(6)   # 1, 2, 3, 6\n-- 4\n-- >>> count_factors(4)   # 1, 2, 4\n-- 3\nlocal function count_factors(n)\n  local count = 0\n  for i = 1, n do\n    if n % i == 0 then\n      count = count + 1\n    end\n  end\n  return count\nen","completion":""}
{"prompt":"-- Plays a single round of the combat game.\n-- This function returns the decks after one round.\nlocal function play_round(decks)\n  local card_1 = table.remove(decks[1], 1)\n  local card_2 = table.remove(decks[2], 1)\n  if card_1 > card_2 then\n    table.insert(decks[1], card_1)\n    table.insert(decks[1], card_2)\n  else\n    table.insert(decks[2], card_2)\n    table.insert(decks[2], card_1)\n  end\n  return decks\nen","completion":""}
{"prompt":"-- Assume .mst extension if missing\nlocal function normalize_path(filepath)\n    local _, ext = filepath:match(\"(.-)%.(%w+)$\")\n    if not ext then\n        return filepath .. \".mst\"\n    else\n        return filepath\n    end\nen","completion":""}
{"prompt":"-- Bit manipulation using xor\n-- example --> any number xored with 0 = the number itself\n-- --> 7 ^ 0 = 7\n-- --> 7 ^ 7 = 0\nlocal function single2(arr)\n  local result = arr[1]\n  for i=2,#arr,1 do\n    result = result ~ arr[i]\n  end\n  return result\nen","completion":""}
{"prompt":"-- Round down an integer.\nlocal function round_down(i, k)\n  return math.floor(i \/ k) * k\nen","completion":""}
{"prompt":"-- The partial derivative with respect to parameter {@code a}\n-- for vertex form of quadratic function\n-- :param x: independent variable\n-- :param a: coefficient {a} of quadratic function\n-- :param b: the x coordinates of the vertex\n-- :param c: the y coordinates of the vertex\n-- :return:(x - b) ** 2\nlocal function quadratic_vertex_derivative_a(x, a, b, c)\n   return (x - b) * (x - b)\nen","completion":""}
{"prompt":"-- Converts square meters to hectares, and gives val to 2 decimal places\nlocal function squaremeters_to_ha(value)\n  if not value then\n    return nil\n  end\n  local result = value \/ 10000\n  result = result * 100\n  result = math.floor(result + 0.5) \/ 100\n  return result\nen","completion":""}
{"prompt":"-- Limits\/clamps the value n between the min and max.\nlocal function f_limit(value, minval, maxval)\n    return math.max(minval, math.min(value, maxval))\nen","completion":""}
{"prompt":"-- Return a proper 2 decimal currency value\n-- :param value: Currency amount\n-- :return: currency value string\nlocal function format_dollar(value)\n\treturn string.format(\"%.2f\", value)\nen","completion":""}
{"prompt":"-- >>> IN2(1, [1,2,3])\n-- False\n-- >>> IN2([1,2,3], 1)\n-- True\n-- >>> IN2([2,3], 1)\n-- False\n-- >>> IN2(\"hello abc world\", \"abc\")\n-- True\n-- >>> IN2(\"hello abc world\", \"xyz\")\n-- False\nlocal function IN2(a, b)\n    local t = type(a)\n    if t == \"table\" then\n        for k, v in pairs(a) do\n            if v == b then\n                return true\n            end\n        end\n        return false\n    elseif t == \"string\" then\n        return string.find(a, b, 1, true) ~= nil\n    end\n    return a == b\nen","completion":""}
{"prompt":"-- Determinant of 2x2 matrix\nlocal function det2(a, b, c, d)\n    return a * d - b * c\nen","completion":""}
{"prompt":"-- Calculates the tensor product of two vectors.\nlocal function _kron(vec0, vec1)\n\tlocal kron = {}\n\tfor i, v in ipairs(vec0) do\n\t\tfor j, w in ipairs(vec1) do\n\t\t\tkron[#kron + 1] = v * w\n\t\tend\n\tend\n\treturn kron\nen","completion":""}
{"prompt":"-- Render the group by part of a query.\n-- Parameters\n-- ----------\n-- fields : list\n-- A list of fields to group by.\n-- Returns\n-- -------\n-- str\n-- A string that represents the \"group by\" part of a query.\nlocal function _render_groupings(fields)\n  if fields and #fields > 0 then\n    return ('GROUP BY %s'):format(table.concat(fields, ', '))\n  else\n    return ''\n  end\nen","completion":""}
{"prompt":"-- Convert negative index to positive index if needed\nlocal function fix_index(index, size)\n    if index < 0 then\n        index = index + size\n    end\n    return index\nen","completion":""}
{"prompt":"-- Wrapper around cgi.escape deprecation.\nlocal function html_escape(val)\n  local ok, res = pcall(function() return cgi.escape(tostring(val)) end)\n  if ok then\n    return res\n  else\n    -- fallback\n    return (tostring(val):gsub('[&\"\\'<>]', {\n      ['&'] = '&amp;',\n      ['\"'] = '&quot;',\n      [\"'\"] = '&#x27;',\n      ['<'] = '&lt;',\n      ['>'] = '&gt;',\n    }))\n  end\nen","completion":""}
{"prompt":"-- Ordinalize a number.\n-- Examples\n-- --------\n-- >>> [ordinalize(n) for n in range(1, 4 + 1)]\n-- ['1st', '2nd', '3rd', '4th']\nlocal function ordinalize(n)\n  local mod10 = n % 10\n  local mod100 = n % 100\n  if mod10 == 1 and mod100 ~= 11 then\n    return n .. 'st'\n  elseif mod10 == 2 and mod100 ~= 12 then\n    return n .. 'nd'\n  elseif mod10 == 3 and mod100 ~= 13 then\n    return n .. 'rd'\n  else\n    return n .. 'th'\n  end\nen","completion":""}
{"prompt":"-- Calculates the real roots of cubic equation. Note: returns only the _real_ roots!\n-- Code as found at http:\/\/www.josechu.com\/ecuaciones_polinomicas\/\nlocal function cubicRealRoot(a, b, c, d)\n\tlocal det = b*b - 3*a*c\n\tif det < 0 then\n\t\treturn 0\n\telse\n\t\tdet = math.sqrt(det)\n\t\tlocal x1 = (det - b) \/ (3 * a)\n\t\tlocal x2 = (2 * c - b * x1) \/ a\n\t\treturn x1, x2\n\tend\nen","completion":""}
{"prompt":"-- Get a list of [input path, output dictionary] pairs where each\n-- element of the list has at least `task` as a key in the output dictionary.\nlocal function get_task_pairs(data_list, task)\n   local task_pairs = {}\n   for _, data_pair in ipairs(data_list) do\n      if data_pair[2][task] then\n         table.insert(task_pairs, data_pair)\n      end\n   end\n   return task_pairs\nen","completion":""}
{"prompt":"-- Returns a list of integers representing\n-- the word lengths in string s.\nlocal function get_word_lengths(s)\n  local word_lengths = {}\n  for word in string.gmatch(s, \"(%a+)\") do\n    table.insert(word_lengths, string.len(word))\n  end\n  return word_lengths\nen","completion":""}
{"prompt":"-- Returns Sunset as float with Solar Noon Float, solar_noon_float\n-- and Hour Angle Deg, hour_angle_deg\nlocal function sunset_float(solar_noon_float, hour_angle_sunrise)\n  return solar_noon_float + hour_angle_sunrise \/ 360\nen","completion":""}
{"prompt":"-- Compute the nth pentagonal number\nlocal function nth_pentagonal(n)\n  return (n*(3*n-1))\/2\nen","completion":""}
{"prompt":"-- Returns x bounded by a maximum and minimum value. Equivalent to:\n-- return min(max(x, lower), higher)\nlocal function bound(lower, x, higher)\n  return (x < lower and lower) or (x > higher and higher) or x\nen","completion":""}
{"prompt":"-- Calcualtes the amount of interest added to the balance each months\n-- :param total_balance: Total debt left\n-- :type total_balance: float\n-- :param monthly_interest: Monthly interest in %\n-- :type monthly_interest: float\nlocal function calculate_monthly_interest(total_balance, monthly_interest)\n    local monthly_interest_amount = total_balance * monthly_interest \/ 100\n    return math.floor(monthly_interest_amount)\nen","completion":""}
{"prompt":"-- Parse a dict() to get keys of elements with a specified value\n-- :param dict_of_elements:\n-- :param value_to_find:\n-- :return:\nlocal function get_keys_by_value(dict_of_elements, value_to_find)\n    local keys = {}\n    for k,v in pairs(dict_of_elements) do\n        if v == value_to_find then\n            table.insert(keys, k)\n        end\n    end\n    return keys\nen","completion":""}
{"prompt":"-- Calculate the vertex-wise cortical contrast.\n-- - cortical contrast = (mean WM intensity) - (mean GM intensity) \/\n-- ( (mean WM intensity + mean GM intensity) \/ 2 )\n-- :type mean_gm: float\n-- :param mean_gm: The mean value of the gray matter voxels.\n-- :type mean_wm: float\n-- :param mean_wm: The mean value of the white matter voxels.\n-- :rtype: float\n-- :return: The cortical contrast value.\nlocal function cortical_contrast(mean_gm, mean_wm)\n  local cortical_contrast = 0.0\n  if mean_gm > mean_wm then\n    cortical_contrast = mean_gm - mean_wm\n  else\n    cortical_contrast = mean_wm - mean_gm\n  end\n  return cortical_contrast \/ ((mean_wm + mean_gm) \/ 2.0)\nen","completion":""}
{"prompt":"-- Write base-10 numbers using the alphabet 'qrstuvwxyz', so that they won't be\n-- normalized away.\nlocal function _numbers_to_letters(num)\n    local base = \"qrstuvwxyz\"\n    local str = \"\"\n    if num == 0 then\n        str = base:sub(1, 1)\n    else\n        while num > 0 do\n            local remainder = num % 26\n            str = base:sub(remainder+1, remainder+1) .. str\n            num = (num - remainder) \/ 26\n        end\n    end\n    return str\nen","completion":""}
{"prompt":"-- Deze functie kijkt of de lengte van de read groter is dan 30 .\n-- Wanneer dit niet zo is wordt de read als leeg gereturned.\n-- Anders wordt er niks met de read gedaan.\nlocal function Trimmen_3(trim_2_2)\n\tif trim_2_2:len() > 30 then\n\t\treturn trim_2_2\n\telse\n\t\treturn ''\n\tend\nen","completion":""}
{"prompt":"-- Args:\n-- _epoch:           e.g. 2\n-- Returns:\n-- _checkpoint_name: e.g. 'epoch=2.ckpt'\nlocal function epoch2checkpoint(_epoch)\n  return string.format('epoch=%d.ckpt', _epoch)\nen","completion":""}
{"prompt":"-- Revert k:v to v:k\nlocal function get_reverted_disk_rses_id_name_map(disk_rses_id_name_map)\n    local reverted_disk_rses_id_name_map = {}\n    for id, name in pairs(disk_rses_id_name_map) do\n        reverted_disk_rses_id_name_map[name] = id\n    end\n    return reverted_disk_rses_id_name_map\nen","completion":""}
{"prompt":"-- We need to sort the dictionaries by key to ensure that questions are\n-- presented in the correct order\nlocal function sort_by_key(dictionary)\n\tlocal keys = {}\n\tfor k in pairs(dictionary) do table.insert(keys, k) end\n\ttable.sort(keys)\n\tlocal new_dict = {}\n\tfor _, k in ipairs(keys) do new_dict[k] = dictionary[k] end\n\treturn new_dict\nen","completion":""}
{"prompt":"-- Return a list containing all the numbers from (f) to (t),\n-- inclusive, in steps of (step).\n-- @param f [number]\n-- @param t [number]\n-- @param step [number]\n-- @return [list]\nlocal function fromtostep(f, t, step)\n  local ret = {}\n  if step > 0 then\n    for i = f, t, step do\n      table.insert(ret, i)\n    end\n  elseif step < 0 then\n    for i = f, t, step do\n      table.insert(ret, i)\n    end\n  end\n  return ret\nen","completion":""}
{"prompt":"-- No shifting and better for N0 situation\nlocal function popcount1(n)\n    local count = 0\n    while n > 0 do\n        count = count + (n % 2)\n        n = math.floor(n \/ 2)\n    end\n    return count\nen","completion":""}
{"prompt":"-- restrict a single coordinate to 0-255\nlocal function _clamp(coordinate)\n  if coordinate < 0 then\n    return 0\n  elseif coordinate > 255 then\n    return 255\n  end\n  return coordinate\nen","completion":""}
{"prompt":"-- Returns the base 10 order of magnitude of a number\nlocal function order(x, count)\n\tlocal o = 0\n\twhile x >= 10 do\n\t\tx = x \/ 10\n\t\to = o + 1\n\tend\n\treturn o\nen","completion":""}
{"prompt":"-- Prepares a summary line by formatting it.\n-- Args:\n-- cost: The cost of the summary line item.\n-- currency: The currency to append to the summary line item.\n-- Returns:\n-- The formatted summary line.\nlocal function prepare_summary_line(cost, currency)\n\treturn string.format(\"%s %s\", cost, currency)\nen","completion":""}
{"prompt":"-- Return boolean mask for paired target conditions.\n-- This function returns a mask indicating which start\/end target conditions\n-- in the provided lists come from a paired set.  For example, the entry for a\n-- a target condition 'T1 -> T5' will have a corresponding value of True if\n-- 'T5 -> T1' also exists in the data.\n-- Inputs:\n-- start_cond - List of strings indicating starting conditions\n-- end_cond - List of strings indicating ending conditions\n-- Returns:\n-- mask - List of boolean indicating whether each of the input elements is\n-- part of a pair\nlocal function get_targ_pairs(start_cond, end_cond)\n  local mask = {}\n  for i=1,#start_cond do\n    local count = 0\n    for j=1,#end_cond do\n      if start_cond[i] == end_cond[j] then\n        mask[i] = true\n        count = count + 1\n      end\n    end\n    if count > 1 then\n      error('Error: The start condition '.. start_cond[i] ..' is part of multiple pairs')\n    elseif count == 0 then\n      mask[i] = false\n    end\n  end\n  return mask\nen","completion":""}
{"prompt":"-- Find longest word in ``reading``.\n-- :param reading: the full string object to be spritzed\n-- :type reading: ``unicode``\n-- :returns: number of characters in the longest word\n-- :rytpe: ``integer``\nlocal function find_max(reading)\n  local max_length = 0\n  local max_index = 0\n  for i = 1, #reading do\n    if string.match(reading, \"[^%s%p]\", i) then\n      local length = string.match(reading, \"[^%s%p]\", i):len()\n      if length > max_length then\n        max_length = length\n        max_index = i\n      end\n    end\n  end\n  return max_index, max_length\nen","completion":""}
{"prompt":"-- >>> _segmentrepr([1, [2, 3], [], [[2, [3, 4], [0.1, 2.2]]]])\n-- '(1, (2, 3), (), ((2, (3, 4), (0.1, 2.2))))'\nlocal function _segmentrepr(obj)\n  if obj == nil then\n    return '()'\n  elseif type(obj) == 'number' then\n    return ('%g'):format(obj)\n  elseif type(obj) == 'table' then\n    local str = '('\n    for i, v in ipairs(obj) do\n      if i > 1 then\n        str = str .. ', '\n      end\n      if type(v) == 'table' then\n        str = str .. _segmentrepr(v)\n      elseif type(v) == 'string' then\n        str = str .. '\"' .. v .. '\"'\n      else\n        str = str .. _segmentrepr(v)\n      end\n    end\n    return str .. ')'\n  else\n    return tostring(obj)\n  end\nen","completion":""}
{"prompt":"-- remove first occurance of trailing parentheses from a string\nlocal function remove_paren(v)\n  return string.gsub(v, '%s*%(.*', '')\nen","completion":""}
{"prompt":"-- Function needed for backwards compatibility with the old \"col\" argument in\n-- plt functions. It returns the default color 'C0' if both arguments are None.\n-- If 'color' is not None, it always uses that. If 'color' is None and \n-- 'col' is an integer, it returns the corresponding 'CN' color. If 'col' is\n-- neither None nor integer, an error is raised.\nlocal function get_color(col, color)\n    if col == nil then\n        return color or 'C0'\n    elseif type(col) == 'number' then\n        return ('C%d'):format(col)\n    else\n        error('col must be integer or None')\n    end\nen","completion":""}
{"prompt":"-- Encode a config topic to UTF-8.\nlocal function encode_config_topic(string)\n    return string.gsub(string, \"[^%w%p%s]\", function(char)\n        return string.format(\"%%%02X\", string.byte(char))\n    end)\nen","completion":""}
{"prompt":"-- Substitutes extra contiguous whitespaces with a single whitespace\nlocal function normalize_whitespace(sent)\n  sent = sent:gsub(\"%s+\", \" \")\n  return sent:gsub(\"^%s+\", \"\"):gsub(\"%s+$\", \"\")\nen","completion":""}
{"prompt":"-- Get the smallest divisible number by all [1..max_factor] numbers by brute force.\nlocal function get_smallest_divisible_number_brute_force(max_factor)\n    local result = 1\n    while true do\n        local divisible = true\n        for factor = 2, max_factor do\n            if result % factor ~= 0 then\n                divisible = false\n                break\n            end\n        end\n        if divisible then\n            return result\n        end\n        result = result + 1\n    end\nen","completion":""}
{"prompt":"-- Forces value to be in [-1, 1]\n-- Parameters\n-- ----------\n-- x: float, int\n-- The value to adjust.\n-- Retruns\n-- -------\n-- float\n-- The adjusted value.\nlocal function unit_limit(x)\n    return math.min(1, math.max(-1, x))\nen","completion":""}
{"prompt":"-- Parse \"state\" column from `qstat` output for given job_id\n-- Returns state for the *first* job matching job_id. Returns 'u' if\n-- `qstat` output is empty or job_id is not found.\nlocal function _parse_qstat_state(qstat_out, job_id)\n    if qstat_out ~= nil and job_id ~= nil then\n        for line in qstat_out:gmatch(\"[^\\r\\n]+\") do\n            if string.match(line, job_id) then\n                -- Matching line found, extract state from it\n                return string.match(line, \"([A-Z]+)\")\n            end\n        end\n    end\n    -- No matching line found, return undetermined\n    return \"u\"\nen","completion":""}
{"prompt":"-- Given a pair of feed indices, return the pair index.\n-- Parameters\n-- ----------\n-- i, j : integer\n-- Feed index.\n-- n : integer\n-- Total number of feeds.\n-- Returns\n-- -------\n-- pi : integer\n-- Pair index.\nlocal function cmap(i, j, n)\n  if i > j then\n    i, j = j, i\n  end\n  local pi = i * n - (i * (i - 1)) \/ 2 + j - i\n  return pi\nen","completion":""}
{"prompt":"-- Adds `suffix` to every element of `signals`.\nlocal function add_suffix(signals, suffix)\n   local new_signals = {}\n   for _, signal in ipairs(signals) do\n      new_signals[#new_signals + 1] = signal .. suffix\n   end\n   return new_signals\nen","completion":""}
{"prompt":"-- Remove wrapping quotes from a string.\n-- :param value: A string that might be wrapped in double quotes, such\n-- as a HTTP cookie value.\n-- :returns: Beginning and ending quotes removed and escaped quotes (``\"``)\n-- unescaped\nlocal function unquote(value)\n  -- Remove beginning and ending quotes and unescape escaped quotes.\n  return value:gsub(\"^%s*\\\"(.-)\\\"%s*$\", function(v)\n    return v:gsub(\"\\\\\\\"\", \"\\\"\")\n  end)\nen","completion":""}
{"prompt":"-- The absorption coefficient\n-- :param transmission_coef: the transmission coefficient\n-- :param reflection_coef: the reflection coefficient\n-- :return: The absorption coefficient\nlocal function absorption_coefficient(transmission_coef, reflection_coef)\n  return 1 - (transmission_coef + reflection_coef)\nen","completion":""}
{"prompt":"-- Raises\n-- ------\n-- ValueError if broadcast fails\nlocal function _broadcast_axis(a, b)\n   if a == b then\n      return a\n   end\n   if a == 1 then\n      return b\n   elseif b == 1 then\n      return a\n   else\n      error(\"axes can be broadcasted only if one of them is 1\")\n   end\nen","completion":""}
{"prompt":"-- Convert None to empty string.\n-- Necessary for fields that are required POST but have no logical value.\nlocal function none_to_empty(val)\n    return (val == nil) and \"\" or val\nen","completion":""}
{"prompt":"-- converts lattice integer to RGB tuple\n-- :param x: int\n-- :return: RGB\nlocal function int2color(x)\n    return {\n        ((x >> 16) & 0xff),\n        ((x >> 8) & 0xff),\n        (x & 0xff)\n    }\nen","completion":""}
{"prompt":"-- Calculates the array of bytes that must be included into an ASN1 Tag to correctly\n-- represent its length\n-- :param value: the size of the tag\n-- :return: the array of integers\nlocal function lenToBytes(value)\n    if value < 128 then\n        return { value }\n    end\n    local bytes = { }\n    local len = value\n    while len > 0 do\n        local byte = len % 256\n        table.insert(bytes, 1, byte)\n        len = math.floor(len \/ 256)\n    end\n    table.insert(bytes, 1, #bytes + 128)\n    return bytes\nen","completion":""}
{"prompt":"-- Swaps GT with PGT - this is a pretty dangerous assumption of [-2]\nlocal function replace_gt(sample)\n    local gt = sample[GT]\n    local pgt = sample[PGT]\n    if (gt == MISSING) or (gt == REF) then return sample end\n    if (gt == ALT) or (gt == HET) then\n        if pgt == MISSING then return sample end\n        sample[GT] = pgt\n    end\n    return sample\nen","completion":""}
{"prompt":"-- If the user wants a fancy annotation, like 'add middle column',\n-- this gets processed here. it's potentially the place where the\n-- user could add entropy score, or something like that.\nlocal function process_special_annotation(v, lin)\n    local s = string.gsub(v, '[%s%p]', '')\n    if s == 'addmiddlecol' then\n        -- add the middle column, but only if there isn't already a\n        -- middle col\n        if not pcall(function ()\n                get_node(lin, { 'TD', 'TH' }, { 'colspan' })\n            end) then\n            v = v .. ' ' .. middle_col_tag\n        end\n    end\n    return v\nen","completion":""}
{"prompt":"-- Convert h:m:s to seconds.\nlocal function hms_to_seconds(h, m, s)\n\treturn h * 3600 + m * 60 + s\nen","completion":""}
{"prompt":"-- Calculation of the normalized pressure as a function of frequency.\n-- :param  p_num   numerical results.\n-- :param  norm_ref reference pressure for the normalization.\n-- :param      p_norm  normalized pressure.\n-- :return     The normalized pressure as a function of frequency.\nlocal function pressure_NORMALIZED(p_num, norm_ref)\n    return p_num \/ norm_ref\nen","completion":""}
{"prompt":"-- Computes the hash of the `terms`, based on its index `i`.\n-- :param terms: the terms\n-- :type terms: List[Term]\n-- :param i: the index of the term\n-- :type i: int\n-- :return: the hash\n-- :rtype: int\nlocal function get_item_hash(terms, i)\n\tlocal ret = 0\n\tlocal t = terms[i]\n\tif t then\n\t\tret = t:hash()\n\tend\n\treturn ret\nen","completion":""}
{"prompt":"-- Loop solution.\nlocal function loop_solution(max_number)\n  local sum = 0\n  local sum2 = 0\n  for i=1,max_number do\n    sum = sum + i\n    sum2 = sum2 + i*i\n  end\n  local diff = sum * sum - sum2\n  return diff\nen","completion":""}
{"prompt":"-- Backpropagator for `scalar_exp`.\nlocal function bprop_scalar_exp(x, out, dout)\n    return { dout * out }\nen","completion":""}
{"prompt":"-- Convert a list of field choices to a dictionary suitable for direct comparison with a ChoiceSet. For example:\n-- [\n-- {\n-- \"value\": \"choice-1\",\n-- \"label\": \"First Choice\"\n-- },\n-- {\n-- \"value\": \"choice-2\",\n-- \"label\": \"Second Choice\"\n-- }\n-- ]\n-- Becomes:\n-- {\n-- \"choice-1\": \"First Choice\",\n-- \"choice-2\": \"Second Choice\n-- }\nlocal function choices_to_dict(choices_list)\n  local choices_dict = {}\n  for _, choice in ipairs(choices_list) do\n    choices_dict[choice.value] = choice.label\n  end\n  return choices_dict\nen","completion":""}
{"prompt":"-- Compute the coordinates of the center of a hex8 element.\n-- Simple average in physical space.\n-- The result is the same as for hex8_subdiv with intervals=1.\n-- Input:\n-- elem_coords:  coordinates of element's nodes, assuming exodus\n-- node order convention - (counter clockwise around\n-- the element)\nlocal function hex8_ctr(elem_coords)\n    local center = {0,0,0}\n    for i=1,8 do\n        center[1] = center[1] + elem_coords[i][1]\n        center[2] = center[2] + elem_coords[i][2]\n        center[3] = center[3] + elem_coords[i][3]\n    end\n    center[1] = center[1] \/ 8\n    center[2] = center[2] \/ 8\n    center[3] = center[3] \/ 8\n    return center\nen","completion":""}
{"prompt":"-- Given an array of unsorted numbers, find all unique triplets that\n-- sum up to zero.\n-- [LC-0015]\n-- >>> threesum_zero([-3, 0, 1, 2, -1, 1, -2])\n-- [[-3, 1, 2], [-2, 0, 2], [-2, 1, 1], [-1, 0, 1]]\n-- >>> threesum_zero([-5, 2, -1, -2, 3])\n-- [[-5, 2, 3], [-2, -1, 3]]\n-- >>> threesum_zero([-1, 0, 1, 2, -1, -4])\n-- [[-1, -1, 2], [-1, 0, 1]]\n-- >>> threesum_zero([])\n-- []\n-- >>> threesum_zero([0])\n-- []\nlocal function threesum_zero(A)\n    local result = {}\n    local n = #A\n    if n <= 2 then return result end\n    table.sort(A)\n    for i = 1, n - 2 do\n        if i > 1 and A[i] == A[i-1] then\n            -- skip duplicates\n            goto continue\n        end\n        local target = -A[i]\n        local left = i + 1\n        local right = n\n        while left < right do\n            local sum = A[left] + A[right]\n            if sum == target then\n                table.insert(result, {A[i], A[left], A[right]})\n                while left < right and A[left] == A[left+1] do\n                    left = left + 1\n                end\n                while left < right and A[right] == A[right-1] do\n                    right = right - 1\n                end\n                left = left + 1\n                right = right - 1\n            elseif sum < target then\n                left = left + 1\n            elseif sum > target then\n                right = right - 1\n            end\n        end\n    ::continue::\n    end\n    return result\nen","completion":""}
{"prompt":"-- Return `input_string` as an integer between 1 and 6.\n-- Check if `input_string` is an integer number between 1 and 6.\n-- If so, return an integer with the same value. Otherwise, tell\n-- the user to enter a valid number and quit the program.\nlocal function parse_input(input_string)\n  local parsed_input = tonumber(input_string)\n  if parsed_input and (parsed_input >= 1 and parsed_input <= 6) then\n    return parsed_input\n  else\n    print(\"Please enter a number between 1 and 6.\")\n    os.exit()\n  end\nen","completion":""}
{"prompt":"-- Calculate the fibonacci number at position n iteratively\nlocal function getFibonacciIterative(n)\n\tlocal a = 0\n\tlocal b = 1\n\tlocal i = 0\n\t\n\twhile (i < n) do\n\t\tlocal sum = a + b\n\t\ta = b\n\t\tb = sum\n\t\ti = i + 1\n\tend\n\t\n\treturn a\nen","completion":""}
{"prompt":"-- Computes ending retained earnings.\n-- Parameters\n-- ----------\n-- bre : int or float\n-- Beginning retained earnings (at the beginning of the period)\n-- net_income : int or float\n-- Net income\n-- dividend : int or float\n-- Dividend payment to shareholders\n-- Returns\n-- -------\n-- out : int or float\n-- Ending retained earnings (at the end of the period)\nlocal function ret_earnings(bre, net_income, dividend)\n  return bre + net_income - dividend\nen","completion":""}
{"prompt":"-- Gets a square number by file and rank index.\nlocal function square(file_index, rank_index)\n    return file_index + rank_index * 8\nen","completion":""}
{"prompt":"-- Set the version of the API. This function should really only\n-- be used in bot.py.\nlocal function set_version(ver)\n  version = ver\n  return version\nen","completion":""}
{"prompt":"-- Splits the given buffer on newlines and strips each line\nlocal function split_lines(buf)\n\tlocal lines = {}\n\tfor line in string.gmatch(buf, '[^\\r\\n]+') do\n\t\ttable.insert(lines, line)\n\tend\n\treturn lines\nen","completion":""}
{"prompt":"-- Prompt user to enter multiple lines of text.\nlocal function get_text(prompt, msg, input)\n  local ok, text = pcall(io.read, prompt or \"> \")\n  if not ok then\n    if text ~= \"interrupted!\" then\n      print(msg or \"\")\n    end\n    text = input or \"\"\n  end\n  return text\nen","completion":""}
{"prompt":"-- use the math library to get the square root\nlocal function builtin_sqrt(x)\n    if x < 0 then return nil, \"cannot take the square root of a negative number\" end\n    local y = math.sqrt(x)\n    if y == y then return y, nil end\n    return nil, \"cannot take the square root of a number that is too large\"\nen","completion":""}
{"prompt":"-- get a flattened tree of the \"paths\" of all children of a tree of objects.\n-- used in sidenav\nlocal function flatten_tree(root)\n  if type(root) ~= 'table' then\n    return { root }\n  else\n    local ret = {}\n    for _, child in pairs(root) do\n      for _, grandchild in pairs(flatten_tree(child)) do\n        table.insert(ret, grandchild)\n      end\n    end\n    return ret\n  end\nen","completion":""}
{"prompt":"-- An arrow is formed in a rectangle with sides a and b by joining the bottom corners to the midpoint of the top edge\n-- and the centre of the rectangle.\n-- :param a: an integer value.\n-- :param b: an integer value.\n-- :return: the arrow area of a triangle.\nlocal function arrow_area(a, b)\n  return 0.25 * a * b\nen","completion":""}
{"prompt":"-- :returns the matrix transposed\nlocal function transpose(matrix)\n\tlocal transposed = {}\n\tfor _, row in pairs(matrix) do\n\t\tfor k, v in pairs(row) do\n\t\t\tif not transposed[k] then\n\t\t\t\ttransposed[k] = {}\n\t\t\tend\n\t\t\ttable.insert(transposed[k], v)\n\t\tend\n\tend\n\treturn transposed\nen","completion":""}
{"prompt":"-- Easing function for animations: Quartic Ease Out\nlocal function quartic_easeout(pos)\n  return ((-pos^4) + (4*pos^3) - (6*pos^2) + (4*pos))\nen","completion":""}
{"prompt":"-- Filter each tuple according to visibility.\n-- Args:\n-- key_tuples: A sequence of tuples of equal length (i.e. rectangular)\n-- visibilities: A sequence of booleans equal in length to the tuples contained in key_tuples.\n-- Returns:\n-- A sequence equal in length to key_tuples where the items are tuples with a length corresponding\n-- to the number of items in visibility which are True.\nlocal function strip_hidden(key_tuples, visibilities)\n  local hidden_count = 0\n  for _,v in pairs(visibilities) do\n    if not v then\n      hidden_count = hidden_count + 1\n    end\n  end\n  local visible_tuples = {}\n  for i, tuple in ipairs(key_tuples) do\n    if visibilities[i] then\n      local visible_tuple = {}\n      for j,item in ipairs(tuple) do\n        table.insert(visible_tuple, item)\n      end\n      table.insert(visible_tuples, visible_tuple)\n    end\n  end\n  return visible_tuples\nen","completion":""}
{"prompt":"-- :type n: int\n-- :rtype: int\nlocal function factorial(n)\n    if n == 0 then\n        return 1\n    else\n        return n * factorial(n - 1)\n    end\nen","completion":""}
{"prompt":"-- Take a str or None and return a non-empty string.\nlocal function _ensure_non_empty(s)\n\tassert(type(s) == \"string\" or s == nil, \"Expected string or nil, got \" .. type(s))\n\treturn s or \"\"\nen","completion":""}
{"prompt":"-- Multiply two quaternion.\nlocal function q_mult(a, b)\n\treturn {\n\t\ta[1]*b[1]-a[2]*b[2]-a[3]*b[3]-a[4]*b[4],\n\t\ta[1]*b[2]+a[2]*b[1]+a[3]*b[4]-a[4]*b[3],\n\t\ta[1]*b[3]-a[2]*b[4]+a[3]*b[1]+a[4]*b[2],\n\t\ta[1]*b[4]+a[2]*b[3]-a[3]*b[2]+a[4]*b[1]\n\t}\nen","completion":""}
{"prompt":"-- Calculate chunksize argument for Pool-methods.\n-- Resembles source-code within `multiprocessing.pool.Pool._map_async`.\nlocal function calc_chunksize(n_workers, len_iterable, factor)\n    if factor == nil then\n        factor = 10\n    end\n    local chunksize = math.ceil(len_iterable \/ n_workers \/ factor)\n    return chunksize\nen","completion":""}
{"prompt":"-- Naive square matrix multiplication\nlocal function naive_matrix_product(A, B)\n    local C = {}\n    for i=1, #A do\n        local Crow = {}\n        for j=1, #B[1] do\n            local sum = 0\n            for k=1, #B do\n                sum = sum + A[i][k] * B[k][j]\n            end\n            table.insert(Crow, sum)\n        end\n        table.insert(C, Crow)\n    end\n    return C\nen","completion":""}
{"prompt":"-- Set figure dimensions to avoid scaling in LaTeX.\n-- Parameters\n-- ----------\n-- width: float or string\n-- Document width in points, or string of predined document type\n-- fraction: float, optional\n-- Fraction of the width which you wish the figure to occupy\n-- subplots: array-like, optional\n-- The number of rows and columns of subplots.\n-- Returns\n-- -------\n-- fig_dim: tuple\n-- Dimensions of figure in inches\nlocal function set_size(width, fraction, subplots)\n  local r\n  if width == 'thesis' then\n    r = 1.0\n  elseif width == 'beamer' then\n    r = 2.0 \/ 3\n  else\n    r = width\n  end\n  local fig_width_pt = 430.0                          -- Get this from LaTeX using \\the\\textwidth\n  local inches_per_pt = 1.0 \/ 72.27 * 2              -- Convert pt to inch\n  local golden_mean = (math.sqrt(5) - 1.0) \/ 2.0\n  local fig_width = fig_width_pt * inches_per_pt     -- width in inches\n  local fig_height = fig_width * golden_mean          -- height in inches\n  if fraction then\n    fig_width = fig_width * fraction\n  end\n  if subplots then\n    -- Make room for the subplots\n    localsubplots = unpack(subplots)\n    fig_width = fig_width * (subplots[1] + subplots[2])\n    fig_height = fig_height * (subplots[2] + subplots[3])\n  end\n  return fig_width, fig_height\nen","completion":""}
{"prompt":"-- Returns usage text for resinter.\nlocal function usage()\n  print(\"usage: resinter [options] file\")\n  print(\"Options:\")\n  print(\"  -o file: write output to file\")\n  print(\"  -h: display help message\")\n  print(\"  -v: verbose output\")\n  print(\"  -v2: extremely verbose output\")\n  os.exit(0)\nen","completion":""}
{"prompt":"-- Return the singular or plural form of a word, according to the number.\n-- If ``with_number`` is true (default), the return value will be the number\n-- followed by the word. Otherwise the word alone will be returned.\n-- Usage:\n-- >>> plural(2, \"ox\", \"oxen\")\n-- '2 oxen'\n-- >>> plural(2, \"ox\", \"oxen\", False)\n-- 'oxen'\nlocal function plural(n, singular, plural, with_number)\n  with_number = with_number ~= false\n  if n == 1 or n == -1 then\n    if with_number then\n      return n .. \" \" .. singular\n    else\n      return singular\n    end\n  else\n    if with_number then\n      return n .. \" \" .. plural\n    else\n      return plural\n    end\n  end\nen","completion":""}
{"prompt":"-- Return a list of n ones.\nlocal function ones_list(n)\n   local t = {}\n   for i = 1, n do\n      t[i] = 1\n   end\n   return t\nen","completion":""}
{"prompt":"-- Compute Constituents Parsed metric for ListOps style examples.\nlocal function count_parse(parse, index, const_parsed)\n   if not parse.constituents then\n      return 0\n   end\n   local const_num = 0\n   for _, constituent in pairs(parse.constituents) do\n      if constituent.type == \"ListOps\" then\n\t const_num = const_num + count_parse(constituent, index, true)\n      elseif constituent.type == \"ListOps-VP\" then\n\t const_num = const_num + count_parse(constituent, index, true)\n      elseif constituent.type == \"ListOps-NP\" then\n\t const_num = const_num + count_parse(constituent, index, true)\n      elseif constituent.type == \"ListOps-QP\" then\n\t const_num = const_num + count_parse(constituent, index, true)\n      elseif constituent.type == \"ListOps-PP\" then\n\t const_num = const_num + count_parse(constituent, index, true)\n      elseif constituent.type == \"ListOps-PP-QP\" then\n\t const_num = const_num + count_parse(constituent, index, true)\n      elseif constituent.type == \"ListOps-PP-QP-NP\" then\n\t const_num = const_num + count_parse(constituent, index, true)\n      elseif constituent.type == \"ListOps-PP-QP-NP-VP\" then\n\t const_num = const_num + count_parse(constituent, index, true)\n      elseif constituent.type == \"ListOps-NP-VP\" then\n\t const_num = const_num + count_parse(constituent, index, true)\n      elseif constituent.type == \"ListOps-NP-VP-PP-QP\" then\n\t const_num = const_num + count_parse(constituent, index, true)\n      end\n   end\n   if not const_parsed then\n      return const_num\n   end\n   return const_num + 1\nen","completion":""}
{"prompt":"-- Update or create a dict of `int` counters, for JSONField.\nlocal function update_inc(initial, key, count)\n    local new = initial or {}\n    new[key] = new[key] or 0\n    new[key] = new[key] + count\n    return new\nen","completion":""}
{"prompt":"-- Convert string into a probable plural form.\nlocal function plural(st)\n  if st ~= nil then\n    return string.match(st, \"%.$\") == nil and st .. \"s\" or st\n  end\nen","completion":""}
{"prompt":"-- Parameters\n-- ----------\n-- element_list :\n-- Returns\n-- -------\nlocal function ensure_list(element_list)\n  if type(element_list) == 'table' then\n    return element_list\n  else\n    return { element_list }\n  end\nen","completion":""}
{"prompt":"-- :return The name of an undirected edge as \"(u,v)\" with u <= v.\nlocal function undirected_edge_name(u, v)\n  if u > v then return undirected_edge_name(v, u) end\n  return \"(\"..tostring(u)..\",\"..tostring(v)..\")\"\nen","completion":""}
{"prompt":"-- extract warnings from the parsed test case stderr\nlocal function get_vgci_warnings(tc)\n\tlocal warnings = {}\n\tif tc.stderr then\n\t\tfor line in tc.stderr:gmatch(\"[^\\n]+\") do\n\t\t\tif line:match(\"warning: warning: \") then\n\t\t\t\twarnings[#warnings+1] = line\n\t\t\tend\n\t\tend\n\tend\n\treturn warnings\nen","completion":""}
{"prompt":"-- Return text if text isn't None or empty, otherwise return 'unknown(number)'\n-- :type text: str\n-- :param text: string, that we want format\n-- :type number: int\n-- :param number: number used in text\nlocal function none_as_unknown(text, number)\n\tif text ~= nil and #text > 0 then\n\t\treturn text\n\telse\n\t\treturn 'unknown(' .. number .. ')'\n\tend\nen","completion":""}
{"prompt":"-- Deret fibonacci merupakan salah satu permasalahan yang diselesaikan\n-- menggunakan pendekatan rekursi. Pada beberapa literatur,\n-- deret fibonacci  dimulai dengan 0,1,1,2,... namun ada\n-- literatur yang menjelaskan bahwa deret ini dimulai dengan 1,1,2,... .\n-- Fungsi fibo(n) memiliki parameter n yang akan mengembalikan nilai\n-- fibonacci pada urutan ke-n. Fungsi ini menggunakan deret 1,1,2,...\nlocal function fibo(n)\n    if n == 0 or n == 1 then\n        return n\n    else\n        return fibo(n - 2) + fibo(n - 1)\n    end\nen","completion":""}
{"prompt":"-- Return a counter function.\n-- >>> c = make_counter()\n-- >>> c('a')\n-- 1\n-- >>> c('a')\n-- 2\n-- >>> c('b')\n-- 1\n-- >>> c('a')\n-- 3\n-- >>> c2 = make_counter()\n-- >>> c2('b')\n-- 1\n-- >>> c2('b')\n-- 2\n-- >>> c('b') + c2('b')\n-- 5\nlocal function make_counter()\n  local cnt = 0\n  return function()\n    cnt = cnt + 1\n    return cnt\n  end\nen","completion":""}
{"prompt":"-- Strip all namespaces or namespace prefixes if present in an XML tag name .\n-- For example:\n-- >>> tag_name = '{http:\/\/maven.apache.org\/POM\/4.0.0}geronimo.osgi.export.pkg'\n-- >>> expected = 'geronimo.osgi.export.pkg'\n-- >>> assert expected == strip_namespace(tag_name)\nlocal function strip_namespace(tag_name)\n    if tag_name == nil then\n        return nil\n    end\n    -- Remove prefix.\n    local prefix_start = string.find(tag_name, \"{\")\n    if prefix_start then\n        local prefix_end = string.find(tag_name, \"}\")\n        if prefix_end then\n            return string.sub(tag_name, prefix_end + 1)\n        else\n            return tag_name\n        end\n    else\n        return tag_name\n    end\nen","completion":""}
{"prompt":"-- Return value as a string zero-padded to two digits\nlocal function zero_pad(v)\n\treturn (\"%02i\"):format(v)\nen","completion":""}
{"prompt":"-- Converts hours to minutes\nlocal function hours_to_minutes(hours)\n  return math.floor(hours * 60)\nen","completion":""}
{"prompt":"-- Get the top level domain from a domain string.\n-- Args:\n-- domain: string with a full domain, eg. www.google.com\n-- Returns:\n-- string: TLD or a top level domain extracted from the domain,\n-- eg: google.com\nlocal function get_tld_from_domain(domain)\n\tlocal tld_domain = string.match(domain, \"(%w+%.%w+)$\")\n\tif tld_domain == nil then\n\t\t-- Return the whole domain if it doesn't contain a top level domain.\n\t\treturn domain\n\telse\n\t\treturn tld_domain\n\tend\nen","completion":""}
{"prompt":"-- Returns if the given year is leap or not\nlocal function getLeap(a_year)\n\t-- Check for common multiple\n\tif ((a_year % 4) == 0) then\n\t\tif ((a_year % 100) == 0) then\n\t\t\tif ((a_year % 400) == 0) then\n\t\t\t\treturn true\n\t\t\tend\n\t\telse\n\t\t\treturn true\n\t\tend\n\tend\n\treturn false\nen","completion":""}
{"prompt":"-- Formats an ID into a Discord's representation of a channel \/ role \/ user mention.\nlocal function format_discord_str(discord_id, type_chars)\n  assert(discord_id, 'ID cannot be nil')\n  assert(type_chars, 'Type must be defined.')\n  return '<' .. type_chars .. discord_id .. '>'\nen","completion":""}
{"prompt":"-- Returns the overlap of two intervals\nlocal function getOverlap(interval_a, interval_b)\n  local overlap_a = math.max(interval_a[1], interval_b[1])\n  local overlap_b = math.min(interval_a[2], interval_b[2])\n  if overlap_a >= overlap_b then return 0 end\n  return overlap_b - overlap_a\nen","completion":""}
{"prompt":"-- Solution:\n-- Let arr[0..n-1] be the input array and L(i) be the length of the LIS \n-- ending at index i such that arr[i] is the last element of the LIS.\n-- Then, L(i) can be recursively written as:\n-- L(i) = 1 + max( L(j) ) where 0 < j < i and arr[j] < arr[i]; or\n-- L(i) = 1, if no such j exists.\n-- To find the LIS for a given array, we need to return max(L(i)) where 0 < i < n.\nlocal function longest_increasing_subsequence(a)\n\tlocal n = #a\n\t-- dp[i] stores the LIS ending at index i\n\tlocal dp = {}\n\t-- Initialize the LIS values for all indexes\n\t-- as 1 as the number of elements in increasing subsequence\n\t-- with only one element is 1\n\tfor i = 1, n do dp[i] = 1 end\n\t-- Update values of dp[i] using the recursive property\n\tfor i = 2, n do\n\t\tfor j = 1, i-1 do\n\t\t\tif a[i] > a[j] and dp[i] < dp[j] + 1 then\n\t\t\t\tdp[i] = dp[j] + 1\n\t\t\tend\n\t\tend\n\tend\n\t-- Find and print the maximum value in dp array\n\tlocal max = 0\n\tfor i = 1, n do\n\t\tif dp[i] > max then\n\t\t\tmax = dp[i]\n\t\tend\n\tend\n\treturn max\nen","completion":""}
{"prompt":"-- Linear rampup\nlocal function linear_rampup(current, rampup_length)\n  if current < rampup_length then\n    return current \/ rampup_length\n  else\n    return 1.0\n  end\nen","completion":""}
{"prompt":"-- Takes a config dictionary and an attribute string as input and tries to\n-- find the attribute in the dictionary. The attribute may use dots to\n-- indicate levels of depth within the dictionary.\n-- Example:\n-- find_nested_attr({'one': {'two': {'three': 3}}}, 'one.two.three')\n-- --> 3\nlocal function find_nested_attr(config, attr)\n   local keys = {}\n   for k in string.gmatch(attr, '[^%.]+') do\n      keys[#keys+1] = k\n   end\n   local last = config\n   for _, k in ipairs(keys) do\n      if type(last) == 'table' then\n         last = last[k]\n      else\n         return\n      end\n   end\n   return last\nen","completion":""}
{"prompt":"-- >>> transpose_2D([[1,2,3,4],[5,6,7,8],[9,10,11,12]])\n-- [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\nlocal function transpose_2D(matrix)\n  local result = {}\n  for i = 1, #matrix[1] do\n    result[i] = {}\n  end\n  for row_index, row in ipairs(matrix) do\n    for col_index, col in ipairs(row) do\n      result[col_index][row_index] = col\n    end\n  end\n  return result\nen","completion":""}
{"prompt":"-- Calculate the distance travelled(in Km) in a give amount of time(s).\nlocal function calculate_dis_travelled(speed, time)\n\treturn speed * time\nen","completion":""}
{"prompt":"-- this function calculates the gor for  a given x\nlocal function gor_func(x, a1, a2, exp)\n\treturn a1*x^exp + a2\nen","completion":""}
{"prompt":"-- Convert given row list into dict with column keys\nlocal function rowdict(columns, row)\n  local r = {}\n  for i, key in ipairs(columns) do\n    r[key] = row[i]\n  end\n  return r\nen","completion":""}
{"prompt":"-- Normalise the whitespace in the string\n-- :param text: string\n-- :return: string with whitespace normalised to single space\nlocal function normalise_whitespace(text)\n  if not text or type(text) ~= 'string' then return '' end\n  local normalised = text:gsub('%s+', ' '):gsub('^%s+', '')\n  local trimmed = normalised:gsub('%s+$', '')\n  return trimmed\nen","completion":""}
{"prompt":"-- Union two (x1, y1, x2, y2) rects.\nlocal function union_crops(crop1, crop2)\n\treturn {\n\t\tmath.min(crop1[1], crop2[1]),\n\t\tmath.min(crop1[2], crop2[2]),\n\t\tmath.max(crop1[3], crop2[3]),\n\t\tmath.max(crop1[4], crop2[4]),\n\t}\nen","completion":""}
{"prompt":"-- Function to compute Recall\nlocal function compute_recall(true_positive, false_negative)\n    if (true_positive + false_negative == 0) then\n        return 0;\n    else\n        return true_positive \/ (true_positive + false_negative);\n    end\nen","completion":""}
{"prompt":"-- Sums the nodes of a tree.\n-- Arguments:\n-- root (binary tree):\n-- The root of a binary tree. A binary tree is either a 3-tuple\n-- ``(data, left, right)`` where ``data`` is the value of the root node\n-- and ``left`` and ``right`` are the left and right subtrees or\n-- ``None`` for the empty tree.\n-- Returns:\n-- n (int):\n-- The sum of the nodes of the tree.\nlocal function sum_tree(root)\n    -- Base Case\n    if root == nil then\n        return 0\n    end\n    return root[1] + sum_tree(root[2]) + sum_tree(root[3])\nen","completion":""}
{"prompt":"-- Prepends amount of zeroes required for indexes to be string-sortable in terms of given collection size.\n-- Examples:\n-- for 10 items prepends up to 1 zero: 1 -> \"01\", 10 -> \"10\"\n-- for 100 items prepends up to 2 zeroes: 7 -> \"007\", \"13\" -> \"013\"\nlocal function zfill_to_collection_size(index, collection_size)\n  local length = string.len(tostring(collection_size))\n  local result = string.format('%0' .. length .. 'd', index)\n  return result\nen","completion":""}
{"prompt":"-- Removes digits (number) charaters.\nlocal function strip_digits(text)\n    return string.gsub(text, '%d', '')\nen","completion":""}
{"prompt":"-- Returns the number of times 8 appears as a digit of x.\n-- >>> num_eights(3)\n-- 0\n-- >>> num_eights(8)\n-- 1\n-- >>> num_eights(88888888)\n-- 8\n-- >>> num_eights(2638)\n-- 1\n-- >>> num_eights(86380)\n-- 2\n-- >>> num_eights(12345)\n-- 0\n-- >>> from construct_check import check\n-- >>> # ban all assignment statements\n-- >>> check(HW_SOURCE_FILE, 'num_eights',\n-- ...       ['Assign', 'AugAssign'])\n-- True\nlocal function num_eights(x)\n  local num = 0\n  local ten = 10\n  while x > 0 do\n    if x % ten == 8 then\n      num = num + 1\n    end\n    x = x \/\/ ten\n  end\n  return num\nen","completion":""}
{"prompt":"-- Drop none from the list\n-- :param arr:\n-- :return:\nlocal function drop_none(arr)\n  local out = {}\n  for _, v in pairs(arr) do\n    if v ~= nil then\n      table.insert(out, v)\n    end\n  end\n  return out\nen","completion":""}
{"prompt":"-- Strips whitespaces from thestart of the text.\nlocal function str_lstrip(text)\n    return (text:gsub(\"^%s+\", \"\"))\nen","completion":""}
{"prompt":"-- Take a position dictionary and build the skills list. Ensure the list\n-- separator is not a comma if there is a comma in one of the skill items\nlocal function make_skills_string(position)\n    local skills = position.skills\n    local skills_string = \"\"\n    if skills ~= nil then\n        for _, skill in ipairs(skills) do\n            skills_string = skills_string .. skill\n            skills_string = skills_string .. \", \"\n        end\n    end\n    if skills_string ~= \"\" then\n        skills_string = skills_string:sub(1, #skills_string - 2)\n    end\n    return skills_string\nen","completion":""}
{"prompt":"-- Flattens a list.\n-- Example:\n-- >>> flatten([a,b,[c,d,[e,f]]])\n-- [a,b,c,d,e,f]\nlocal function flatten(L)\n  local r = {}\n  local function f(x)\n    if type(x) == 'table' then\n      for _,v in ipairs(x) do\n        f(v)\n      end\n    else\n      table.insert(r, x)\n    end\n  end\n  f(L)\n  return r\nen","completion":""}
{"prompt":"-- Convert a label to latex format by appending surrounding $ and escaping spaces\n-- Parameters\n-- ----------\n-- label : str\n-- The label string to be converted to latex expression\n-- Returns\n-- -------\n-- str\n-- A string with $ surrounding\nlocal function label_texify(label)\n\t-- Convert to string if not already one\n\tlabel = tostring(label)\n\t-- Surround by $ and escape spaces\n\treturn \"$\" .. string.gsub(label, \" \", \"\\\\ \") .. \"$\"\nen","completion":""}
{"prompt":"-- Concatenate value and arg with hyphens as separator, if neither is empty\nlocal function hyphenate(value, arg)\n    if value == '' or arg == '' then\n        return value .. arg\n    else\n        return value .. '-' .. arg\n    end\nen","completion":""}
{"prompt":"-- Returns a string representation of a float with the\n-- the given number of fractional digits. This should not be\n-- used to perform a rounding operation (this is done via\n-- :meth:`~.float_round`), but only to produce a suitable\n-- string representation for a float.\n-- :param int precision_digits: number of fractional digits to\n-- include in the output\nlocal function float_repr(value, precision_digits)\n    -- A negative precision doesn't make sense, so we make it\n    -- positive.\n    precision_digits = precision_digits >= 0 and precision_digits or 0\n    return string.format(\"%.\" .. precision_digits .. \"f\", value)\nen","completion":""}
{"prompt":"-- Check for matches with supplied values\n-- 0 - no matches\n-- -1 - error\n-- n - number of matching rows (should be only 1)\nlocal function host_match(cursor, name, topic)\n   if not cursor then return -1 end\n   local sql = \"select id from hosts where name=? AND topic=?\"\n   local stmt, errmsg = cursor:prepare(sql)\n   if not stmt then\n      log.error(\"Error: %s\", errmsg)\n      return -1\n   end\n   local result, errmsg = stmt:bind_values(name, topic)\n   if errmsg then\n      log.error(\"Error: %s\", errmsg)\n      stmt:close()\n      return -1\n   end\n   local rc, errmsg = stmt:step()\n   if errmsg then\n      log.error(\"Error: %s\", errmsg)\n      stmt:close()\n      return -1\n   end\n   if rc == sqlite3.ROW then\n      local id = stmt:get_value(0)\n      stmt:close()\n      return id\n   end\n   stmt:close()\n   return 0\nen","completion":""}
{"prompt":"-- Gets the prmtop number\n-- :param trajFilename: prmtop filename\n-- :type trajFilename: str\n-- :returns: int -- prmtop number\nlocal function getPrmtopNum(prmtopFilename)\n  return tonumber(string.match(prmtopFilename, \"(%d+).prmtop\"))\nen","completion":""}
{"prompt":"-- Convert a 24-bit color value to 8-bit red, green, blue components.\n-- Will return a 3-tuple with the color component values.\nlocal function color_to_RGB(color)\n\tlocal red = bit32.band(bit32.rshift(color, 16), 0xFF)\n\tlocal green = bit32.band(bit32.rshift(color, 8), 0xFF)\n\tlocal blue = bit32.band(color, 0xFF)\n\treturn {red, green, blue}\nen","completion":""}
{"prompt":"-- Computes the number of features created by a 2d convolution.\n-- See: http:\/\/cs231n.github.io\/convolutional-networks\/\nlocal function get_num_features(fp_size, kernel_size, padding, stride)\n   return math.floor((fp_size + 2 * padding - kernel_size) \/ stride + 1)\nen","completion":""}
{"prompt":"-- Parse command line arguments into Python arguments for parsers.\n-- Converts an arguments string of the form: key1=value1,key2=value2 into\n-- a dict of arguments that can be passed to Python initializers.\n-- This function also understands type prefixes and will cast values prefixed\n-- with 'int:' or 'float:'. For example magic_number=int:4 will be converted\n-- to {\"magic_number\": 4}.\nlocal function parse_kwargs(s)\n    local args = {}\n    if s == nil or s == \"\" then return args end\n    for pair in s:gmatch(\"([^,]+)\") do\n        local key, val = pair:match(\"([^=]+)=([^=]+)\")\n        if val ~= nil then\n            if val:match(\"^int:\") then\n                val = tonumber(val:sub(5))\n            elseif val:match(\"^float:\") then\n                val = tonumber(val:sub(7))\n            end\n            args[key] = val\n        end\n    end\n    return args\nen","completion":""}
{"prompt":"-- Minmod function for two scalars\n-- Idea from http:\/\/codegolf.stackexchange.com\/questions\/42079\/shortest-minmod-function\nlocal function scalar_minmod(a, b)\n    local out = 0\n    if (a*b) > 0 then\n        if a > 0 then\n            out = math.min(a, b)\n        else\n            out = math.max(a, b)\n        end\n    end\n    return out\nen","completion":""}
{"prompt":"-- Encode given number in base 10 to digits in given base.\n-- number: int -- integer representation of number (in base 10)\n-- base: int -- base to convert to\n-- return: str -- string representation of number (in given base)\nlocal function encode(number, base)\n    -- TODO: Your code here\n    local digits = \"0123456789abcdefghijklmnopqrstuvwxyz\"\n    local output = \"\"\n    while number > 0 do\n        local digit = number % base\n        number = math.floor(number \/ base)\n        output = string.sub(digits, digit+1, digit+1) .. output\n    end\n    return output\nen","completion":""}
{"prompt":"-- >>> for_in_literal_list()\n-- [1, 2, 3, 4]\nlocal function for_in_literal_list()\n\tlocal array = {1, 2, 3, 4}\n\tlocal list = {}\n\tfor _, v in ipairs(array) do\n\t\ttable.insert(list, v)\n\tend\n\treturn list\nen","completion":""}
{"prompt":"-- return number given coordinate\n-- start indices at 0\nlocal function coord2num(i, j, N)\n\treturn j * N + i + 1\nen","completion":""}
{"prompt":"-- Clamp a value 'n' within the range 'minn' and 'maxn'.\n-- :param n:               value to be clamped\n-- :param minn:            lower bound of clamp\n-- :param maxn:            upper bound of clamp\n-- :returns:\n-- * **clamped_val** - value within the range of 'minn' and 'maxn'.\nlocal function clamp(n, minn, maxn)\n  return math.min(math.max(n, minn), maxn)\nen","completion":""}
{"prompt":"-- this is just a DocString\nlocal function behzad2(x, y)\n   return (x^2) + (y^2)\nen","completion":""}
{"prompt":"-- Calculate the sum of an arithmetic series.\n-- Parameters:\n-- a_1     The first element of the series\n-- d       The difference between elements\n-- n       The number of elements in the series to sum\n-- Return:\n-- The sum of n numbers in the arithmetic series.\nlocal function arithmetic_sum_n(a_1, d, n)\n  local sum = 0\n  for i = 1, n do\n    sum = sum + a_1\n    a_1 = a_1 + d\n  end\n  return sum\nen","completion":""}
{"prompt":"-- Return the sum of the first n natural numbers\n-- >>> sum_naturals(10)\n-- 55\n-- >>> sum_naturals(100)\n-- 5050\nlocal function sum_naturals(n)\n  return n * (n + 1) \/ 2\nen","completion":""}
{"prompt":"-- x: a non-negative integer argument\n-- a: a positive integer argument\n-- returns: integer, the remainder when x is divided by a.\nlocal function rem(x, a)\n    return x - math.floor(x\/a)*a\nen","completion":""}
{"prompt":"-- Expand variables in path such as ``$PROJECT_ROOT``.\nlocal function filter_env_vars_in_filepath(filename)\n  filename = string.gsub(filename, \"%%(%w+)\", os.getenv)\n  return filename\nen","completion":""}
{"prompt":"-- 2. Function with one input and one output\n-- This function demonstrates how a function returns a processed output \n-- based on the received input\n-- This function calculates the area of a square\n-- side: the side of the square, must be a positive number\n-- area: the area of the square, must be a positive number\nlocal function square_area(side)\n    return side * side\nen","completion":""}
{"prompt":"-- Coerce a value to a tuple of given length (and possibly given type).\n-- Parameters\n-- ----------\n-- x : value or iterable\n-- N : integer\n-- length of the desired tuple\n-- t : type, optional\n-- required type for all elements\n-- Returns\n-- -------\n-- tuple\n-- ``tuple(x)`` if `x` is iterable, ``(x,) * N`` otherwise.\n-- Raises\n-- ------\n-- TypeError\n-- if `type` is given and `x` or any of its elements do not match it\n-- ValueError\n-- if `x` is iterable, but does not have exactly `N` elements\nlocal function as_tuple(x, N, t)\n  local x_type = type(x)\n  if x_type == \"table\" then\n    if N == nil then\n      return x\n    end\n    if #x ~= N then\n      error(\n        \"length mismatch: expected \" .. N .. \" elements, got \" .. #x,\n        2\n      )\n    end\n    if t ~= nil then\n      local t_type = type(t)\n      for i = 1, N do\n        if type(x[i]) ~= t_type then\n          error(\n            \"invalid type: expected \" .. t_type .. \", got \" .. type(x[i]),\n            2\n          )\n        end\n      end\n    end\n    return x\n  else\n    local out = {}\n    for i = 1, N do\n      if t == \"string\" then\n        out[i] = tostring(x)\n      else\n        out[i] = x\n      end\n    end\n    return out\n  end\nen","completion":""}
{"prompt":"-- The naming convention of our mujoco simulation is \"{elem}_name\", where elem = [geom, site, body]\n-- The string before the first underbar '_' describes the elem(ent) of the model.\n-- This function parses the string and returns the first string (i.e., the element of the model)\nlocal function get_elem_type(mjModel, elem_name)\n    local m = string.match(elem_name, \"^([^_]+)\")\n    return m\nen","completion":""}
{"prompt":"-- Property: ClusteringKeyColumn.OrderBy\nlocal function validate_clusteringkeycolumn_orderby(clusteringkeycolumn_orderby)\n    if clusteringkeycolumn_orderby == nil then\n        return nil\n    elseif clusteringkeycolumn_orderby == \"\" then\n        return nil\n    elseif string.len(clusteringkeycolumn_orderby) > 2000000 then\n        return nil\n    elseif string.find(clusteringkeycolumn_orderby, \"[*\\\"'`%?]\") then\n        return nil\n    else\n        return clusteringkeycolumn_orderby\n    end\nen","completion":""}
{"prompt":"-- Return parameter as type integer, if possible\n-- otherwise as type string\nlocal function _int_or_str(c)\n    if type(c) == \"string\" then\n        if c:match(\"^%d+$\") then\n            return tonumber(c)\n        end\n        return c\n    else\n        return c\n    end\nen","completion":""}
{"prompt":"-- The derivative for vertex form of quadratic function\n-- :param x: independent variable\n-- :param a: coefficient {a} of quadratic function\n-- :param b: the x coordinates of the vertex\n-- :param c: the y coordinates of the vertex\n-- :return:2 * a * (x - b)\nlocal function quadratic_vertex_derivative(x, a, b, c)\n  return 2 * a * (x - b)\nen","completion":""}
{"prompt":"-- Summary of set_fizz_buzz function: Evaluates the value of node_value and\n-- returns either\n-- 'FizzBuzz' if value is divisible by 3 and 5.\n-- 'Fizz' if the value is divisible by 3.\n-- 'Buzz' if the value is divisible by 5.\n-- Parameters:\n-- node_value (Node) : the current node\n-- Returns:\n-- Either 'FizzBuzz', 'Fizz' or 'Buzz'\nlocal function set_fizz_buzz(node_value)\n\tif node_value % 15 == 0 then\n\t\treturn 'FizzBuzz'\n\telseif node_value % 3 == 0 then\n\t\treturn 'Fizz'\n\telseif node_value % 5 == 0 then\n\t\treturn 'Buzz'\n\telse\n\t\treturn node_value\n\tend\nen","completion":""}
{"prompt":"-- Convert the temperature from Farenheit to Kelvin scale.\n-- :param float temp: The temperature in degrees Farenheit.\n-- :returns: The temperature in degrees Kelvin.\n-- :rtype: float\nlocal function convert_farenheit_to_kelvin(temp)\n    -- Check for the valid range of temperatures\n    if temp < -459.67 then\n        return -459.67\n    elseif temp > 500 then\n        return 500\n    else\n        return (temp + 459.67) * 5 \/ 9\n    end\nen","completion":""}
{"prompt":"-- Returns request headers for the ARIN API\nlocal function _get_arin_headers()\n  return {\n    ['X-Mashape-Key'] = ARIN_API_KEY,\n    ['Accept'] = 'application\/json',\n  }\nen","completion":""}
{"prompt":"-- Restrict a percentage ``value`` to an integer between 0 and 100\nlocal function clamp_percentages(value)\n  return math.floor(math.max(0, math.min(100, value)))\nen","completion":""}
{"prompt":"-- Returns n-th Fibonacci number\n-- n must be more than 0, otherwise it raise a ValueError.\n-- >>> fibonacci(0)\n-- 0\n-- >>> fibonacci(1)\n-- 1\n-- >>> fibonacci(2)\n-- 1\n-- >>> fibonacci(10)\n-- 55\n-- >>> fibonacci(-2)\n-- Traceback (most recent call last):\n-- ...\n-- ValueError: n must be more or equal than 0\nlocal function fibonacci(n)\n\tif n < 0 then\n\t\terror(\"n must be more or equal than 0\")\n\tend\n\tif n == 0 then\n\t\treturn 0\n\tend\n\tif n == 1 or n == 2 then\n\t\treturn 1\n\tend\n\treturn fibonacci(n - 1) + fibonacci(n - 2)\nen","completion":""}
{"prompt":"-- Get a value from the dictionary; if not such value, return the specified default\nlocal function DictGet(d, k, dflt)\n    return d[k] or dflt\nen","completion":""}
{"prompt":"-- Remove quotes from a literal.\nlocal function removeQuote(text)\n    if string.match(text, '^\"') and string.match(text, '\"$') then\n        return string.sub(text, 2, #text - 1)\n    else\n        return text\n    end\nen","completion":""}
{"prompt":"-- Assumes s is a slug-type string.\n-- Returns another slug-type string with a number at the the end.\n-- Useful when you want unique slugs that may have been hashed to the same string.\nlocal function versionate(s)\n  local ret = s\n  if ret:match(\"(.+)%-%d+$\") then\n    -- if there is already a number at the end, just add one\n    ret = ret:gsub(\"%-?(%d+)$\", function(n)\n      return \"-\" .. (tonumber(n) + 1)\n    end)\n  else\n    -- otherwise add one at the end\n    ret = ret .. \"-1\"\n  end\n  return ret\nen","completion":""}
{"prompt":"-- :param dna: The original DNA strand input by user.\n-- :return: The complement strand of the original DNA.\nlocal function build_complement(dna)\n\tlocal complement = ''\n\tfor i = 1, #dna do\n\t\tlocal char = dna:sub(i, i)\n\t\tlocal complement_char = ''\n\t\tif char == 'A' then\n\t\t\tcomplement_char = 'T'\n\t\telseif char == 'C' then\n\t\t\tcomplement_char = 'G'\n\t\telseif char == 'G' then\n\t\t\tcomplement_char = 'C'\n\t\telseif char == 'T' then\n\t\t\tcomplement_char = 'A'\n\t\telse\n\t\t\tcomplement_char = 'N'\n\t\tend\n\t\tcomplement = complement .. complement_char\n\tend\n\treturn complement\nen","completion":""}
{"prompt":"-- Strips the comments from a multi-line string.\n-- >>> strip_comments('hello ;comment\\nworld')\n-- 'hello \\nworld'\nlocal function strip_comments(s)\n\tif not s:find(';') then\n\t\treturn s\n\tend\n\treturn s:gsub(';[^\\n]*', '')\nen","completion":""}
{"prompt":"-- Returns the powerlevel at a given coordinate (x, y) based on the serial number {serial}\n-- Arguments:\n-- x {int} -- x coordinate\n-- y {int} -- y coordinate\n-- Keyword Arguments:\n-- serial {int} -- Serial number (default: {9306})\n-- Returns:\n-- int -- Power level\nlocal function get_power_level(x, y, serial)\n    serial = serial or 9306\n    local rack_id = x + 10\n    local power_level = rack_id * y\n    power_level = power_level + serial\n    power_level = power_level * rack_id\n    power_level = math.modf(power_level \/ 100)\n    power_level = power_level % 10\n    power_level = power_level - 5\n    return power_level\nen","completion":""}
{"prompt":"-- Split a USN into a UDN and a device or service type.\n-- USN is short for Unique Service Name, and UDN is short for Unique Device\n-- Name.  If the USN only contains a UDN, the type is empty.\n-- Return a list of exactly two items.\nlocal function split_usn(usn)\n\tusn = string.gsub(usn, \"%s+\", \"\") -- Remove whitespace\n\tlocal index = string.find(usn, \"::\")\n\tif not index then\n\t\treturn {usn, ''}\n\tend\n\tlocal udn, device = string.sub(usn, 1, index - 1), string.sub(usn, index + 2)\n\treturn {udn, device}\nen","completion":""}
{"prompt":"-- NORMAG: NORmalizes an array by the magnitude of the element which is greates in MAGnitude. \n-- p.23\nlocal function NORMAG(LX, X)\n\tif not X then\n\t\tX = LX\n\t\tLX = #X\n\tend\n\tlocal M = 0\n\tlocal X1\n\tfor i=1, LX do\n\t\tX1 = X[i]\n\t\tif X1 < 0 then\n\t\t\tX1 = -X1\n\t\tend\n\t\tif X1 > M then\n\t\t\tM = X1\n\t\tend\n\tend\n\tif M > 0 then\n\t\tfor i=1, LX do\n\t\t\tX[i] = X[i] \/ M\n\t\tend\n\tend\n\treturn X\nen","completion":""}
{"prompt":"-- Convert Python format date to human.\n-- Example:\n-- >>> date_format_to_human('%Y-%m-%d')\n-- YYYY-MM-DD\n-- :param value: Date format example: %Y-%m\nlocal function date_format_to_human(value)\n    return value:gsub('%%(%w)', function(x)\n        if x == 'Y' then return 'YYYY' end\n        if x == 'y' then return 'YY' end\n        if x == 'm' then return 'MM' end\n        if x == 'd' then return 'DD' end\n        if x == 'H' then return 'HH' end\n        if x == 'M' then return 'mm' end\n        if x == 'S' then return 'ss' end\n        return x\n    end)\nen","completion":""}
{"prompt":"-- Incorrect implementation of the ten function.\n-- Note:\n-- The `if` statement checks an undefined variable `val` instead of `value`.\n-- Args:\n-- value (int): A number.\n-- Returns:\n-- bool: Whether `value` is less than ten.\n-- Raises:\n-- NameError: The function references `val`, which is not available in the local or global\n-- namespace, so a `NameError` is raised.\nlocal function brokenTen(value)\n    local val = value\n    if val < 10 then\n        return true\n    end\n    return false\nen","completion":""}
{"prompt":"-- Removes the final extension from a path.\nlocal function _strip_extension(path)\n  return path:gsub(\"%.[^.]*$\", \"\")\nen","completion":""}
{"prompt":"-- Convert a given value from Rankine to Kelvin and round it to 2 decimal places.\n-- Wikipedia reference: https:\/\/en.wikipedia.org\/wiki\/Rankine_scale\n-- Wikipedia reference: https:\/\/en.wikipedia.org\/wiki\/Kelvin\nlocal function rankieToKelvin(rankie, ndigits)\n  return (rankie - 491.67) \/ 1.8 + 273.15\n    -- https:\/\/en.wikipedia.org\/wiki\/Metric_prefix#List_of_SI_prefixes\n    -- https:\/\/en.wikipedia.org\/wiki\/Metric_prefix#Names_for_prefixes_used_in_the_United_States\n    -- https:\/\/en.wikipedia.org\/wiki\/Kelvin#Unit_conversions\nen","completion":""}
{"prompt":"-- Adds a parenthesis around a values.\nlocal function parenthesise(_value)\n  return (\"(%s)\"):format(_value)\nen","completion":""}
{"prompt":"-- Checks that a valid axis type is requested.\n-- - *pp* - percentile axis\n-- - *qq* - quantile axis\n-- - *prob* - probability axis\n-- Raises an error on an invalid value. Returns the lower case verion\n-- of valid values.\nlocal function axis_type(axtype)\n\taxtype = string.lower(axtype or \"pp\")\n\tif not (axtype==\"pp\" or axtype==\"qq\" or axtype==\"prob\") then\n\t\terror(\"Invalid axis type `\"..(axtype or \"<nil>\")..\"'. Valid values are: `pp`, `qq`, `prob`.\", 2)\n\tend\n\treturn axtype\nen","completion":""}
{"prompt":"-- Generate ability score modifier\nlocal function abilityModifier(score)\n    return score \/ 2 - 5\nen","completion":""}
{"prompt":"-- if x <= 0:\n-- return 0\n-- else:\n-- return 1\nlocal function dRELU(x)\n  if x > 0 then\n    return 1\n  else\n    return 0\n  end\nen","completion":""}
{"prompt":"-- Get status value by key from dictionary.\nlocal function from_string(key, ghs_dict)\n    local value = 0;\n    if ghs_dict[key] then\n        value = tonumber(ghs_dict[key]);\n    end\n    return value;\nen","completion":""}
{"prompt":"-- Strips an initial \".\/\" and any trailing slashes from 'path'.\nlocal function _clean_up_path(path)\n\tif path:sub(1, 2) == '.\/' then\n\t\tpath = path:sub(3)\n\tend\n\treturn path:gsub('[\/]*$', '')\nen","completion":""}
{"prompt":"-- Retrieve the address from a feature\nlocal function retrieve_address(feature)\n  if feature.properties then\n    if feature.properties.address then\n      return feature.properties.address\n    elseif feature.properties.name then\n      return feature.properties.name\n    elseif feature.properties.label then\n      return feature.properties.label\n    end\n  end\n  return ''\nen","completion":""}
{"prompt":"-- Validate user alias for subfield.\nlocal function validateAlias(value)\n  if not value then return value end\n  return not value:find('^%d+$') and value or nil\nen","completion":""}
{"prompt":"-- Return just the digits for the rating count\nlocal function clean_rating_count(rating_count)\n\tlocal number = string.gsub(rating_count, \"[^0-9]\", \"\")\n\treturn number\nen","completion":""}
{"prompt":"-- Multiply the inverse of a rotation matrix by a vector.\nlocal function apply_inverse_rot_to_vec(rot, vec)\n    local x = rot[1][1] * vec[1] + rot[2][1] * vec[2] + rot[3][1] * vec[3]\n    local y = rot[1][2] * vec[1] + rot[2][2] * vec[2] + rot[3][2] * vec[3]\n    local z = rot[1][3] * vec[1] + rot[2][3] * vec[2] + rot[3][3] * vec[3]\n    return {x, y, z}\nen","completion":""}
{"prompt":"-- This function converts Rankine to celsius, with Rankine as parameter.\nlocal function ranktocels(rankine)\n\treturn (rankine-491.67)\/1.8\nen","completion":""}
{"prompt":"-- Generate the nth instance of the lucas\nlocal function lucas(n)\n  if n == 0 then\n    return 2\n  elseif n == 1 then\n    return 1\n  else\n    return lucas(n - 1) + lucas(n - 2)\n  end\nen","completion":""}
{"prompt":"-- Return a string holding the human-friendly version of the IPv4\n-- address *addr* in an integer representation.\nlocal function _format_ip4(addr)\n\treturn (string.format(\"%d.%d.%d.%d\", bit32.band(bit32.rshift(addr, 24), 0xff),\n\t\tbit32.band(bit32.rshift(addr, 16), 0xff),\n\t\tbit32.band(bit32.rshift(addr, 8), 0xff),\n\t\tbit32.band(addr, 0xff)))\nen","completion":""}
{"prompt":"-- Converts two bytes to a normal integer value.\n-- :param hi_byte: the high byte\n-- :param low_byte: the low byte\n-- :return: converted integer that has a value between [0-65535]\nlocal function two_bytes_to_int(hi_byte, low_byte)\n\treturn (hi_byte*256)+low_byte\nen","completion":""}
{"prompt":"-- Given a reading frame (how many nucleotides into a codon) at the\n-- start of a cDNA sequence, return the number of nucleotides which need\n-- to be trimmed to start on a complete codon.\n-- Parameters\n-- ----------\n-- reading_frame_at_start_of_sequence : int\n-- Returns an int\nlocal function reading_frame_to_offset(reading_frame_at_start_of_sequence)\n  -- Set a default value for the offset\n  local offset = 0\n  -- If the reading frame is not 0, then add the offset for the number\n  -- of bases we have to remove to get to the start of the codon.\n  if (reading_frame_at_start_of_sequence ~= 0) then\n    offset = 3 - reading_frame_at_start_of_sequence\n  end\n  -- Return the offset.\n  return offset\nen","completion":""}
{"prompt":"-- Integer divide and round up.\n-- Equivalent to: `int(ceil(float(n) \/ float(d)))`\nlocal function div_up(n, d)\n    return math.floor((n + d - 1) \/ d)\nen","completion":""}
{"prompt":"-- You're a hungry rabbit, and you already have eaten a certain number of carrots,\n-- but now you need to eat more carrots to complete the day's meals.\n-- you should return an array of [ total number of eaten carrots after your meals,\n-- the number of carrots left after your meals ]\n-- if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n-- Example:\n-- * eat(5, 6, 10) -> [11, 4]\n-- * eat(4, 8, 9) -> [12, 1]\n-- * eat(1, 10, 10) -> [11, 0]\n-- * eat(2, 11, 5) -> [7, 0]\n-- Variables:\n-- @number : integer\n-- the number of carrots that you have eaten.\n-- @need : integer\n-- the number of carrots that you need to eat.\n-- @remaining : integer\n-- the number of remaining carrots thet exist in stock\n-- Constrain:\n-- * 0 <= number <= 1000\n-- * 0 <= need <= 1000\n-- * 0 <= remaining <= 1000\n-- Have fun :)\nlocal function eat(number, need, remaining)\n    return {number + math.min(need, remaining), remaining - math.min(need, remaining)}\nen","completion":""}
{"prompt":"-- Compressibility factor using Carnahan-Starling equation\nlocal function S0_CS(phi)\n\treturn (1-phi^2)^0.5\nen","completion":""}
{"prompt":"-- identifies LGR (.xml) and GenBank (.gk\/gbk) files\n-- will print an error message and exit the application if other files are specified\nlocal function check_file_type(file_name)\n  local _, _, ext = string.find(file_name, \"(.*)%.(%w+)\")\n  if ext == \"xml\" or ext == \"gk\" or ext == \"gbk\" then\n    return true\n  else\n    io.stderr:write(\"Error: unexpected file type: \" .. file_name .. \"\\n\")\n    os.exit()\n  end\nen","completion":""}
{"prompt":"-- Return base64 `data` with padding characters to ensure its length is a multiple of 4.\nlocal function pad_base64(data)\n    local length = #data\n    local padding_count = 4 - (length % 4)\n    if padding_count == 4 then\n        return data\n    end\n    return data .. (\"=\"):rep(padding_count)\nen","completion":""}
{"prompt":"-- Calculates the signed milliseconds delta between the reference unix epoch and the provided target unix epoch\n-- :param reference_epoch: the unix epoch that the millis offset has to be calculated with respect to\n-- :type reference_epoch: int\n-- :param target_epoch: the unix epoch for which the millis offset has to be calculated\n-- :type target_epoch: int\n-- :return: int\nlocal function millis_offset_between_epochs(reference_epoch, target_epoch)\n    return (target_epoch - reference_epoch) * 1000\nen","completion":""}
{"prompt":"-- Returns a *in* type polynomial interpolator of power ``n``.\n-- :param n:\n-- The power of the interpolating polynomial.\n-- :return:\n-- An interpolating function.\nlocal function get_pow_in(n)\n  return function(x)\n    return x^n\n  end\nen","completion":""}
{"prompt":"-- Find the n-th fibonacci number by iteration using Dynamic Programming\nlocal function fib_iterative(n)\n    local a, b = 0, 1\n    for i = 1, n do\n        a, b = b, a + b\n    end\n    return a\nen","completion":""}
{"prompt":"-- Remove escape sequences from a Bash string.\nlocal function _parse_string(token)\n  local result = token\n  local pos = 0\n  while (pos + 1) <= #result do\n    local chr = result:sub(pos + 1, pos + 1)\n    if chr == '\\\\' then\n      local next_chr = result:sub(pos + 2, pos + 2)\n      if next_chr == '$' or next_chr == '\"' then\n        result = result:sub(1, pos) .. result:sub(pos + 2)\n        pos = pos - 1\n      end\n    end\n    pos = pos + 1\n  end\n  return result\nen","completion":""}
{"prompt":"-- The activation function\nlocal function sign(n)\n    if n >= 0 then\n        return 1\n    else\n        return -1\n    end\nen","completion":""}
{"prompt":"-- Number `odd` or `even`.\nlocal function is_even_or_odd(number)\n    if (number % 2 == 0) then\n        return \"even\"\n    else\n        return \"odd\"\n    end\nen","completion":""}
{"prompt":"-- calculate the quadratic num from 1 ~ n\nlocal function quadratic_sum(n)\n  return (n * (n + 1) * (2 * n + 1)) \/ 6\nen","completion":""}
{"prompt":"-- Cast callback to list.\n-- Parameters\n-- ----------\n-- callback : callable or list of callables\n-- Callable object(s).\n-- Returns\n-- -------\n-- list\n-- List of callable objects.\nlocal function callback_to_list(callback)\n    if callback == nil then\n        return {}\n    elseif type(callback) == 'table' then\n        return callback\n    else\n        return { callback }\n    end\nen","completion":""}
{"prompt":"-- Perform a substitution on a task\n-- Examples\n-- --------\n-- >>> subs((inc, 'x'), 'x', 1)  # doctest: +SKIP\n-- (inc, 1)\nlocal function subs(task, key, val)\n   if type(task) == 'table' then\n      for i, v in ipairs(task) do\n         task[i] = subs(v, key, val)\n      end\n      return task\n   else\n      if task == key then return val end\n      return task\n   end\nen","completion":""}
{"prompt":"-- Takes up to a 6 digit int and returns a list of each digit in order\nlocal function list_digits(number)\n\tlocal str = tostring(number)\n\tlocal list = {}\n\tfor i = 1, #str do\n\t\tlocal digit = string.sub(str, i, i)\n\t\tlist[#list + 1] = tonumber(digit)\n\tend\n\treturn list\nen","completion":""}
{"prompt":"-- Lookup the value of a given (numbered) column in a given Line\n-- Returns None if either the column or the line is None\nlocal function lookup_field(line, column)\n  if line and column then\n    return line:lookup(column)\n  end\n  return nil\nen","completion":""}
{"prompt":"-- Basic moving average filter\n-- zeta = 1 -> ignore prev. vals\n-- zeta = 0 -> ignore current val\nlocal function moving_average_filter(val, filtered_val_prev, zeta)\n  filtered_val_prev = filtered_val_prev or val\n  filtered_val_prev = filtered_val_prev * (1-zeta) + zeta * val\n  return filtered_val_prev\nen","completion":""}
{"prompt":"-- Prepare a string for use in a 'single quoted' JS literal.\nlocal function js_quote(string)\n  return string:gsub('\\\\', '\\\\\\\\'):gsub(\"'\", \"\\\\'\"):gsub('\\n', '\\\\n'):gsub('\\r', '\\\\r'):gsub('\\t', '\\\\t')\nen","completion":""}
{"prompt":"-- Compute the difference between the sum of squares and the square of\n-- the sum of the natural numbers up to and including the provided ceiling.\nlocal function sum_square_difference(ceiling)\n  local square_of_sum, sum_of_squares = 0, 0\n  for n = 1, ceiling do\n    square_of_sum = square_of_sum + n\n    sum_of_squares = sum_of_squares + n * n\n  end\n  return square_of_sum * square_of_sum - sum_of_squares\nen","completion":""}
{"prompt":"-- Find the determinant of a 2*2 matrix\n-- Only 2*2 matrices are supported. Anything else will raise a TypeError\nlocal function find_determinant(matrix)\n\tlocal matrix_height = #matrix\n\tif matrix_height ~= #matrix[1] then\n\t\terror(string.format(\"Matrix must be a square matrix. Currently it is %s\", tostring(matrix)))\n\tend\n\tlocal matrix_width = #matrix[1]\n\tif matrix_width == 2 then\n\t\treturn matrix[1][1]*matrix[2][2] - matrix[1][2]*matrix[2][1]\n\telse\n\t\tlocal determinant = 0\n\t\tfor i=1,matrix_width do\n\t\t\tdeterminant = determinant + matrix[1][i]*find_determinant(create_sub_matrix(matrix, {i}))\n\t\tend\n\t\treturn determinant\n\tend\nen","completion":""}
{"prompt":"-- poly learning stategyt\n-- lr = baselr*(1-iter\/max_iter)^power\nlocal function adjust_learning_rate(args, cur_epoch, max_epoch, curEpoch_iter, perEpoch_iter, baselr)\n    local power = 2\n    local newlr = baselr\n    if max_epoch == cur_epoch then\n        newlr = baselr * (1 - (perEpoch_iter - curEpoch_iter + 1) \/ perEpoch_iter) ^ power\n    else\n        newlr = baselr * (1 - (max_epoch - cur_epoch + 1) \/ max_epoch) ^ power\n    end\n    return newlr\nen","completion":""}
{"prompt":"-- Rescales value from the specified range to the specified other range.\n-- Arguments:\n-- in_min: min bound of the range of value.\n-- in_max: max bound of the range of value.\n-- out_min: min bound of the range of the output.\n-- out_max: max bound of the range of the output.\n-- value: a number to rescale from the input range to the output range.\n-- Return:\n-- (float) a number that is the same relative distance away from out_min and\n-- out_max as value was from in_min and in_max\nlocal function rescale(in_min, in_max, out_min, out_max, value)\n  return (value - in_min) * (out_max - out_min) \/ (in_max - in_min) + out_min\nen","completion":""}
{"prompt":"-- convert value `a` to list\n-- Args:\n-- a: value to be convert to `list`\n-- Returns (list):\nlocal function _to_list(a)\n    if type(a) == 'table' then\n        return a\n    else\n        return {a}\n    end\nen","completion":""}
{"prompt":"-- Take a keyword and escape all the\n-- Solr parts we want to escape!\nlocal function esc_kw(kw)\n  local r = ''\n  for i = 1, #kw do\n    local c = kw:sub(i,i)\n    if c == ':' then\n      r = r .. '\\\\:'\n    elseif c == '\/' then\n      r = r .. '\\\\\/'\n    elseif c == '?' then\n      r = r .. '\\\\?'\n    elseif c == '\\\\' then\n      r = r .. '\\\\\\\\'\n    elseif c == '+' then\n      r = r .. '\\\\+'\n    elseif c == '-' then\n      r = r .. '\\\\-'\n    elseif c == '!' then\n      r = r .. '\\\\!'\n    elseif c == '(' then\n      r = r .. '\\\\('\n    elseif c == ')' then\n      r = r .. '\\\\)'\n    elseif c == '{' then\n      r = r .. '\\\\{'\n    elseif c == '}' then\n      r = r .. '\\\\}'\n    elseif c == '[' then\n      r = r .. '\\\\['\n    elseif c == ']' then\n      r = r .. '\\\\]'\n    elseif c == '^' then\n      r = r .. '\\\\^'\n    elseif c == '\"' then\n      r = r .. '\\\\\"'\n    elseif c == '~' then\n      r = r .. '\\\\~'\n    elseif c == '*' then\n      r = r .. '\\\\*'\n    elseif c == '|' then\n      r = r .. '\\\\|'\n    else\n      r = r .. c\n    end\n  end\n  return r\nen","completion":""}
{"prompt":"-- subtracts corresponding elements\nlocal function vector_subtract(v, w)\n  local z = {}\n  for i = 1, #v do\n    z[i] = v[i] - w[i]\n  end\n  return z\nen","completion":""}
{"prompt":"-- Determine if it is northern hemisphere.\n-- Arguments:\n-- lat: float\n-- Latitude, in degrees. Northern: positive, Southern: negative.\n-- Returns:\n-- 1: northern, 0: southern.\nlocal function is_northern(lat)\n\t-- Convert latitude to radians.\n\tlocal latr = lat * (math.pi\/180)\n\t\n\t-- Determine if latitude is in north hemisphere or south.\n\tif latr >= 0 then\n\t\treturn 1\n\telse\n\t\treturn 0\n\tend\nen","completion":""}
{"prompt":"-- Expand tab characters `'\\\\t'` into spaces.\n-- :param tabstop: number of space characters per tab\n-- (defaults to the canonical 8)\n-- :param ignoring: if not `None`, the expansion will be \"smart\" and\n-- go from one tabstop to the next. In addition,\n-- this parameter lists characters which can be\n-- ignored when computing the indent.\nlocal function expandtabs(s, tabstop, ignoring)\n   if tabstop == nil then tabstop = 8 end\n   if ignoring == nil then ignoring = \" \\t\" end\n   local r = {}\n   local current = 0\n   for i = 1, #s do\n      local c = s:sub(i, i)\n      if c == '\\t' then\n         r[#r+1] = string.rep(' ', tabstop - current % tabstop)\n      else\n         r[#r+1] = c\n      end\n      if ignoring:find(c) then\n         current = current + 1\n      else\n         current = current + 1 + tabstop - 1\n      end\n   end\n   return table.concat(r)\nen","completion":""}
{"prompt":"-- Occupy the n lowest orbitals of a state in the bitstring representation\n-- Args:\n-- occ_num (integer): number of orbitals to occupy\n-- Returns:\n-- (integer): bitstring representation of the ground state\nlocal function init_bitstring_groundstate(occ_num)\n  local ground_state = 0\n  -- Fill in lowest orbital(s)\n  for i=1, occ_num do\n    ground_state = ground_state + 2^(i-1)\n  end\n  return ground_state\nen","completion":""}
{"prompt":"-- Get the radar file type (radial or raster).\n-- Args:\n-- azdat: Boolean.\n-- Returns:\n-- Radial or raster.\nlocal function get_data_type(azdat)\n  if azdat then\n    return \"radial\"\n  else\n    return \"raster\"\n  end\nen","completion":""}
{"prompt":"-- Jinja2 filter adding =-underline to row of text\n-- >>> underline_filter(\"headline\")\n-- \"headline\\n========\"\nlocal function underline_filter(text)\n\treturn text .. \"\\n\" .. string.rep(\"=\", string.len(text))\nen","completion":""}
{"prompt":"-- Escape '%' characters so they are not interpreted as strftime format\n-- specifiers, which are not supported by Zenmap.\nlocal function escape_nmap_filename(filename)\n\treturn filename:gsub(\"%%\", \"%%%%\")\nen","completion":""}
{"prompt":"-- Round number to a max of n digits after the decimal point\n-- :param number: Given number\n-- :param n: Requested number of digits after the decimal points\n-- :return: number with a max of n digits after the decimal point\nlocal function rtnd(number, n)\n\tif n == 0 then\n\t\treturn math.floor(number)\n\telse\n\t\tnumber = number * 10 ^ n\n\t\treturn math.floor(number) \/ (10 ^ n)\n\tend\nen","completion":""}
{"prompt":"-- Return the transpose of a 2 dimensional list, matrix.\n-- Args:\n-- W (list): The matrix to transpose. 2 dimensional.\n-- Returns:\n-- list: Transpose of `W`.\nlocal function transpose(W)\n  if #W == 0 then\n    return {}\n  end\n  local H = {}\n  for i=1,#W[1] do\n    H[i] = {}\n    for j=1,#W do\n      H[i][j] = W[j][i]\n    end\n  end\n  return H\nen","completion":""}
{"prompt":"-- Returns avg brightness of three colours\n-- written by anthony luo\nlocal function _avg_bright(colour)\n\treturn (colour[1] + colour[2] + colour[3]) \/ 3\nen","completion":""}
{"prompt":"-- a, b: two positive integers\n-- Returns the greatest common divisor of a and b\nlocal function gcd(a, b)\n  if a == 0 then\n    return b\n  end\n  if b == 0 then\n    return a\n  end\n  if a < 0 then\n    a = -a\n  end\n  if b < 0 then\n    b = -b\n  end\n  if a < b then\n    return gcd(b, a)\n  end\n  while b ~= 0 do\n    local q = a \/ b\n    local r = a % b\n    a = b\n    b = r\n  end\n  return a\nen","completion":""}
{"prompt":"-- Print a brief error message and return an error code.\nlocal function error(context)\n  print(\"Error: \" .. context .. \".\")\n  return 1\nen","completion":""}
{"prompt":"-- Parses an integer, possibly starting with 0b\/0o\/0x, from a string and returns it.\n-- Examples:\n-- >>> parse_mask(\"10\")\n-- 10\n-- >>> parse_mask(\"0x10\")\n-- 16\n-- >>> parse_mask(\"0o10\")\n-- 8\n-- >>> parse_mask(\"0b10\")\n-- 2\n-- >>> parse_mask(\"\")\n-- Traceback (most recent call last):\n-- ...\n-- ValueError: invalid literal for int() with base 10: ''\nlocal function parse_mask(s)\n\tif #s > 2 and s:sub(1,2) == \"0b\" then\n\t\treturn tonumber(s:sub(3), 2)\n\telseif #s > 2 and s:sub(1,2) == \"0o\" then\n\t\treturn tonumber(s:sub(3), 8)\n\telseif #s > 2 and s:sub(1,2) == \"0x\" then\n\t\treturn tonumber(s:sub(3), 16)\n\telse\n\t\treturn tonumber(s)\n\tend\nen","completion":""}
{"prompt":"-- Take the max between two numbers\n-- **Parameters**\n-- > **x:** `float` -- Description of parameter `x`.\n-- > **y:** `float` -- Description of parameter `y`.\n-- **Returns**\n-- > `float` -- Description of returned object.\nlocal function mini(x, y)\n  if x < y then return x end\n  return y\nen","completion":""}
{"prompt":"-- Replace \\ with \\\\ because RST wants it that way.\nlocal function bs(link)\n  return link:gsub(\"\\\\\", \"\\\\\\\\\")\nen","completion":""}
{"prompt":"-- convert value `a` to list\n-- Args:\n-- a: value to be convert to `list`\n-- Returns (list):\nlocal function _to_list(a)\n\treturn (type(a) == 'table') and a or {a}\nen","completion":""}
{"prompt":"-- Given (min_lon, min_lat, max_lon, max_lat) bounding box values, returns a string representation understood by\n-- Mapillary APIs.\nlocal function to_bbox_str(llo, lla, mlo, mla)\n    return table.concat( {llo, lla, mlo, mla}, \",\" )\nen","completion":""}
{"prompt":"-- Converts a color from hexadecimal to decimal tuple, color can be in\n-- the following formats: 3-digit RGB, 4-digit ARGB, 6-digit RGB and\n-- 8-digit ARGB.\nlocal function color_hex_to_dec_tuple(color)\n  local color_length = color:len()\n  if color_length == 3 then\n    return {\n      tonumber(\"0x\" .. color:sub(1, 1)) * 0x11,\n      tonumber(\"0x\" .. color:sub(2, 2)) * 0x11,\n      tonumber(\"0x\" .. color:sub(3, 3)) * 0x11\n    }\n  elseif color_length == 4 then\n    return {\n      tonumber(\"0x\" .. color:sub(1, 1)) * 0x11,\n      tonumber(\"0x\" .. color:sub(2, 2)) * 0x11,\n      tonumber(\"0x\" .. color:sub(3, 3)) * 0x11,\n      tonumber(\"0x\" .. color:sub(4, 4))\n    }\n  elseif color_length == 6 then\n    return {\n      tonumber(\"0x\" .. color:sub(1, 2)),\n      tonumber(\"0x\" .. color:sub(3, 4)),\n      tonumber(\"0x\" .. color:sub(5, 6))\n    }\n  elseif color_length == 8 then\n    return {\n      tonumber(\"0x\" .. color:sub(1, 2)),\n      tonumber(\"0x\" .. color:sub(3, 4)),\n      tonumber(\"0x\" .. color:sub(5, 6)),\n      tonumber(\"0x\" .. color:sub(7, 8))\n    }\n  else\n    error(\"Color is in incorrect format.\")\n  end\nen","completion":""}
{"prompt":"-- Speedup relative to proportion parallel\n-- Amdahl's Law gives an idealized speedup we\n-- can expect for an algorithm given the proportion\n-- that algorithm can be parallelized and the speed\n-- we gain from that parallelization. The best case\n-- scenario is that the speedup, `s`, is equal to\n-- the number of processors available.\n-- Args:\n-- p: proportion parallel\n-- s: speed up for the parallelized proportion\nlocal function amdahls_law(p, s)\n    return s \/ (p + (1 - p) * s)\nen","completion":""}
{"prompt":"-- Returns the length (number of letters) in the current hand.\n-- hand: dictionary (string int)\n-- returns: integer\nlocal function calculateHandlen(hand)\n  local sum = 0\n  for letter in pairs(hand) do\n    sum = sum + hand[letter]\n  end\n  return sum\nen","completion":""}
{"prompt":"-- Function to acquire appropriate (square) grid width for plotting.\nlocal function grid_width(cluster_num, i)\n   if cluster_num == 1 then\n      return 1\n   else\n      return math.ceil(math.sqrt(cluster_num))\n   end\nen","completion":""}
{"prompt":"-- Calculate percentage.\n-- Parameters\n-- ----------\n-- x : float or int\n-- baseValue : float or int\n-- Returns\n-- -------\n-- float\n-- Percentage of `x` out of `baseValue`, normalised to 100.\nlocal function getPercent(x, baseValue)\n\treturn (x \/ baseValue) * 100\nen","completion":""}
{"prompt":"-- Convert an integer to a hexadecimal string compatible with :class:`QColor`\n-- Args:\n-- color_number: integer value of a RGB color\n-- Returns:\n-- :class:`QColor` compatible hex string in format '#rrggbb'\nlocal function intToColorHex(color_number)\n\tlocal hex = string.format('%x', color_number)\n\twhile #hex < 6 do\n\t\thex = '0' .. hex\n\tend\n\treturn '#' .. hex\nen","completion":""}
{"prompt":"-- Given a sequence of tuples the first two elements of which are\n-- longitude and latitude, return list of lons\nlocal function extractLats(listoftups)\n\tlocal lats = {}\n\tfor i = 1, #listoftups, 1 do\n\t\tlats[#lats+1] = listoftups[i][2]\n\tend\n\treturn lats\nen","completion":""}
{"prompt":"-- Find element with most occurrences in the list\n-- Args:\n-- array (list of str): Array to be searched\n-- Returns:\n-- str: Value with most occurrences in the list\nlocal function find_element_with_max_occurrence(array)\n  local max_occurrences = 0\n  local max_element = nil\n  for _, element in pairs(array) do\n    local occurrences = 0\n    for _, value in pairs(array) do\n      if element == value then\n        occurrences = occurrences + 1\n      end\n    end\n    if occurrences > max_occurrences then\n      max_occurrences = occurrences\n      max_element = element\n    end\n  end\n  return max_element\nen","completion":""}
{"prompt":"-- Returns the location of {i,j} in the set {{0,0},{0,1},...,{0,qj-1},...{qi-1,qj-1}}.\nlocal function sindex(i, j, qi, qj)\n\treturn j + qj * i\nen","completion":""}
{"prompt":"-- Extracts the git revision from the prerelease identifier.\n-- This is assumed to be the last `.` separated component.\nlocal function _extract_git_revision(prerelease)\n    return prerelease:match(\".-([^.]+)$\") or \"\"\nen","completion":""}
{"prompt":"-- A language code may come in two parts as per ISO 639-1. For the case of\n-- pt-BR, the first part would be the primary language (pt) and the second\n-- one, the country code. This function retruns the primary language part of\n-- the language code.\nlocal function get_primary_language(lang)\n    return lang:gsub(\"%-.*$\", \"\")\nen","completion":""}
{"prompt":"-- Gets the team url from the NHL API.\n-- :param teamid: int, the team ID\n-- :return: str, http:\/\/statsapi.web.nhl.com\/api\/v1\/teams\/[teamid]\nlocal function get_team_info_url(teamid)\n\treturn string.format(\"http:\/\/statsapi.web.nhl.com\/api\/v1\/teams\/%s\", teamid)\nen","completion":""}
{"prompt":"-- Replaces link breaks (NL, CR) into whitespaces.\n-- Args:\n-- src_str string: A source string.\n-- Returns:\n-- A modified string.\nlocal function remove_line_break(src_str)\n    return src_str:gsub(\"\\n\", \" \"):gsub(\"\\r\", \"\")\nen","completion":""}
{"prompt":"-- Transforms points from the interval [-1,1] to the interval [a,b].\n-- Parameters\n-- ----------\n-- x : numpy array\n-- The points to be tranformed.\n-- a : float or numpy array\n-- The lower bound on the interval. Float if one-dimensional, numpy array if multi-dimensional\n-- b : float or numpy array\n-- The upper bound on the interval. Float if one-dimensional, numpy array if multi-dimensional\n-- Returns\n-- -------\n-- transform : numpy array\n-- The transformed points.\nlocal function transform(x, a, b)\n   if type(a) == 'number' then\n      return (b-a)\/2*x + (b+a)\/2\n   else\n      return (b-a)\/2*x + (b+a)\/2\n   end\nen","completion":""}
{"prompt":"-- Takes an integer and returns a string of length 3 corresponding to it\nlocal function toTD(n)\n\tif n >= 100 then\n\t\treturn string.format(\"%03d\", n)\n\telseif n >= 10 then\n\t\treturn string.format(\"0%02d\", n)\n\telse\n\t\treturn string.format(\"00%d\", n)\n\tend\nen","completion":""}
{"prompt":"-- Parses a string of numbers and ranges into a list of integers. Ranges\n-- are separated by dashes and inclusive of both the start and end number.\n-- Example:\n-- parse_int_list(\"8 9 10,11-13\") == [8,9,10,11,12,13]\nlocal function parse_int_list(string)\n  local list = {}\n  for part in string:gmatch(\"[%w%-]+\") do\n    if part:find(\"%-\") then\n      local start, end_ = part:match(\"(%d+)%-(%d+)\")\n      for i = start, end_, 1 do\n        table.insert(list, i)\n      end\n    else\n      table.insert(list, tonumber(part))\n    end\n  end\n  return list\nen","completion":""}
{"prompt":"-- Given alns (already clipped to the window bounds), filter out any\n-- that are incompatible with Arrow.\n-- By and large we avoid doing any filtering to avoid potential\n-- reference bias in variant calling.\n-- However at the moment the POA (and potentially other components)\n-- breaks when there is a read of zero length.  So we throw away\n-- reads that are \"stumpy\", where the aligner has inserted a large\n-- gap, such that while the alignment technically spans the window,\n-- it may not have any read content therein:\n-- Ref   ATGATCCAGTTACTCCGATAAA\n-- Read  ATG---------------TA-A\n-- Win.     [              )\nlocal function filterAlns(refWindow, alns, arrowConfig)\n  local filteredAlns = {}\n  local numAlns = 0\n  for _, aln in ipairs(alns) do\n    -- If the alignment is empty, discard it:\n    if aln.qlen == 0 then\n      -- TODO: We should log a warning here, if the user has\n      -- configured logging.\n    elseif aln.rlen == 0 then\n      -- TODO: We should log a warning here, if the user has\n      -- configured logging.\n    elseif aln.strand == 1 then\n      -- Check the read length against the max read length allowed:\n      if aln.qlen > arrowConfig.maxReadLength then\n        -- TODO: We should log a warning here, if the user has\n        -- configured logging.\n      else\n        -- Check whether the alignment straddles the window boundary:\n        if aln.qend > refWindow.qend or aln.rend > refWindow.rend then\n          -- TODO: We should log a warning here, if the user has\n          -- configured logging.\n        else\n          -- The alignment passes all tests, so save it:\n          filteredAlns[#filteredAlns + 1] = aln\n          numAlns = numAlns + 1\n        end\n      end\n    end\n  end\n  return filteredAlns, numAlns\nen","completion":""}
{"prompt":"-- Create a single-quoted string for a shell\n-- :param string:\n-- A unicode string to quote\n-- :return:\n-- A unicode string quoted for a shell\nlocal function _shell_quote(string)\n    string = string:gsub(\"'\", \"'\\\\''\")\n    return \"'\" .. string .. \"'\"\nen","completion":""}
{"prompt":"-- Find the greatest common multiple of 2 numbers\nlocal function GCD_SIMPLE(num1, num2)\n  if num1 == 0 then\n    return num2\n  end\n  return GCD_SIMPLE(num2 % num1, num1)\nen","completion":""}
{"prompt":"-- Calculate the Greatest Common Divisor of a and b.\n-- Unless b==0, the result will have the same sign as b (so that when\n-- b is divided by it, the result comes out positive).\nlocal function gcd(a, b)\n  return b == 0 and a or gcd(b, a%b)\nen","completion":""}
{"prompt":"-- Generate consecutive values list between two numbers.\nlocal function number_range(a, b)\n    local t = {}\n    for i = a, b do table.insert(t, i) end\n    return t\nen","completion":""}
{"prompt":"-- Dict deep merge function\n-- Merge recursive second dict in first and return it\n-- >>> deep_merge({},{})\n-- {}\n-- >>> deep_merge({'key': 'value'}, {'key': 'value'})\n-- {'key': 'value'}\n-- >>> deep_merge({'key': 'value'}, {'key': 'new_value', 'second_key': 'second_value'})\n-- {'key': 'new_value', 'second_key': 'second_value'}\n-- >>> deep_merge(\n-- ...     {'key': 'value', 'dict_key': {'nested_key': 'nested_value'}},\n-- ...     {\n-- ...         'key': 'value',\n-- ...         'dict_key': {'nested_key': 'new_nested_value', 'nested_dict_key': {}},\n-- ...         'flat_key': 'flat_value'\n-- ...     }\n-- ... )\n-- {'key': 'value', 'dict_key': {'nested_key': 'new_nested_value', 'nested_dict_key': {}}, 'flat_key': 'flat_value'}\nlocal function deep_merge(first, second)\n    for key, value in pairs(second) do\n        if type(value) == 'table' and first[key] and type(first[key]) == 'table' then\n            deep_merge(first[key], value)\n        else\n            first[key] = value\n        end\n    end\n    return first\nen","completion":""}
{"prompt":"-- Return 0 if x<eps, otherwise return x\nlocal function zero_if_less_than(x, eps)\n   return x < eps and 0 or x\nen","completion":""}
{"prompt":"-- Round down, to the nearest even 100\nlocal function rd(v, n)\n  n = n or 100\n  return math.floor(v \/ n) * n\nen","completion":""}
{"prompt":"-- Replace curved quotes with straight quotes in a custom parameter name.\n-- These should be the only keys with problematic (non-ascii) characters,\n-- since they can be user-generated.\nlocal function _normalize_custom_param_name(name)\n  local s = name:gsub(\"\u2018\", \"'\")\n  s = s:gsub(\"\u2019\", \"'\")\n  s = s:gsub(\"\u201c\", '\"')\n  s = s:gsub(\"\u201d\", '\"')\n  return s\nen","completion":""}
{"prompt":"-- Scales x by scaling factor s.\n-- Parameters\n-- ----------\n-- x : float\n-- s : float\n-- Returns\n-- -------\n-- x : float\nlocal function scale(x, s)\n    if s ~= 1 then\n        x = x * s\n    end\n    return x\nen","completion":""}
{"prompt":"-- Normalization function that performs SNAPPY normalization (hyphen to underscore).\nlocal function normalize_snappy(s)\n  return (s:gsub(\"-\", \"_\"))\nen","completion":""}
{"prompt":"-- we are going to verify outputs in groups\nlocal function distribute(N, div)\n  if div > N then\n    error(\"divisor must be less than N\")\n  end\n  if div == 1 then\n    return { N }\n  end\n  local out = {}\n  local rest = N % div\n  local quot = (N - rest) \/ div\n  for i = 1, div do\n    table.insert(out, quot)\n  end\n  if rest > 0 then\n    table.insert(out, rest)\n  end\n  return out\nen","completion":""}
{"prompt":"-- Run calculation, round up, and return result.\nlocal function roundu(x, y, z)\n   return math.ceil((x * y) \/ z)\nen","completion":""}
{"prompt":"-- Tries to determin the quotation (`\"` or `'`) used in a given string.\n-- `\"` is the default and used when no quotations are found or\n-- the amount of `\"` and `'` are equal\nlocal function get_prefered_quotation_from_string(string)\n  local quote_count = 0\n  for i = 1, #string do\n    local char = string:sub(i, i)\n    if char == '\"' then\n      quote_count = quote_count + 1\n    elseif char == \"'\" then\n      quote_count = quote_count - 1\n    end\n  end\n  if quote_count > 0 then\n    return '\"'\n  elseif quote_count < 0 then\n    return \"'\"\n  end\n  return '\"'\nen","completion":""}
{"prompt":"-- The transpose of the matrix.\n-- Args\n-- ----\n-- A (compulsory)\n-- A matrix.\n-- mul_factor (int\/float, optional)\n-- Multiplication factor of the matrix. Defaults to 1.\n-- Returns\n-- -------\n-- Matrix\n-- The transpose of the given matrix multiplied by the multiplication factor.\nlocal function transpose(A, mul_factor)\n  local mul_factor = mul_factor or 1\n  local result = {}\n  for i = 1, #A[1] do\n    result[i] = {}\n    for j = 1, #A do\n      result[i][j] = A[j][i] * mul_factor\n    end\n  end\n  return result\nen","completion":""}
{"prompt":"-- Escape HTML\/XML special characters (& < >) in a string that's to be embedded in a text part of an HTML\/XML document.\n-- For escaping attribute values use html_attr_escape() - attributes need a different set of special characters to be escaped.\nlocal function html_escape(text)\n    return text:gsub(\n        \"[&<>]\"\n        , function (c)\n            if c == \"&\" then\n                return \"&amp;\"\n            elseif c == \"<\" then\n                return \"&lt;\"\n            elseif c == \">\" then\n                return \"&gt;\"\n            end\n        end\n    )\nen","completion":""}
{"prompt":"-- bigrams at sublist level\n-- >>> sublist_bigrams(['V V', 'R , V O V D N', 'P O V'])\n-- [('V', 'V'), ('R', ','), (',', 'V'), ('V', 'O'), ('P', 'O'), ('O', 'V')]\nlocal function sublist_bigrams(pos_list)\n  local bigrams = {}\n  for _, chunk in pairs(pos_list) do\n    local prev_token\n    for token in chunk:gmatch('%w+') do\n      if prev_token then\n        table.insert(bigrams, {prev_token, token})\n      end\n      prev_token = token\n    end\n  end\n  return bigrams\nen","completion":""}
{"prompt":"-- :param dict layer_boundaries_dict: the distance from the deepest point of a track to each layer\n-- :param int probe_insert_distance: the distance the probe was inserted (based on experiment, not histology)\n-- :param tip_to_0th_channel_distance: the distance from the tip of the probe to the first recording site\n-- :return:\nlocal function layer_boundaries_relative_to_channel_0_dict(layer_boundaries_dict, probe_insert_distance, tip_to_0th_channel_distance)\n    local new_dict = {}\n    for layer, boundary in pairs(layer_boundaries_dict) do\n        new_dict[layer] = boundary - tip_to_0th_channel_distance\n    end\n    return new_dict\nen","completion":""}
{"prompt":"-- Calculates Percentage Error. \n-- returns float\nlocal function calcPercentageError(actualResult, forecastResult)\n    -- Calculate Percentage Error\n    return ((actualResult - forecastResult)\/actualResult) * 100\nen","completion":""}
{"prompt":"-- solving the fibonacci sequence with recursion\n-- >>> fib(1)\n-- 1\n-- >>> fib(2)\n-- 1\n-- >>> fib(3)\n-- 2\n-- >>> fib(4)\n-- 3\n-- >>> fib(5)\n-- 5\nlocal function fib(n)\n  if n < 2 then return n end\n  return fib(n - 1) + fib(n - 2)\nen","completion":""}
{"prompt":"-- Break up line into a list of component Fortran statements\n-- Note, because this is a simple script, we can cheat on the\n-- interpretation of two consecutive quote marks.\n-- >>> line_statements('integer :: i, j')\n-- ['integer :: i, j']\n-- >>> line_statements('integer :: i; real :: j')\n-- ['integer :: i', ' real :: j']\n-- >>> line_statements('integer :: i ! Do not break; here')\n-- ['integer :: i ! Do not break; here']\n-- >>> line_statements(\"write(6, *) 'This is all one statement; y''all;'\")\n-- [\"write(6, *) 'This is all one statement; y''all;'\"]\n-- >>> line_statements('write(6, *) \"This is all one statement; y\"\"all;\"')\n-- ['write(6, *) \"This is all one statement; y\"\"all;\"']\n-- >>> line_statements(\" ! This is a comment statement; y'all;\")\n-- [\" ! This is a comment statement; y'all;\"]\n-- >>> line_statements(\"!! \")\n-- ['!! ']\nlocal function line_statements(line)\n  local stmt_list = {}\n  local p = line:find(\" !\", 1, true)\n  local q = line:find(\"!!\", 1, true)\n  if p and q and p < q then\n    stmt_list[#stmt_list+1] = line:sub(1, p-1)\n    stmt_list[#stmt_list+1] = line:sub(p)\n  else\n    stmt_list[#stmt_list+1] = line\n  end\n  return stmt_list\nen","completion":""}
{"prompt":"-- Min function for real numbers\n-- Parameters\n-- ----------\n-- a: scalar\n-- b: scalar\n-- Returns\n-- -------\n-- scalar\nlocal function rmin(a, b)\n    if a < b then return a else return b end\nen","completion":""}
{"prompt":"-- Usually the distribution of the character brightness for a given font\n-- is not as diverse as we would like it to be. This results in a pretty\n-- poor result during the image to ASCII art conversion (if used as-is).\n-- Because of this it's much better to normalize the brightness distribution.\n-- Normalization widens the distribution ranges to 8-bit 0-255 range.\n-- Args:\n-- brightness_dict (dict): A map of characters to brightness.\n-- Returns:\n-- dict: normalized map of characters to brightness.\nlocal function normalize_brightness_dict(brightness_dict)\n  local max_brightness = 0\n  for _, brightness in pairs(brightness_dict) do\n    if brightness > max_brightness then\n      max_brightness = brightness\n    end\n  end\n  local normalized_brightness_dict = {}\n  for char, brightness in pairs(brightness_dict) do\n    normalized_brightness_dict[char] = (brightness \/ max_brightness) * 255\n  end\n  return normalized_brightness_dict\nen","completion":""}
{"prompt":"-- Return number of samples required to cover duration in seconds.\nlocal function sec_to_samples(n_sec, sr)\n\treturn math.floor(n_sec * sr)\nen","completion":""}
{"prompt":"-- Check answer. Correct: 1 point, else 0\nlocal function points(a, b, answer_given)\n    local answer_correct = (a * b == answer_given)\n    return (answer_correct and 1 or 0)\nen","completion":""}
{"prompt":"-- Find the absolute value of a number.\n-- >>> abs_val(-5.1)\n-- 5.1\n-- >>> abs_val(-5) == abs_val(5)\n-- True\n-- >>> abs_val(0)\n-- 0\nlocal function abs_val(num)\n    if num < 0 then return -num else return num end\nen","completion":""}
{"prompt":"-- The Grasshopper is in position 1.\n-- The Grasshopper may jump to +1, +2 or +3.\n-- How many possible trajectories does the grasshopper have to get to position n?\n-- If n<=1, consider that the Grasshopper has 0 possible trajectory.\n-- >>> count_trajectories(0)\n-- 0\n-- >>> count_trajectories(1)\n-- 0\n-- >>> count_trajectories(2)\n-- 1\n-- >>> count_trajectories(3)\n-- 2\n-- >>> count_trajectories(4)\n-- 3\n-- >>> count_trajectories(7)\n-- 20\n-- >>> count_trajectories(-3)\n-- 0\nlocal function count_trajectories(n)\n    if n <= 0 then\n        return 0\n    elseif n == 1 then\n        return 0\n    elseif n == 2 then\n        return 1\n    elseif n == 3 then\n        return 2\n    else\n        return count_trajectories(n - 1) + count_trajectories(n - 2) + count_trajectories(n - 3)\n    end\nen","completion":""}
{"prompt":"-- Assumes n int >= 0\n-- Returns Fibonacci of n\nlocal function fib(n)\n    if n < 2 then\n        return 1\n    end\n    return fib(n - 1) + fib(n - 2)\nen","completion":""}
{"prompt":"-- Eliminar espacios a los bordes\n-- Elimina los espacios en blanco al inicio y final del string deseado.\n-- Args:\n-- input(String): palabra a recortar\n-- Returns:\n-- String\nlocal function trim(input)\n    return (input:gsub(\"^%s*(.-)%s*$\", \"%1\"))\nen","completion":""}
{"prompt":"-- Returns the hypotenuse of point.\nlocal function hypot(a)\n  local sum = 0\n  for _, v in ipairs(a) do\n    sum = sum + v * v\n  end\n  return math.sqrt(sum)\nen","completion":""}
{"prompt":"-- return the percentage of dna composed of G+C\nlocal function gc(s)\n  local gc = 0\n  for c in string.gmatch(s,\".\") do\n    if c == 'C' or c == 'G' then\n      gc = gc + 1\n    end\n  end\n  return gc\/string.len(s)*100\nen","completion":""}
{"prompt":"-- Escape single quotes for use in a shell single quoted string\n-- Explanation:\n-- (1) End first quotation which uses single quotes.\n-- (2) Start second quotation, using double-quotes.\n-- (3) Quoted character.\n-- (4) End second quotation, using double-quotes.\n-- (5) Start third quotation, using single quotes.\n-- If you do not place any whitespaces between (1) and (2), or between\n-- (4) and (5), the shell will interpret that string as a one long word\nlocal function shell_escape_single_quote(command)\n  return command:gsub(\"'\", \"'\\\"'\\\"'\")\nen","completion":""}
{"prompt":"-- change odd elements of the list to floats\nlocal function _parse_methods(methods)\n   if type(methods) == \"table\" then\n      return methods\n   elseif type(methods) == \"string\" then\n      methods = methods:split(\",\")\n      for k,v in ipairs(methods) do\n         methods[k] = v:trim()\n      end\n      return methods\n   else\n      return {}\n   end\nen","completion":""}
{"prompt":"-- @brief Determines the last count instructions\n-- with the flag instruction_flag\n-- @param count Number of last instructions that should be found\n-- @param ps_lst List of PseudoInstructions\n-- @param last_pos Last position to search\n-- @param instruction_flag Flag that defines a instruction\n-- @return List of indices or None\nlocal function search_last_inst(count, ps_lst, last_pos, instruction_flag)\n    local ret_lst = {}\n    local last_pos = last_pos or 1\n    local cnt = 0\n    for i, ps in ipairs(ps_lst) do\n        if ps.pos <= last_pos and ps.flag == instruction_flag then\n            ret_lst[#ret_lst + 1] = i\n            cnt = cnt + 1\n            if cnt >= count then\n                return ret_lst\n            end\n        end\n    end\n    return nil\nen","completion":""}
{"prompt":"-- Checks for int\/float before settling on string\nlocal function find_type(string_in)\n\t-- Try to convert to int\n\tlocal int_out = tonumber(string_in)\n\tif int_out ~= nil then\n\t\treturn int_out, \"int\"\n\tend\n\t\n\t-- Try to convert to float\n\tlocal float_out = tonumber(string_in)\n\tif float_out ~= nil then\n\t\treturn float_out, \"float\"\n\tend\n\t\n\treturn string_in, \"string\"\nen","completion":""}
{"prompt":"-- Return a formatted time string 'HH:MM:SS\n-- based on a numeric time() value\nlocal function format_time(t)\n  return string.format(\"%02d:%02d:%02d\", math.floor(t \/ 3600), math.floor(t % 3600 \/ 60), math.floor(t % 60))\nen","completion":""}
{"prompt":"-- Learning Rate Schedule\n-- Learning rate is scheduled to be reduced after 30, 60, 90, 120 epochs.\n-- Called automatically every epoch as part of callbacks during training.\n-- # Arguments\n-- epoch (int): The number of epochs\n-- # Returns\n-- lr (float32): learning rate\nlocal function lr_schedule(epoch)\n  if epoch <= 30 then\n    return 0.001\n  elseif epoch <= 60 then\n    return 0.0001\n  elseif epoch <= 90 then\n    return 0.00001\n  elseif epoch <= 120 then\n    return 0.000001\n  else\n    return 0.0000001\n  end\nen","completion":""}
{"prompt":"-- Escape HTML special characters\nlocal function esc(s)\n\ts = string.gsub(s, \"&\", \"&amp;\")\n\ts = string.gsub(s, \"<\", \"&lt;\")\n\ts = string.gsub(s, \">\", \"&gt;\")\n\ts = string.gsub(s, \"\\\"\", \"&quot;\")\n\ts = string.gsub(s, \"'\", \"&apos;\")\n\treturn s\nen","completion":""}
{"prompt":"-- Compute factorial of a number RECURSIVELY.\nlocal function recursive_factorial(number)\n    if number == 0 or number == 1 then\n        return 1\n    else\n        return number * recursive_factorial(number - 1)\n    end\nen","completion":""}
{"prompt":"-- Add 0s to inputs that their length is less than 3.\n-- For example: 1 --> 001 | 02 --> 020 | st --> 0st\nlocal function three_digit(number)\n  local number = tostring(number)\n  if #number == 1 then\n    number = \"00\" .. number\n  elseif #number == 2 then\n    number = \"0\" .. number\n  end\n  return number\nen","completion":""}
{"prompt":"-- Computes the number of ways of traveling from source to destination.\n-- Args:\n-- m: The total vertical distance.\n-- n: The total horizontal distance.\n-- Returns:\n-- The number of ways ways you can travel to the goal on a grid\n-- with dimensions (m x n).\nlocal function grid_traveler_memo(m, n, memo)\n  memo = memo or {}\n  if memo[m] and memo[m][n] then return memo[m][n] end\n  if m == 1 and n == 1 then return 1 end\n  if m == 0 or n == 0 then return 0 end\n  if not memo[m] then memo[m] = {} end\n  memo[m][n] = grid_traveler_memo(m - 1, n, memo) + grid_traveler_memo(m, n - 1, memo)\n  return memo[m][n]\nen","completion":""}
{"prompt":"-- Returns the directory's name.\n-- Args:\n-- path: The path to return the directory for\n-- Returns:\n-- The directory's name.\nlocal function dirname(path)\n  return string.match(path, \"(.*)\/\") or \"\"\nen","completion":""}
{"prompt":"-- recursive\nlocal function fact(n)\n   if n == 0 then\n      return 1\n   else\n      return n * fact(n-1)\n   end\nen","completion":""}
{"prompt":"-- Takes Numeric Code and returns String API code\n-- Input Values: 1:\"Base\", 2:\"Advanced\", 3:\"Misc\", 4:\"Four Factors\", 5:\"Scoring\", 6:\"Opponent\", 7:\"Usage\"\n-- Used in:\nlocal function measure_type(x)\n    if x == 1 then\n        return \"Base\"\n    elseif x == 2 then\n        return \"Advanced\"\n    elseif x == 3 then\n        return \"Misc\"\n    elseif x == 4 then\n        return \"Four Factors\"\n    elseif x == 5 then\n        return \"Scoring\"\n    elseif x == 6 then\n        return \"Opponent\"\n    elseif x == 7 then\n        return \"Usage\"\n    end\nen","completion":""}
{"prompt":"-- Integrate (1-m*(a-ttrunc)) da from a=ttrunc to a=t\nlocal function linear_mass(t, ttrunc, m)\n    local a = t - ttrunc\n    local da = m*(a-ttrunc)\n    return a, da\nen","completion":""}
{"prompt":"-- Identifies the compression scheme of a given file (if any) and return a\n-- tuple with the appropriate cat command to decompress it.\nlocal function _select_cat(filename)\n   -- Try to identify the compression scheme, and if it's compressed, then\n   -- use the appropriate cat command to decompress it.\n   if filename:find(\"%.gz$\") then\n      return {\"gunzip\", \"-c\"}\n   elseif filename:find(\"%.bz2$\") then\n      return {\"bunzip2\", \"-c\"}\n   elseif filename:find(\"%.xz$\") then\n      return {\"unxz\", \"-c\"}\n   else\n      return {\"cat\"}\n   end\nen","completion":""}
{"prompt":"-- # Custom objects\n-- The datetime example works through the use of the `__format__()` magic\n-- method. You can define custom format handling in your own objects by\n-- overriding this method. This gives you complete control over the format\n-- syntax used.\nlocal function test_custom_1()\n  local custom = {\n    __format__ = function(self, fmt)\n      local dt = self.date:format(fmt)\n      return string.format(\"%s %s\", self.name, dt)\n    end,\n    name = \"Bob\",\n    date = \"2015-05-26 15:45:30\"\n  }\n  print(string.format(\"%s's Birthday is %s\", custom, custom))\nen","completion":""}
{"prompt":"-- Formats a (zero-based) month number as a full month name, according to the current locale. For example: monthFormat(0) -> \"January\".\nlocal function monthFormat(month)\n    return os.date(\"%B\", os.time{year=2000, month=month+1, day=1})\nen","completion":""}
{"prompt":"-- Cook up a fake imagegroup json object from given ids.\nlocal function image_group_object_factory(image_id, group_id)\n\treturn {\n\t\timage_id = image_id,\n\t\tgroup_id = group_id,\n\t}\nen","completion":""}
{"prompt":"-- Round the value x to the nearest integer. This method is necessary since in Python 3 the builtin\n-- round() function is performing Bankers rounding, i.e. rounding to the nearest even integer value.\n-- :param x: value to be rounded\n-- :type x: Union[int, float]\n-- :return: the closest integer to x\nlocal function round_to_nearest_integer(x)\n  return math.floor(x + 0.5)\nen","completion":""}
{"prompt":"-- Remove line breaks from text\nlocal function remove_line_break(text)\n  if type(text) == \"table\" then\n    local output = {}\n    for k, v in ipairs(text) do\n      output[k] = v:gsub(\"\\n\", \"\")\n    end\n    return output\n  else\n    return text:gsub(\"\\n\", \"\")\n  end\nen","completion":""}
{"prompt":"-- Change the array as [\"1\",\"2\",\"3\"] to \"1,2,3\"\n-- Returns:\n-- string\nlocal function array_to_csv_str(array)\n    local result = \"\"\n    if array == nil then\n        return result\n    end\n    for i,v in ipairs(array) do\n        result = result .. tostring(v)\n        if i < #array then\n            result = result .. \",\"\n        end\n    end\n    return result\nen","completion":""}
{"prompt":"-- Return the correct part of a model to use for filtering.\n-- This is necessary because the API allows to filter models using this syntax:\n-- model:attribute:value\n-- Where \"attribute\" is actually an attribute of the model's traintuple or\n-- composite_traintuple (depending on its type).\nlocal function _get_model_tuple(model)\n    if model.traintuple ~= nil then\n        return model.traintuple\n    elseif model.composite_traintuple ~= nil then\n        return model.composite_traintuple\n    elseif model.aggregatetuple ~= nil then\n        return model.aggregatetuple\n    elseif model.testtuple ~= nil then\n        return model.testtuple\n    elseif model.aggregatetuple ~= nil then\n        return model.aggregatetuple\n    else\n        assert(false)\n    end\nen","completion":""}
{"prompt":"-- acrescenta_elemento: resposta x string x coordenada --> resposta\n-- acrescenta_elemento(r,s,c) devolve a resposta r com mais um elemento - o\n-- tuplo (s, c).\nlocal function acrescenta_elemento(r, s, c)\n  -- Tabela auxiliar.\n  local t = {}\n  -- Inicializa o vetor auxiliar.\n  for i = 1, #r do t[i] = {r[i][1], r[i][2]} end\n  -- Adiciona elemento.\n  t[#t + 1] = {s, c}\n  -- Devolve resposta.\n  return t\nen","completion":""}
{"prompt":"-- Convert latitude\/ longitude decimal form to dms form\n-- Keyword arguments:\n-- elem -- latitude or longitude in decimal form\nlocal function convert_decimal_to_dms(elem)\n  local dms = {}\n  local d = math.floor(elem)\n  local m = math.floor((elem - d)*60)\n  local s = math.floor(((elem - d)*60 - m)*60)\n  if (s == 60) then s = 0; m = m+1; end\n  if (m == 60) then m = 0; d = d+1; end\n  table.insert(dms, d)\n  table.insert(dms, m)\n  table.insert(dms, s)\n  return dms\nen","completion":""}
{"prompt":"-- For parm current space and die roll, return the new space the pawn will land on.\nlocal function move(space, d)\n  return (space + d - 1) % 10 + 1\nen","completion":""}
{"prompt":"-- This method will transform a string value from the None \/ Low \/ Med \/\n-- High scale to its confidence integer representation.\n-- The scale for this confidence representation is the following:\n-- .. list-table:: None, Low, Med, High to STIX Confidence\n-- :header-rows: 1\n-- * - None\/ Low\/ Med\/ High\n-- - STIX Confidence Value\n-- * - Not Specified\n-- - Not Specified\n-- * - None\n-- - 0\n-- * - Low\n-- - 15\n-- * - Med\n-- - 50\n-- * - High\n-- - 85\n-- Args:\n-- scale_value (str): A string value from the scale. Accepted strings are\n-- \"None\", \"Low\", \"Med\" and \"High\". Argument is case sensitive.\n-- Returns:\n-- int: The numerical representation corresponding to values in the\n-- None \/ Low \/ Med \/ High scale.\n-- Raises:\n-- ValueError: If `scale_value` is not within the accepted strings.\nlocal function none_low_med_high_to_value(scale_value)\n  if scale_value == nil or scale_value == \"None\" then\n    return 0\n  elseif scale_value == \"Low\" then\n    return 15\n  elseif scale_value == \"Med\" then\n    return 50\n  elseif scale_value == \"High\" then\n    return 85\n  else\n    error(\"`scale_value` must be 'None', 'Low', 'Med' or 'High'\")\n  end\nen","completion":""}
{"prompt":"-- Convert an fno to an NA.\n-- Parameters\n-- ----------\n-- fno : `float`\n-- focal ratio\n-- Returns\n-- -------\n-- `float`\n-- NA.  The NA of the system.\nlocal function fno_to_na(fno)\n    if fno == 0.0 then\n        return 1.0\n    else\n        return (1.0 \/ (2 * fno))\n    end\nen","completion":""}
{"prompt":"-- Given a surface represented by points and faces, remove all\n-- faces that contain a boundary vertex. Return a new faces list\n-- without these faces.\nlocal function _remove_boundary_faces(points, faces, boundary_indices)\n    if #boundary_indices == 0 then return faces end\n    local i = 1\n    local num_faces = #faces\n    while i <= num_faces do\n        local face = faces[i]\n        local num_face_points = #face\n        local face_boundary = false\n        for j = 1, num_face_points do\n            if boundary_indices[face[j]] then\n                face_boundary = true\n                break\n            end\n        end\n        if face_boundary then\n            table.remove(faces, i)\n            num_faces = num_faces - 1\n        else\n            i = i + 1\n        end\n    end\n    return faces\nen","completion":""}
{"prompt":"-- Pasa de string a int\nlocal function clean_integer(num)\n\tlocal result = 0\n\tfor char in num:gmatch(\"%d\") do\n\t\tresult = result * 10 + char\n\tend\n\treturn result\nen","completion":""}
{"prompt":"-- Returns an estimate for the perimeter of an ellipse of semi-major axis\n-- maj_ax and semi-minor axis min_ax\nlocal function ellipse_perimeter(maj_ax, min_ax)\n  local a = maj_ax\n  local b = min_ax\n  return math.pi * (3 * (a + b) - math.sqrt((3 * a + b) * (a + 3 * b)))\nen","completion":""}
{"prompt":"-- Sieve of Erathosthenes\n-- Output the list of all primes less than n\nlocal function prime_sieve_erathosthenes(n)\n    local primes = {}\n    local is_prime = {}\n    for i = 2, n do is_prime[i] = true end\n    for i = 2, n do\n        if is_prime[i] then\n            primes[#primes + 1] = i\n            local j = i * i\n            while j <= n do\n                is_prime[j] = false\n                j = j + i\n            end\n        end\n    end\n    return primes\nen","completion":""}
{"prompt":"-- Internal helper to ensure data is a tuple of given `num` length.\nlocal function __assert_data_tuple(data, num)\n  if data == nil then\n    data = {}\n  end\n  if type(data) ~= \"table\" then\n    data = {data}\n  end\n  if #data ~= num then\n    data = {data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8]}\n  end\n  return data\nen","completion":""}
{"prompt":"-- Remove all characters c and C from a string.\nlocal function no_c(my_string)\n    return my_string:gsub(\"[cC]\", \"\")\nen","completion":""}
{"prompt":"-- Returns the nth pentagonal number.\nlocal function pentagonalNum(n)\n    return (n * (3 * n - 1)) \/ 2\nen","completion":""}
{"prompt":"-- Quote a string literal for \/bin\/sh.\nlocal function shellquote(text)\n    return \"'\"..text:gsub(\"'\", \"'\\\\''\")..\"'\"\nen","completion":""}
{"prompt":"-- Clamps a signed short to be within its upper and lower bounds.\nlocal function clamp_short(x)\n    return math.max(math.min(x, 32767), -32768)\nen","completion":""}
{"prompt":"-- Convert\n-- {'x_position': 0.008984250082219904, 'x_velocity': -0.026317885259067864, 'angle_position': -0.007198829694026056, 'angle_velocity': -0.03567818795116845}\n-- from the sim into what my brain expects\n-- ['cart_position', 'cart_velocity', 'pole_angle', 'pole_angular_velocity']\nlocal function transform_state(sim_state)\n\treturn {\n\t\tcart_position = sim_state.x_position,\n\t\tcart_velocity = sim_state.x_velocity,\n\t\tpole_angle = sim_state.angle_position,\n\t\tpole_angular_velocity = sim_state.angle_velocity,\n\t}\nen","completion":""}
{"prompt":"-- Max function for real numbers\n-- Parameters\n-- ----------\n-- a: scalar\n-- b: scalar\n-- Returns\n-- -------\n-- scalar\nlocal function rmax(a, b)\n    return a > b and a or b\nen","completion":""}
{"prompt":"-- Merge all metrics dictionaries in list into a single object.\nlocal function combine_metrics(metrics_data)\n  local combined = {}\n  for _, metrics in pairs(metrics_data) do\n    for k, v in pairs(metrics) do\n      combined[k] = v\n    end\n  end\n  return combined\nen","completion":""}
{"prompt":"-- Returns the sum of all multiples of 3 and 5 below a given number.\nlocal function sum_multiples_3_and_5(number)\n  local total = 0\n  for i = 1, (number - 1) do\n    if i % 3 == 0 or i % 5 == 0 then\n      total = total + i\n    end\n  end\n  return total\nen","completion":""}
{"prompt":"-- Write a function named sum_digits which takes a number as input and\n-- returns the sum of the absolute value of each of the number's decimal digits.\nlocal function sum_digits(number)\n    local sum = 0\n    for i in tostring(number):gmatch(\"[0-9]\") do\n        sum = sum + tonumber(i)\n    end\n    return sum\nen","completion":""}
{"prompt":"-- concatenate the lists back in order for the next step\nlocal function merge(lst)\n  local result = {}\n  local pos = 1\n  for _,v in pairs(lst) do\n    local n = #v\n    for i = 1,n do\n      result[pos] = v[i]\n      pos = pos + 1\n    end\n  end\n  return result\nen","completion":""}
{"prompt":"-- Compute the intersection length of two tuples.\n-- Args:\n-- A: a (speaker, start, end) tuple of type (string, float, float)\n-- B: a (speaker, start, end) tuple of type (string, float, float)\n-- Returns:\n-- a float number of the intersection between `A` and `B`\nlocal function compute_intersection_length(A, B)\n  local t = math.max(A[2], B[2])\n  local u = math.min(A[3], B[3])\n  if t < u then\n    return u - t\n  else\n    return 0\n  end\nen","completion":""}
{"prompt":"-- A recursive function calcuating Fibonnaci sequence\n-- Parameters\n-- ----------\n-- n : integer\n-- the nth Fibonnaci number in the sequence\n-- Returns\n-- -------\n-- recursively calling fib_rec to calculte Fibonnaci number.\n-- Will return the nth Fibonnaci number\nlocal function fib_rec(n)\n    if n == 0 then\n        return 0\n    elseif n == 1 then\n        return 1\n    else\n        return fib_rec(n - 1) + fib_rec(n - 2)\n    end\nen","completion":""}
{"prompt":"-- Reverse complement a DNA sequence.\nlocal function reverse_complement(seq)\n    local rev_seq = {}\n    local complement = {A = 'T', C = 'G', G = 'C', T = 'A', a = 't', c = 'g', g = 'c', t = 'a', n = 'n'}\n    for i = #seq, 1, -1 do\n        local ch = seq:sub(i, i)\n        rev_seq[#rev_seq + 1] = complement[ch]\n    end\n    return table.concat(rev_seq)\nen","completion":""}
{"prompt":"-- automaticaly convert string to the int or float\nlocal function auto_converter(s)\n\tlocal n = tonumber(s)\n\tif n ~= nil then\n\t\treturn n\n\tend\n\treturn s\nen","completion":""}
{"prompt":"-- Args:\n-- value (int): A number from 0 to 25 that represents an\n-- ASCII alphabet character.\n-- Returns:\n-- string: Returns a python string representing the character\n-- of value mapped by [a, z] -> [0, 25]\nlocal function char_from_value(value)\n    return string.char(value + 97)\nen","completion":""}
{"prompt":"-- Converts a given string to lower case.\nlocal function to_lower(s)\n  return s:lower()\nen","completion":""}
{"prompt":"-- Return the longest common substring from the beginning of sa and sb.\nlocal function common_start(sa, sb)\n  local n = 0\n  for i = 1, #sa do\n    if i > #sb or sa:sub(i, i) ~= sb:sub(i, i) then\n      return sa:sub(1, n)\n    end\n    n = n + 1\n  end\n  return sa:sub(1, n)\nen","completion":""}
{"prompt":"-- A Linear model f=x -> alpha* x + df0. Returns the frequency domain half\n-- width half maximum (HWHM).\nlocal function gilbert_damping(x, alpha, df0)\n  return alpha * x + df0\nen","completion":""}
{"prompt":"-- using recursion\n-- :param n:\n-- :return:\nlocal function fib_recursion(n)\n  if n == 0 or n == 1 then\n    return n\n  end\n  return fib_recursion(n - 1) + fib_recursion(n - 2)\nen","completion":""}
{"prompt":"-- Extract ID from the end of the URI\n-- Args:\n-- id_or_uri: ID or URI of the OneView resources.\n-- Returns:\n-- str: The string founded after the last \"\/\"\nlocal function extract_id_from_uri(id_or_uri)\n\tlocal id = id_or_uri\n\tlocal last_slash = id_or_uri:find(\"\/[^\/]+$\")\n\tif last_slash then\n\t\tid = id_or_uri:sub(last_slash + 1)\n\tend\n\treturn id\nen","completion":""}
{"prompt":"-- >>> tell_pod_deploy_name('dummy-web-dev-7557696ddf-52cc6')\n-- 'dummy-web-dev'\n-- >>> tell_pod_deploy_name('dummy-web-7557696ddf-52cc6')\n-- 'dummy-web'\nlocal function tell_pod_deploy_name(s)\n\tlocal r = s:match('([a-zA-Z0-9%-]+)-[a-z0-9]+-[a-z0-9]+')\n\tif r then return r end\n\tr = s:match('([a-zA-Z0-9%-]+)-[a-z0-9]+')\n\tif r then return r end\n\treturn nil\nen","completion":""}
{"prompt":"-- Get the length of a (start, stop, step) range.\nlocal function get_len_of_range(start, stop, step)\n  return math.max(0, math.ceil((stop - start) \/ step))\nen","completion":""}
{"prompt":"-- Find the dot product of two 3-dimensional points\n-- Parameters\n-- coords1: coordinates of form [x,y,z]\n-- coords2: coordinates of form [x,y,z]\n-- Returns\n-- value:  Dot product coords2 and coords1 (float)\nlocal function dot(coords1, coords2)\n\treturn coords1[1] * coords2[1] + coords1[2] * coords2[2] + coords1[3] * coords2[3]\nen","completion":""}
{"prompt":"-- Get the dtypes specification that needs to be passed to read_csv.\nlocal function _read_csv_dtypes(table_meta)\n    local dtypes = {}\n    if table_meta.column_type_overrides then\n        for _, override in ipairs(table_meta.column_type_overrides) do\n            if override.dtype ~= nil then\n                dtypes[override.column] = override.dtype\n            end\n        end\n    end\n    return dtypes\nen","completion":""}
{"prompt":"-- Find the smallest positive number that is evenly divisible by all of the\n-- numbers from 1 to the provided limit.\n-- Seconds to execute 100 times when finding the LCM of 1 to 10: 0.187355995178.\nlocal function smallest_multiple(limit)\n  local i = 1\n  while true do\n    local divisible = true\n    for j = 1, limit do\n      if i % j ~= 0 then\n        divisible = false\n        break\n      end\n    end\n    if divisible then return i end\n    i = i + 1\n  end\nen","completion":""}
{"prompt":"-- Simple function that just removes empty strings from the lsit of subroutines\n-- :param list_of_subroutines: the list of subroutines and functions affected\n-- by adding gr into the decleration\n-- :return: a cleaner version of the list of subroutines without empty strings\nlocal function clean_list(list_of_subroutines)\n    local list = {}\n    for i = 1, #list_of_subroutines do\n        if string.len(list_of_subroutines[i]) > 0 then\n            list[#list+1] = list_of_subroutines[i]\n        end\n    end\n    return list\nen","completion":""}
{"prompt":"-- Assumes n an int > 0\n-- Returns n!\nlocal function fact_iter(n)\n\tlocal a = 1\n\tlocal function aux(n)\n\t\tif n == 0 then return a\n\t\telse a = a * n; return aux(n - 1) end\n\tend\n\treturn aux(n)\nen","completion":""}
{"prompt":"-- Reverses the given string and returns it\nlocal function reverse_string(word)\n    local word_reverse = \"\"\n    for i = #word, 1, -1 do\n        word_reverse = word_reverse .. word:sub(i, i)\n    end\n    return word_reverse\nen","completion":""}
{"prompt":"-- Mock a function that 'fails', i.e., returns a 1.\nlocal function mock_function_fail() return 1 en","completion":""}
{"prompt":"-- Returns the area of a trapezoid\nlocal function trapezoid_area(base_minor, base_major, height)\n    return 0.5 * (base_minor + base_major) * height\nen","completion":""}
{"prompt":"-- Count the number of leading spaces in a string.\nlocal function _indentation_level(string)\n  local indentation = 0\n  for i = 1, string:len() do\n    local char = string:sub(i, i)\n    if char == \" \" then\n      indentation = indentation + 1\n    else\n      break\n    end\n  end\n  return indentation\nen","completion":""}
{"prompt":"-- Checking for password format\n-- Format::: (min)-(max) (letter): password\nlocal function check(x)\n  local _, _, min, max, letter, password = string.find(x, \"(%d+)-(%d+) (%w): (%w+)\")\n  if not min or not max or not letter or not password then return nil end\n  min = tonumber(min)\n  max = tonumber(max)\n  letter = string.lower(letter)\n  local count = 0\n  for i = 1, #password do\n    if password:sub(i, i) == letter then count = count + 1 end\n  end\n  return count >= min and count <= max\nen","completion":""}
{"prompt":"-- Normalize a longitude into the range -180 to 180, not including 180.\n-- Args:\n-- longitude: A longitude in signed decimal degrees.\nlocal function normalizeLongitude(longitude)\n    while longitude >= 180 do\n        longitude = longitude - 360\n    end\n    while longitude < -180 do\n        longitude = longitude + 360\n    end\n    return longitude\nen","completion":""}
{"prompt":"-- replace '\/' to '_' to transfer url to file_path\n-- :param url: string\n-- :return:\nlocal function url2path(url)\n    return url:gsub('\/', '_')\nen","completion":""}
{"prompt":"-- Code due to Jack Wisdom.\n-- Compute Laplace coefficients and Leverrier derivatives\n-- j\n-- j   d     i\n-- a   ---   b (a)\n-- j    s\n-- da\n-- by series summation.\nlocal function laplace_wisdom(s, i, j, a)\n  if i == 0 then\n    return 0\n  end\n  if j == 0 then\n    return 0\n  end\n  if i > j then\n    return 0\n  end\n  if j == 1 then\n    return (a * s^i) \/ (1 - (a * s)^i)\n  end\n  return (a * laplace_wisdom(s, i, j - 1, a)) \/ (1 - (a * s)^i)\nen","completion":""}
{"prompt":"-- Uses built in math library to get square root\nlocal function builtin_sqrt(x)\n  return math.sqrt(x)\nen","completion":""}
{"prompt":"-- Map mp3 version float to a data structure index.\n-- 1 -> 0, 2 -> 1, 2.5 -> 2\nlocal function _mp3VersionKey(version)\n    if version >= 2.5 then\n        return 2\n    elseif version >= 2 then\n        return 1\n    else\n        return 0\n    end\nen","completion":""}
{"prompt":"-- Fibonacci Number Generator.\n-- This will give you the n'th number in the Fibonacci sequence\n-- Args:\n-- n: The number position in the Fibonacci sequence\n-- Returns:\n-- The n'th number of in the Fibonacci sequence\nlocal function fib(n)\n    if n <= 1 then\n        return n\n    end\n    local prev = 0\n    local curr = 1\n    for i=2,n do\n        local new = curr + prev\n        prev = curr\n        curr = new\n    end\n    return curr\nen","completion":""}
{"prompt":"-- retrieve the successor of p in list l\nlocal function _succ(p, l)\n    local pos = 0\n    for i, v in ipairs(l) do\n        if v == p then\n            pos = i\n            break\n        end\n    end\n    pos = pos + 1\n    if pos > #l then\n        pos = 1\n    end\n    return l[pos]\nen","completion":""}
{"prompt":"-- Taks a string and returns and integer. Yes, this is rather nonsensical\n-- but its a teaching moment to show you how to centralize common logic\n-- across submodules in a module.\nlocal function make_it_an_int(stringy_number)\n  local converted_value = tonumber(stringy_number)\n  if converted_value == nil then\n    return 0\n  else\n    return converted_value\n  end\nen","completion":""}
{"prompt":"-- Calculates a \"tableness\" score for a string by counting\n-- the number of edges (indices where a space is followed\n-- by a non-space or vice versa) that continue into the\n-- next line.\n-- This is a helper function for guess_tabwidth.\nlocal function tableness(text)\n\tlocal count = 0\n\tfor i = 1, #text do\n\t\tif text:sub(i, i) == \" \" then\n\t\t\tif i > 1 and text:sub(i - 1, i - 1) == \"\\n\" then\n\t\t\t\tcount = count + 1\n\t\t\tend\n\t\tend\n\tend\n\treturn count\nen","completion":""}
{"prompt":"-- Convert the given Home Assistant light level (0-255) to Lutron (0-100).\nlocal function to_lutron_level(level)\n  local level = math.floor((level \/ 255) * 100)\n  return level < 0 and 0 or (level > 100 and 100 or level)\nen","completion":""}
{"prompt":"-- List of types in sequence from ancestor to our type.\nlocal function convert_type_hierarchy(context, the_type, hierarchy)\n\tlocal result = {}\n\tlocal current = the_type\n\twhile current do\n\t\tif current.kind == \"record\" then\n\t\t\tif not hierarchy[current.name] then\n\t\t\t\thierarchy[current.name] = result\n\t\t\t\ttable.insert(result, current.name)\n\t\t\tend\n\t\telseif current.kind == \"type\" then\n\t\t\ttable.insert(result, current.name)\n\t\tend\n\t\tcurrent = current.parent\n\tend\n\treturn result\nen","completion":""}
{"prompt":"-- Returns the value that results from applying an expression to the last document in a group of documents that share the same group by key.\n-- Only meaningful when documents are in a defined order.\n-- See https:\/\/docs.mongodb.com\/manual\/reference\/operator\/aggregation\/last\/\n-- for more details\n-- :param expression: expression or variables\n-- :return: Aggregation operator\nlocal function LAST(expression)\n  return {['$last'] = expression}\nen","completion":""}
{"prompt":"-- convert sela to ela\n-- :param value: sela, 1 ela = 10^8 sela\n-- :return: a string representing the amount in ela\nlocal function SelaToEla(value)\n\treturn string.format(\"%.8f\", value \/ 100000000)\nen","completion":""}
{"prompt":"-- :param start:\n-- :param stop:\n-- :return: List of all the numbers between start and stop squared\nlocal function squared_numbers(start, stop)\n    local squared = {}\n    for n = start, stop do\n        table.insert(squared, n^2)\n    end\n    return squared\nen","completion":""}
{"prompt":"-- Should return a list of title cased names,\n-- each name appears only once\nlocal function dedup_and_title_case_names(names)\n\tlocal res = {}\n\tlocal seen = {}\n\tfor i, name in ipairs(names) do\n\t\tlocal t = name:sub(1, 1):upper() .. name:sub(2):lower()\n\t\tif not seen[t] then\n\t\t\tseen[t] = true\n\t\t\ttable.insert(res, t)\n\t\tend\n\tend\n\treturn res\nen","completion":""}
{"prompt":"-- Kelvin to Fahrenheit.\nlocal function k2f(k, r)\n\tif k then return math.floor(((k-273.15)*1.8)+32)\n\telse return \"N\/A\"\n\tend\nen","completion":""}
{"prompt":"-- Return a string formatted to 'camelCase'\nlocal function toCamel(name)\n    local newName = string.gsub(name, \"_\", \" \")\n    newName = string.lower(string.sub(newName, 1, 1)) .. string.sub(newName, 2)\n    return string.gsub(newName, \" \", \"\")\nen","completion":""}
{"prompt":"-- Returns the length (number of letters) in the current hand.\n-- hand: dictionary (string-> int)\n-- returns: integer\nlocal function calculateHandlen(hand)\n    local len = 0\n    for letter, _ in pairs(hand) do\n        len = len + 1\n    end\n    return len\nen","completion":""}
{"prompt":"-- Get List of none variation\n-- Examples\n-- --------\n-- >>> get_none_variation()\n-- [None, 'none', 'None', 'NONE', 'null', 'Null', 'NULL', 'na', 'Na', 'nA', 'NA', 'N.A', 'N.A.', 'nil', 'Nil', 'NIL']\n-- Returns\n-- -------\n-- variations : list\nlocal function get_none_variation()\n  return {None, 'none', 'None', 'NONE', 'null', 'Null', 'NULL', 'na', 'Na', 'nA', 'NA', 'N.A', 'N.A.', 'nil', 'Nil', 'NIL'}\nen","completion":""}
{"prompt":"-- Computes cross product between two vectors\nlocal function cross_product(a, b)\n    return {\n        a[2] * b[3] - a[3] * b[2],\n        a[3] * b[1] - a[1] * b[3],\n        a[1] * b[2] - a[2] * b[1],\n    }\nen","completion":""}
{"prompt":"-- dTanH(x) = 1 - TanH(x)^2\nlocal function dtanh(tanh_x)\n\treturn 1 - tanh_x * tanh_x\nen","completion":""}
{"prompt":"-- Shortening the note body for a one-line preview can chop two-byte unicode\n-- characters in half. This method fixes that.\nlocal function fixStringEnds(text)\n\tlocal last = string.byte(text, #text)\n\tif last == 226 then\n\t\treturn text:sub(1, #text - 1) .. \"\u2026\"\n\telse\n\t\treturn text\n\tend\nen","completion":""}
{"prompt":"-- Use @reduce decorator for converting a simple binary operation into a reduction kernel.\n-- :param a:\n-- :param b:\n-- :return:\nlocal function cuda_infinity_norm(a, b)\n  return math.max(math.abs(a), math.abs(b))\nen","completion":""}
{"prompt":"-- Get the first edge of the graph or an empty edge if there is non\n-- :param g: a graph as a dictionary\n-- :return: an edge as a dictionary\n-- >>> get_graph_first_edge({'edgeSet': [{'right':[4,5,6]}], 'entities': []}) == {'right':[4,5,6]}\n-- True\n-- >>> get_graph_first_edge({})\n-- {}\n-- >>> get_graph_first_edge({'edgeSet':[]})\n-- {}\n-- >>> get_graph_first_edge({'edgeSet': [{'right':[4,5,6]}, {'right':[8]}], 'entities': []}) == {'right':[4,5,6]}\n-- True\nlocal function get_graph_first_edge(g)\n  if g.edgeSet and #g.edgeSet > 0 then\n    return g.edgeSet[1]\n  else\n    return {}\n  end\nen","completion":""}
{"prompt":"-- Parse transport options.\n-- :param str optstring: Example input: 'scramblesuit:k=v;scramblesuit:k2=v2;obs3fs:k=v'\n-- :returns: {'obfs3': {'k':'v'}, 'scramblesuit': {'k2' : 'v2', 'k' : 'v'} }\nlocal function get_transport_options_impl(string)\n\tlocal ret = {}\n\tfor i in string:gmatch('[^;]+') do\n\t\tlocal name, value = i:match(\"^([^:]+):(.*)$\")\n\t\tif not name then\n\t\t\tname = i\n\t\t\tvalue = ''\n\t\tend\n\t\tif not ret[name] then\n\t\t\tret[name] = {}\n\t\tend\n\t\tfor j in value:gmatch('[^,]+') do\n\t\t\tlocal key, value = j:match(\"^([^=]+)=?(.*)$\")\n\t\t\tif not key then\n\t\t\t\tkey = j\n\t\t\t\tvalue = ''\n\t\t\tend\n\t\t\tret[name][key] = value\n\t\tend\n\tend\n\treturn ret\nen","completion":""}
{"prompt":"-- Parse all the unknown arguments from click for downstream tasks. Used in\n-- user plugins for custom command line arguments.\n-- Parameters\n-- ----------\n-- click_args : list\n-- Unknown arguments from click\n-- Returns\n-- -------\n-- parsed : dict\n-- Parsed arguments stored as key value pair\n-- Note\n-- -----\n-- Unknown arguments must be long arguments i.e should start with --\nlocal function parse_custom_arguments(click_args)\n    local parsed = {}\n    local i = 1\n    while i <= #click_args do\n        local arg = click_args[i]\n        if arg:sub(1, 2) == '--' then\n            local key = arg:sub(3)\n            local value\n            i = i + 1\n            if i <= #click_args then\n                value = click_args[i]\n            end\n            parsed[key] = value\n        end\n        i = i + 1\n    end\n    return parsed\nen","completion":""}
{"prompt":"-- translates an rgb tuple of int to a tkinter friendly color code\nlocal function rgb(r, g, b)\n\treturn \"#\" .. string.format(\"%02x%02x%02x\", r, g, b)\nen","completion":""}
{"prompt":"-- The same path can have multiple methods.\n-- For example: \/vcenter\/vm can have 'get', 'patch', 'put'\n-- Rearrange list into a map\/object which is the format expected by swagger-ui\n-- key is the path ie. \/vcenter\/vm\/\n-- value is a an object which contains key as method names and value as path objects\nlocal function convert_path_list_to_path_map(path_list)\n  local path_map = {}\n  for _, path in ipairs(path_list) do\n    if not path_map[path.path] then\n      path_map[path.path] = { [path.method] = path }\n    else\n      path_map[path.path][path.method] = path\n    end\n  end\n  return path_map\nen","completion":""}
{"prompt":"-- Order a list of letter paragraphs in the same order as a list of IDs.\nlocal function sort_letter_paragraphs(paragraphs, ids)\n  local sorted_paragraphs = {}\n  for _, id in ipairs(ids) do\n    for _, p in ipairs(paragraphs) do\n      if id == p.id then\n        table.insert(sorted_paragraphs, p)\n        break\n      end\n    end\n  end\n  return sorted_paragraphs\nen","completion":""}
{"prompt":"-- Clamps a number between two numbers\n-- Args:\n-- x: the number to clamp\n-- low: the minimum value the number can have\n-- high: the maximum value the number can have\n-- Returns:\n-- the value of x clamped between low and high\nlocal function clamp(x, low, high)\n  return math.max(low, math.min(x, high))\nen","completion":""}
{"prompt":"-- Convert base 10 or base 16 string to int.\nlocal function to_int(value)\n\treturn math.floor(tonumber(value))\nen","completion":""}
{"prompt":"-- Converts the raw R\/G\/B values to luminosity in lux.\nlocal function calculate_lux(r, g, b)\n    local luminance = (0.299 * r + 0.587 * g + 0.114 * b)\n    if luminance < 1.0 then\n        return 0.0\n    else\n        return (luminance ^ 2.4)\n    end\nen","completion":""}
{"prompt":"-- linear interpolation\nlocal function lerp(a, b, w)\n\treturn a + (b - a) * w\nen","completion":""}
{"prompt":"-- Convert time expressed in (float) minutes into (float) seconds.\n-- :param float time_minutes: Time expressed in minutes.\n-- :return: Time expressed in seconds.\n-- :rtype: float\nlocal function convert_time(time_minutes)\n  return time_minutes * 60.0\nen","completion":""}
{"prompt":"-- Convert string to int or float\n-- Args:\n-- s (str): string to be converted to numeric\n-- Returns:\n-- int or float\nlocal function to_numeric(s)\n    local n = tonumber(s)\n    if n == nil then\n        return s\n    end\n    return n\nen","completion":""}
{"prompt":"-- Compute the width for a right-handed neutrino to decay into an active\n-- neutrino and two neutral pion. (NOTE: The amplitude for this process is\n-- order G_F^4. For consistancy of the EFT, we must ignore this process.)\n-- Returns\n-- -------\n-- width: float\n-- Partial decay with for N -> nu + pi0 + pi0.\nlocal function width_nu_pi0_pi0(_)\n  local width = 0\n  return width\nen","completion":""}
{"prompt":"-- An optimized dynamic programming solution to find a single number of the\n-- Fibonacci sequence. It runs in O(n) time with O(1) space complexity.\nlocal function fib_dp(n)\n  if n < 2 then return n end\n  local prev = 0\n  local curr = 1\n  for i = 1, n - 1 do\n    local new_curr = curr + prev\n    prev = curr\n    curr = new_curr\n  end\n  return curr\nen","completion":""}
{"prompt":"-- get harmonic mean value\nlocal function harmonic_mean(score1, score2)\n\treturn 2 \/ (1 \/ score1 + 1 \/ score2)\nen","completion":""}
{"prompt":"-- Extract all letters from a string and make them uppercase\nlocal function formatstr(text)\n\treturn string.upper(text:gsub(\"[^A-Za-z]\", \"\"))\nen","completion":""}
{"prompt":"-- Escape &, <, and > in a string of data.\n-- You can escape other strings of data by passing a dictionary as\n-- the optional entities parameter.  The keys and values must all be\n-- strings; each key will be replaced with its corresponding value.\nlocal function escape(data, entities)\n   local buffer = {}\n   for i = 1, #data do\n      local char = string.sub(data, i, i)\n      if char == '&' then\n         table.insert(buffer, '&amp;')\n      elseif char == '<' then\n         table.insert(buffer, '&lt;')\n      elseif char == '>' then\n         table.insert(buffer, '&gt;')\n      else\n         if entities and entities[char] then\n            table.insert(buffer, entities[char])\n         else\n            table.insert(buffer, char)\n         end\n      end\n   end\n   return table.concat(buffer)\nen","completion":""}
{"prompt":"-- Remove all indentation from the input string\n-- :param s: Input string\n-- :type s: ```AnyStr```\n-- :returns: Deindented string\n-- :rtype: ```AnyStr```\nlocal function deindent(s)\n    if not s then return '' end\n    local lines = {}\n    local indentation = 999999\n    local min_indentation = 999999\n    for line in s:gmatch(\"[^\\n]+\") do\n        local i = line:match(\"^%s+\")\n        if i then\n            i = #i\n            if min_indentation > i then\n                min_indentation = i\n            end\n        end\n        table.insert(lines, line)\n    end\n    for i,line in ipairs(lines) do\n        if line:find(\"^%s+\") then\n            lines[i] = line:gsub(\"^%s+\", \"\")\n        end\n    end\n    return table.concat(lines, \"\\n\")\nen","completion":""}
{"prompt":"-- A safe string to integer function that returns a default if it fails.\nlocal function to_int_safe(s, default)\n    local n = tonumber(s)\n    if n ~= nil and math.floor(n) == n then\n        return n\n    else\n        return default\n    end\nen","completion":""}
{"prompt":"-- The center of the sphere can be given as an Atom, or directly as\n-- a list of three floats (x,y,z). If it's an Atom, find it and return\n-- the xyz coords. If not, just turn the list into a tuple.\n-- Parameters\n-- ----------\n-- origin : 3-item list of coordinates, or chimera.Atom\n-- genes : gaudi.parse.Settings.genes\n-- List of gene-dicts to look for molecules that may contain\n-- the referred atom in `origin`\n-- Returns\n-- -------\n-- Tuple of float\n-- The x,y,z coordinates\nlocal function parse_origin(origin, individual)\n  if type(origin) == 'table' and type(origin[1]) == 'number' then\n    return origin\n  end\n  local gene = individual.genes:get_gene('Molecule', origin)\n  if not gene then\n    return nil\n  end\n  local mol = gene.value\n  local atom = mol:find_atom(origin)\n  if not atom then\n    return nil\n  end\n  return atom:getCoords()\nen","completion":""}
{"prompt":"-- Wrap argument values with string\n-- Args:\n-- args: list like [\"--foo=3\", \"--bar=False\"]\n-- Returns:\n-- list of string: like [\"--foo='3'\", \"--bar='False'\"]\nlocal function wrap_go_args_with_string(args)\n    if args then\n        local rargs = {}\n        for _,v in ipairs(args) do\n            if string.find(v, \"=\") ~= nil then\n                local key, val = string.match(v, \"(.+)=([^=]*)\")\n                rargs[#rargs+1] = key .. \"='\" .. val .. \"'\"\n            else\n                rargs[#rargs+1] = v\n            end\n        end\n        return rargs\n    else\n        return {}\n    end\nen","completion":""}
{"prompt":"-- Escape lua regex.\nlocal function regex_escape(raw)\n  return (raw:gsub(\"([%(%)%.%+%-%*%?%[%]%^%$%%])\", \"%%%1\"))\nen","completion":""}
{"prompt":"-- Return the value of a number's bit position.\n-- >>> [bit_on(42, i) for i in range(clog2(42))]\n-- [0, 1, 0, 1, 0, 1]\nlocal function bit_on(num, bit)\n\treturn num & (1 << bit) > 0 and 1 or 0\nen","completion":""}
{"prompt":"-- Convert an integer into its ordinal representation.\nlocal function ordinal(n)\n    local s = string.format('%d', n)\n    if n%100==11 or n%100==12 or n%100==13 then\n        return s..'th'\n    else\n        local rem = n%10\n        if rem==1 then\n            return s..'st'\n        elseif rem==2 then\n            return s..'nd'\n        elseif rem==3 then\n            return s..'rd'\n        else\n            return s..'th'\n        end\n    end\nen","completion":""}
{"prompt":"-- \nlocal function intcomma(number, locale)\n\tlocal formatted = tostring(number)\n\tif locale == 'de' then\n\t\tformatted = formatted:gsub('.', ',')\n\tend\n\treturn formatted\nen","completion":""}
{"prompt":"-- Gets the range of a map.\nlocal function map_range(value, leftMin, leftMax, rightMin, rightMax)\n    return rightMin + (value - leftMin) * (rightMax - rightMin) \/ (leftMax - leftMin)\nen","completion":""}
{"prompt":"-- Collatz conjecture: start with any positive integer n.Next term is obtained from the previous term as follows:\n-- if the previous term is even, the next term is one half of the previous term.\n-- If the previous term is odd, the next term is 3 times the previous term plus 1.\n-- The conjecture states the sequence will always reach 1 regaardless of starting value n.\n-- Example:\n-- >>> collatz_sequence(43)\n-- [43, 130, 65, 196, 98, 49, 148, 74, 37, 112, 56, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]\nlocal function collatz_sequence(n)\n    local sequence = {n}\n    local limit = 0\n    while n ~= 1 and limit < 20000 do\n        limit = limit + 1\n        if n % 2 == 0 then\n            n = n \/ 2\n        else\n            n = 3 * n + 1\n        end\n        sequence[#sequence + 1] = n\n    end\n    return sequence\nen","completion":""}
{"prompt":"-- *declination_sexegesimal_to_decimal*\n-- **Key Arguments:**\n-- - ``dec`` -- declination in sexegesimal\n-- **Return:**\n-- - ``decimalDegrees``\n-- .. todo::\n-- @review: when complete, clean worker function and add comments\n-- @review: when complete add logging\nlocal function declination_sexegesimal_to_decimal(dec)\n  --============================================================================--\n  --== Parse Input\n  --============================================================================--\n  dec = assert(dec)\n  assert(type(dec) == \"string\", \"Argument is not a string\")\n  --============================================================================--\n  --== Declare Variables\n  --============================================================================--\n  local decimal_degrees\n  local sign\n  --============================================================================--\n  --== Parse Degrees, Minutes, Seconds\n  --============================================================================--\n  local minutes, seconds\n  for match in string.gmatch(dec, \"(%d+)\") do\n    if not decimal_degrees then\n      --== If first number is found, then this is the degrees.\n      decimal_degrees = tonumber(match)\n    elseif not minutes then\n      --== If the second number is found, then this is the minutes.\n      minutes = tonumber(match)\n    else\n      --== The third number is the seconds.\n      seconds = tonumber(match)\n    end\n  end\n  --============================================================================--\n  --== Parse Sign\n  --============================================================================--\n  if string.match(dec, \"[+-]\") then\n    sign = string.match(dec, \"[+-]\")\n  end\n  --============================================================================--\n  --== Convert Degrees, Minutes, Seconds\n  --============================================================================--\n  decimal_degrees = decimal_degrees + minutes\/60 + seconds\/3600\n  if sign and sign == '-' then\n    decimal_degrees = -1 * decimal_degrees\n  end\n  --============================================================================--\n  --== Return Result\n  --============================================================================--\n  return decimal_degrees\nen","completion":""}
{"prompt":"-- This makes sure the given value is an array.\nlocal function make_me_iterable(a)\n  return type(a) == 'table' and a or { a }\nen","completion":""}
{"prompt":"-- Parse price.\nlocal function parse_price(price)\n  if not price then return nil end\n  local number = string.match(price, \"^[0-9%.]+\")\n  if number then\n    return tonumber(number)\n  end\n  return nil\nen","completion":""}
{"prompt":"-- Takes a string and removes 'amp '\nlocal function remove_amp(tweet)\n  local new_tweet = tweet\n  if string.find(tweet, 'amp ') ~= nil then\n    new_tweet = string.gsub(tweet, '&amp;', '&')\n    new_tweet = string.gsub(new_tweet, 'amp%s', '')\n  end\n  return new_tweet\nen","completion":""}
{"prompt":"-- Return True if a DICOM dataset should be filtered out, else False\nlocal function filter_dicom(dcmdata)\n  return false\nen","completion":""}
{"prompt":"-- Returns number of 1s in binary expansion of the number\nlocal function binary_1(number)\n  local count = 0\n  while number ~= 0 do\n    if number % 2 ~= 0 then count = count + 1 end\n    number = math.floor(number \/ 2)\n  end\n  return count\nen","completion":""}
{"prompt":"-- Get i-th number from Fibonacci Series.\n-- | 1 if i = 0\n-- F(i) = { 2 if i = 1\n-- | F(i - 1) + F(i - 2) if i >= 2\nlocal function fibonacci(i)\n\tif i == 0 then\n\t\treturn 1\n\telseif i == 1 then\n\t\treturn 2\n\telse\n\t\treturn fibonacci(i - 1) + fibonacci(i - 2)\n\tend\nen","completion":""}
{"prompt":"-- Sin axis of circle\nlocal function circle_sin(d, params)\n\tlocal r = params.r or 1\n\treturn r * math.sin(d)\nen","completion":""}
{"prompt":"-- Convert the region name to something that we can use for comparison\n-- without running into encoding issues.\nlocal function _clean_region(region)\n  region = region:lower():gsub(\"%W\", \"\")\n  if region == \"us-east-1\" then\n    return \"us-east\"\n  end\n  return region\nen","completion":""}
{"prompt":"-- Returns the area of a triangle\nlocal function triangle_area(base, height)\n    return (base * height) \/ 2\nen","completion":""}
{"prompt":"-- Given variables like ``['a=b', 'c=d']`` turns it into ``{'a':\n-- 'b', 'c': 'd'}``\nlocal function parse_vars(args)\n\tlocal vars = {}\n\tfor i = 1, #args do\n\t\tlocal k, v = args[i]:match(\"^([a-zA-Z0-9_]+)=(.*)$\")\n\t\tif not k then\n\t\t\terror(\"Invalid argument \" .. args[i] .. \" should be of the form 'var=value'\")\n\t\tend\n\t\tvars[k] = v\n\tend\n\treturn vars\nen","completion":""}
{"prompt":"-- Get the extension of a file\nlocal function detectFormat(fileName)\n\treturn (string.match(fileName, \"%.([^.]+)$\") or \"\"):lower()\nen","completion":""}
{"prompt":"-- Do a VB LSet\n-- Left aligns a string within a string variable, or copies a variable of one \n-- user-defined type to another variable of a different user-defined type.\n-- LSet stringvar = string\n-- LSet replaces any leftover characters in stringvar with spaces.\n-- If string is longer than stringvar, LSet places only the leftmost characters, \n-- up to the length of the stringvar, in stringvar.\n-- Warning   Using LSet to copy a variable of one user-defined type into a \n-- variable of a different user-defined type is not recommended. Copying data \n-- of one data type into space reserved for a different data type can cause unpredictable results.\n-- When you copy a variable from one user-defined type to another, the binary data \n-- from one variable is copied into the memory space of the other, without regard \n-- for the data types specified for the elements.\nlocal function LSet(var, value)\n    return string.sub(value .. string.rep(\" \", string.len(var)), 1, string.len(var))\nen","completion":""}
{"prompt":"-- Find nth fibonacci number using recursive algorithm.\n-- input: n (int) n for nth fibonacci number\n-- returns: (int) representing value of nth fib number\nlocal function fibonacci(n)\n    if n == 0 or n == 1 then\n        return n\n    end\n    return fibonacci(n - 1) + fibonacci(n - 2)\nen","completion":""}
{"prompt":"-- Limit n to be between min_val and max_val\nlocal function minmax(n, min_val, max_val)\n    return math.max(min_val, math.min(n, max_val))\nen","completion":""}
{"prompt":"-- If s is not a list, return [s].\nlocal function toList(s)\n    if type(s) == \"table\" then\n        return s\n    else\n        return {s}\n    end\nen","completion":""}
{"prompt":"-- Either have m as scalar, so bound(x,m,M) which returns m <= x <= M *OR*\n-- have m as length 2 vector, bound(x,m, <IGNORED>) returns m[0] <= x <= m[1].\n-- Args:\n-- x: scalar\n-- Returns:\n-- x: scalar, bound between min (m) and Max (M)\nlocal function bound(x, m, M)\n\tif type(m) == 'number' and type(M) == 'number' then\n\t\treturn math.min(math.max(m, x), M)\n\telseif type(m) == 'table' then\n\t\treturn math.min(math.max(m[1], x), m[2])\n\tend\n\treturn x\nen","completion":""}
{"prompt":"-- Turns a string into a list of utf8 encoded bytes.\nlocal function str_to_int_list(message)\n  local int_list = {}\n  for c in message:gmatch(\".\") do\n    int_list[#int_list + 1] = string.byte(c)\n  end\n  return int_list\nen","completion":""}
{"prompt":"-- Climatology check with standard deviation-based limits but with a minimum width\n-- :param inval: value to be compared to climatology\n-- :param inclimav: the climatological average to which it will be compared\n-- :param instdev: the standard deviation which will be used to test the anomaly\n-- :param limit: maximum standardised anomaly\n-- :param lowbar: the anomaly must be greater than lowbar to fail regardless of standard deviation\n-- :return: return 1 if the difference is outside the specified range, 0 otherwise.\nlocal function climatology_plus_stdev_with_lowbar(inval, inclimav, instdev, limit, lowbar)\n    local diff = inval - inclimav\n    if diff > lowbar and diff > limit * instdev then return 1 end\n    if diff < -lowbar and diff < -limit * instdev then return 1 end\n    return 0\nen","completion":""}
{"prompt":"-- Given a list of coordinates, invert the z coordinates. This is used when\n-- converting particle coordinates from the raw tiltseries to the final reconstruction's\n-- coordinate system for simulated data.\n-- Args:\n-- positions: A list of [x, y, z] coordinates\n-- Returns: A list of [x, y, z] coordinates\nlocal function invert_z_coordinates(positions)\n\tlocal new_positions = {}\n\tfor i = 1, #positions do\n\t\tnew_positions[i] = {positions[i][1], positions[i][2], -positions[i][3]}\n\tend\n\treturn new_positions\nen","completion":""}
{"prompt":"-- Parses an SVG style attribute string, returning it as a key\/value\n-- dictionary.\nlocal function get_style_dict(style)\n    local dict = {}\n    for pair in style:gmatch(\"([^;]+)\") do\n        local k, v = pair:match(\"^%s*(.-)%s*:%s*(.-)%s*$\")\n        k = k and k:gsub(\"^%s*(.-)%s*$\", \"%1\")\n        v = v and v:gsub(\"^%s*(.-)%s*$\", \"%1\")\n        dict[k] = v\n    end\n    return dict\nen","completion":""}
{"prompt":"-- Series - 1, 1, 2, 3, 5, 8, 13\n-- `n` starts from 1.\n-- :param n:\n-- :return:\nlocal function fib_itr(n)\n    if n < 3 then\n        return 1\n    else\n        local prev2 = 1\n        local prev1 = 1\n        local prev = 1\n        for i = 3, n do\n            prev = prev1 + prev2\n            prev2 = prev1\n            prev1 = prev\n        end\n        return prev\n    end\nen","completion":""}
{"prompt":"-- Turn an LSB byte to an MSB byte, and vice versa. Used for SPI as\n-- it is LSB for the PN532, but 99% of SPI implementations are MSB only!\nlocal function reverse_bit(num)\n    local reversed = 0\n    for i = 0, 7 do\n        reversed = reversed * 2 + num % 2\n        num = math.floor(num \/ 2)\n    end\n    return reversed\nen","completion":""}
{"prompt":"-- Method fixes Windows path\n-- Args:\n-- none\n-- Returns:\n-- str\nlocal function fix_path(path)\n\treturn string.gsub(path, \"\\\\\", \"\/\")\nen","completion":""}
{"prompt":"-- Get input_width and input_height of the model.\nlocal function get_input_wh(model_name)\n  local input_width, input_height\n  if model_name == 'resnet50_v1' then\n    input_width, input_height = 224, 224\n  elseif model_name == 'resnet101_v1' then\n    input_width, input_height = 224, 224\n  elseif model_name == 'resnet50_v2' then\n    input_width, input_height = 299, 299\n  elseif model_name == 'resnet101_v2' then\n    input_width, input_height = 299, 299\n  else\n    print('Invalid model_name')\n    os.exit()\n  end\n  return input_width, input_height\nen","completion":""}
{"prompt":"-- Calculate targets used to update policy and value functions.\nlocal function bootstrapped_values(terminal_value, rewards, gamma)\n  -- Calculate the target value as the discounted sum of rewards plus the\n  -- discounted bootstrap value.\n  local values = {}\n  local n = #rewards\n  for i = n, 1, -1 do\n    local reward = rewards[i]\n    values[i] = reward + gamma * terminal_value\n    terminal_value = values[i]\n  end\n  return values\nen","completion":""}
{"prompt":"-- Replace brackets with parenthesis because it breaks the UI\nlocal function _replace_brackets(s)\n  return s:gsub(\"%[\", \"(\"):gsub(\"%]\", \")\")\nen","completion":""}
{"prompt":"-- Returns the max subarray of the given list of numbers.\n-- Returns 0 if  nums is None or an empty list.\n-- Time Complexity: O(n)\n-- Space Complexity: O(n)\nlocal function max_sub_array(nums)\n    if nums == nil or #nums == 0 then return 0 end\n    local max_sum = nums[1]\n    local temp_sum = max_sum\n    for i = 2, #nums do\n        temp_sum = math.max(nums[i], temp_sum + nums[i])\n        max_sum = math.max(temp_sum, max_sum)\n    end\n    return max_sum\nen","completion":""}
{"prompt":"-- Extract the cookies to a format that the request library understands\n-- :param cookies: This should be a driver cookie. Obtained with the command my_driver.get_cookies()\n-- :type cookies: dict\n-- :return: Cookies dictionary suitable for a requests lib object\n-- :rtype: dict\nlocal function transfer_driver_cookies_to_request(cookies)\n    if cookies then\n        local new_cookies = {}\n        for _, cookie in ipairs(cookies) do\n            new_cookies[cookie.name] = cookie.value\n        end\n        return new_cookies\n    end\n    return nil\nen","completion":""}
{"prompt":"-- Calculate slope between two points\nlocal function calcSlope(y1, y2, x1, x2)\n\tif x1 == x2 then return 0 end\n\treturn (y1 - y2) \/ (x1 - x2)\nen","completion":""}
{"prompt":"-- floats a value\nlocal function parse_float(svalue)\n\treturn tonumber(svalue) or 0\nen","completion":""}
{"prompt":"-- 4 vector ``a`` times scalar ``c``\nlocal function scale4(a, c)\n\treturn {a[1] * c, a[2] * c, a[3] * c, a[4] * c}\nen","completion":""}
{"prompt":"-- Create a early warning message.\n-- :param hours: Hours until the deadline.\n-- :type hours: int\n-- :param minutes: Minutes until the deadline.\n-- :type minutes: int\n-- :param assignment_name: Name of the assignment that approaches its deadline.\n-- :type assignment_name: str\n-- :return: An early warning message.\n-- :rtype: str\nlocal function prep_early_warning(hours, minutes, assignment_name)\n  local msg = \"The deadline for \" .. assignment_name .. \" is in \"\n  local msg = msg .. hours .. \" hours and \" .. minutes .. \" minutes.\"\n  return msg\nen","completion":""}
{"prompt":"-- convert floats like 1.0, 100.0, etc. to int, if possible\nlocal function intfloat2int(x)\n    if type(x) == \"number\" then\n        local int = math.floor(x)\n        if int == x then return int end\n    end\n    return x\nen","completion":""}
{"prompt":"-- Convert engine position format to conventional format.\n-- position can be an integer from 0 to 63. For example 0 is converted to \"a1\".\nlocal function convert_position_to_conventional_format(position)\n    local row = math.floor(position \/ 8) + 1\n    local column = position % 8 + 1\n    return string.format(\"%s%d\", string.char(96 + column), row)\nen","completion":""}
{"prompt":"-- Return an echo function that receive the given positional arguments\n-- and execute echo_fn with a message constructed like bellow:\n-- >>> fn = echo_fn('fn', 'x', 'y')\n-- >>> fn(1, 2)\n-- fn(x=1, y=2)\nlocal function echo_fn(name)\n\treturn function(...)\n\t\tlocal args = {...}\n\t\tlocal params = {}\n\t\tfor i = 1, #args do\n\t\t\tlocal arg = args[i]\n\t\t\tif i == 1 then\n\t\t\t\tparams[i] = arg\n\t\t\telse\n\t\t\t\tparams[i] = string.format('%s=%s', arg, args[i])\n\t\t\tend\n\t\tend\n\t\tprint(string.format('%s(%s)', name, table.concat(params, \", \")))\n\tend\nen","completion":""}
{"prompt":"-- Pipe to validate the marks' entries for every student.\n-- Checks happening here:\n-- 1. If marks for a particular subject exceed the maximum possible marks\nlocal function marks_validator_pipe(data, config)\n  return data, config\nen","completion":""}
{"prompt":"-- Return n-th number in the Fibonacci Sequence.\nlocal function nth_fib(num)\n    if num <= 1 then\n        return num\n    else\n        return nth_fib(num - 1) + nth_fib(num - 2)\n    end\nen","completion":""}
{"prompt":"-- Count the number of word appearence in the tokenized sentences\n-- Args:\n-- tokenized_sentences: List of lists of strings\n-- Returns:\n-- dict that maps word (str) to the frequency (int)\nlocal function count_words(tokenized_sentences)\n  local word_count = {}\n  for i = 1, #tokenized_sentences do\n    for j = 1, #tokenized_sentences[i] do\n      local word = tokenized_sentences[i][j]\n      if word_count[word] == nil then\n        word_count[word] = 1\n      else\n        word_count[word] = word_count[word] + 1\n      end\n    end\n  end\n  return word_count\nen","completion":""}
{"prompt":"-- Clear and normalise text\n-- Includes case lowering and strip (right & left) for whitespace.\n-- Also replace comma with dots to ease the search of float number\n-- Args:\n-- input_text_lines [(str)]: lines of text to be cleaned\n-- Returns:\n-- cleaned_text_lines [(str)]: text has been cleaned\nlocal function clean_normalise_text_lines(input_text_lines)\n    local cleaned_text_lines = {}\n    for _, v in pairs(input_text_lines) do\n        local cleaned_text = string.lower(string.gsub(string.gsub(v, \"^%s*(.-)%s*$\", \"%1\"), \",\", \".\"))\n        if cleaned_text ~= '' then\n            cleaned_text_lines[#cleaned_text_lines + 1] = cleaned_text\n        end\n    end\n    return cleaned_text_lines\nen","completion":""}
{"prompt":"-- The roll function\n-- Lifted from https:\/\/www.johndcook.com\/blog\/2019\/03\/03\/do-the-chacha\/\nlocal function roll(x, n)\n    return ((x << n) | (x >> (32 - n))) & 0xFFFFFFFF\nen","completion":""}
{"prompt":"-- Find the full periods.\nlocal function _find_full_periods(events, quantity, capacity)\n\tlocal periods = {}\n\tlocal start_index = 1\n\tfor i = 1, #events, 1 do\n\t\tlocal event = events[i]\n\t\tif event.type == 'start' then\n\t\t\tif i - start_index + 1 > quantity then\n\t\t\t\tlocal period = _get_period(events, start_index, i, quantity, capacity)\n\t\t\t\ttable.insert(periods, period)\n\t\t\t\tstart_index = i\n\t\t\tend\n\t\tend\n\tend\n\tif #events - start_index + 1 >= quantity then\n\t\tlocal period = _get_period(events, start_index, #events, quantity, capacity)\n\t\ttable.insert(periods, period)\n\tend\n\treturn periods\nen","completion":""}
{"prompt":"-- gc_content - a number representing the GC content\n-- Returns a string representing GC Classification. Must return one of\n-- these: \"low\", \"moderate\", or \"high\"\nlocal function classify(gc_content)\n  if (gc_content < 0.4) then\n    return \"low\"\n  elseif (gc_content >= 0.4 and gc_content <= 0.6) then\n    return \"moderate\"\n  else\n    return \"high\"\n  end\nen","completion":""}
{"prompt":"-- Returns all of the odd or\n-- even numbers from a list\nlocal function odds_or_evens(my_bool, nums)\n\tlocal new_list = {}\n\tfor _, n in pairs(nums) do\n\t\tif my_bool then\n\t\t\tif n % 2 == 0 then\n\t\t\t\ttable.insert(new_list, n)\n\t\t\tend\n\t\telse\n\t\t\tif n % 2 ~= 0 then\n\t\t\t\ttable.insert(new_list, n)\n\t\t\tend\n\t\tend\n\tend\n\treturn new_list\nen","completion":""}
{"prompt":"-- Return an array of length n of random bits {0, 1} where Probability(0) = p and Probability(1) = 1 - p\n-- this is used for randomly selecting some of the tokens for vertical placement.\nlocal function randomFlips(n, p)\n    local bits = {}\n    for i = 1, n do\n        bits[i] = math.random() < p and 1 or 0\n    end\n    return bits\nen","completion":""}
{"prompt":"-- Return merged range.\nlocal function marge_ranges(range_1, range_2)\n\treturn {\n\t\tmath.min(range_1[1], range_2[1]),\n\t\tmath.max(range_1[2], range_2[2]),\n\t}\nen","completion":""}
{"prompt":"-- Return geotype based on population density\n-- Params:\n-- ======\n-- geotype_lookup : list of (population_density_upper_bound, geotype) tuples\n-- sorted by population_density_upper_bound ascending\nlocal function lookup_clutter_geotype(geotype_lookup, population_density)\n  local clutter_geotype = \"\"\n  local population_density_upper_bound = -1\n  for i = 1, #geotype_lookup do\n    local current_geotype = geotype_lookup[i][2]\n    if population_density > geotype_lookup[i][1] and\n       population_density_upper_bound < geotype_lookup[i][1]\n    then\n      clutter_geotype = current_geotype\n      population_density_upper_bound = geotype_lookup[i][1]\n    end\n  end\n  return clutter_geotype\nen","completion":""}
{"prompt":"-- Compute a simple sum over all index-wise contributions\nlocal function assembleValue(hierarchy, indexEstimations)\n\tlocal value = 0\n\tfor _, estimations in ipairs(indexEstimations) do\n\t\tfor _, estimation in ipairs(estimations) do\n\t\t\tvalue = value + estimation\n\t\tend\n\tend\n\treturn value\nen","completion":""}
{"prompt":"-- Counts no of whitespace in string and returns an int.\nlocal function count_str_whitespace(mystr)\n    local count = 0\n    for i=1, #mystr do\n        if string.match(mystr:sub(i,i),\"%s\") then\n            count = count + 1\n        end\n    end\n    return count\nen","completion":""}
{"prompt":"-- Replace linebreaks and indenting with single space\nlocal function linebreak_fix(text)\n  text = text:gsub(\"\\r\", \"\")\n  text = text:gsub(\"\\n\", \" \")\n  text = text:gsub(\"\\t\", \" \")\n  text = text:gsub(\" +\", \" \")\n  text = text:gsub(\"^ \", \"\")\n  text = text:gsub(\" $\", \"\")\n  return text\nen","completion":""}
{"prompt":"-- Convert similarity to edge label.\n-- Parameters\n-- ----------\n-- similarity : float\n-- Similarity between two answers.\n-- Returns\n-- -------\n-- str\n-- Label of the edge. Similarity in percentage i.e 90%.\nlocal function sim_to_label(similarity)\n  local sim_label = \"\"\n  if similarity == nil then\n    sim_label = \"0%\"\n  else\n    local label = 100 * similarity\n    if label > 100 then\n      sim_label = \"100%\"\n    elseif label < 0 then\n      sim_label = \"0%\"\n    else\n      sim_label = string.format(\"%.0f%%\", label)\n    end\n  end\n  return sim_label\nen","completion":""}
{"prompt":"-- Convert dissolved oxygen from units of micromol\/kg to mL\/L.\n-- Parameters\n-- ----------\n-- oxy_umol_kg : array-like\n-- Dissolved oxygen in units of [umol\/kg]\n-- sigma0 : array-like\n-- Potential density anomaly (i.e. sigma - 1000) referenced to 0 dbar [kg\/m^3]\n-- Returns\n-- -------\n-- oxy_mL_L : array-like\n-- Dissolved oxygen in units of [mL\/L]\n-- Notes\n-- -----\n-- Conversion value 44660 is exact for oxygen gas and derived from the ideal gas law.\n-- (c.f. Sea-Bird Application Note 64, pg. 6)\nlocal function oxy_umolkg_to_ml(oxy_umol_kg, sigma0)\n   local oxy_mL_L = oxy_umol_kg * 44660 * sigma0\n   return oxy_mL_L\nen","completion":""}
{"prompt":"-- Assume n is an int >= 0\nlocal function foo_two(n)\n  if n == 0 then\n    return 1\n  else\n    return n * foo_two(n - 1)\n  end\nen","completion":""}
{"prompt":"-- Converts a delimited string into a list, stripping whitespace \n-- from both ends of each item.  Does not return any zero-length strings.\n-- 'delim' is the delimiter.\nlocal function split_strip(s, delim)\n\tdelim = delim or \",\"\n\tlocal t = {}\n\tfor k in string.gmatch(s, \"[^\"..delim..\"]+\") do\n\t\tk = string.gsub(k, \"%s+$\", \"\")\n\t\tk = string.gsub(k, \"^%s+\", \"\")\n\t\tif k ~= \"\" then\n\t\t\ttable.insert(t, k)\n\t\tend\n\tend\n\treturn t\nen","completion":""}
{"prompt":"-- Parse a pretty-printed version of an int into an int.\nlocal function pretty2int(string)\n    local result, err = 0\n    for c in string:gmatch('%d') do\n        result = result * 10 + tonumber(c)\n    end\n    return result, err\nen","completion":""}
{"prompt":"-- check if row & col values are within the 2D array\nlocal function outOfBounds(row, col, height, width)\n\treturn row < 0 or col < 0 or row >= height or col >= width\nen","completion":""}
{"prompt":"-- :param cidr:\n-- :return:\nlocal function cidr_to_netmask(cidr)\n  local mask = 0xffffffff - (math.pow(2, 32 - cidr) - 1)\n  return string.format(\"%d.%d.%d.%d\", (mask & 0xff000000) >> 24, (mask & 0xff0000) >> 16, (mask & 0xff00) >> 8, mask & 0xff)\nen","completion":""}
{"prompt":"-- You're given an array of strings,\n-- your task is to return an array of all palindromes of even length\n-- in the same order of appearance.\n-- Consider the empty string as not palindrome.\n-- Examples:\n-- * detect_even_palindrome([\"AabcbaA\", \"abccdA\", \"1221\"]) => [\"1221\"]\n-- * detect_even_palindrome([\"rebber\", \"madam\"]) => [\"rebber\"]\n-- * detect_even_palindrome([\"\", \"124\", \"a\"]) => []\n-- * detect_even_palindrome([]) => []\nlocal function detect_even_palindrome(arr)\n  local result = {}\n  for _, str in ipairs(arr) do\n    if #str > 0 and #str % 2 == 0 and str == str:reverse() then\n      result[#result + 1] = str\n    end\n  end\n  return result\nen","completion":""}
{"prompt":"-- Tidy up a string to make it suitable for a color name in a palette\n-- This replaces whitespace with underscores, and lowers the text\n-- Args:\n-- word (str): Color name to tidy up\n-- Returns:\n-- str: Tidied color name\nlocal function tidy_color_name(word)\n    word = word:gsub(\" \", \"_\")\n    word = word:gsub(\"%W\", \"\")\n    return word:lower()\nen","completion":""}
{"prompt":"-- Make a summary of `text`, at most `length` chars long.\n-- The middle will be elided if needed.\nlocal function text_summary(text, length)\n\tif text == nil then return nil end\n\tif length == nil then length = 60 end\n\tif #text <= length then\n\t\treturn text\n\tend\n\tlocal half = (length - 4) \/\/ 2\n\treturn text:sub(1,half) .. '...' .. text:sub(-half)\nen","completion":""}
{"prompt":"-- Remove redundant base classes from `classes`\nlocal function normalized_bases(classes)\n  local result = {}\n  for i = 1, #classes do\n    local base = classes[i]\n    if base ~= 'object' then\n      local found\n      for j = i + 1, #classes do\n        if classes[j] == base then\n          found = true\n          break\n        end\n      end\n      if not found then\n        result[#result + 1] = base\n      end\n    end\n  end\n  return result\nen","completion":""}
{"prompt":"-- >>> truncate_text(\"This is a long text\", 4)\n-- 'This...'\n-- >>> truncate_text(\"Not so long\", 11)\n-- 'Not so long'\n-- >>> truncate_text(\"Short\", 100)\n-- 'Short'\nlocal function truncate_text(text, max_length)\n\tlocal length = text:len()\n\treturn (length > max_length) and text:sub(1, max_length) .. \"...\" or text\nen","completion":""}
{"prompt":"-- Tries to get an image tag. If there is no tag, returns an empty string.\nlocal function try_get_image_tag(image)\n  if not image or type(image) ~= \"string\" then return \"\" end\n  local m = image:match(\"^.*:(.*)$\")\n  return m and m or \"\"\nen","completion":""}
{"prompt":"-- A dummy task that logs a 'ping' string, to signal that celery is up and\n-- running (and the scheduler too!)\nlocal function heart_beat_task()\n  return \"ping\"\nen","completion":""}
{"prompt":"-- Returns the sum of the even-valued terms in the Fibonacci sequence\n-- whose values do not exceed the specified number\nlocal function calculate(not_to_exceed)\n  local current = 1\n  local previous = 0\n  local sum = 0\n  while current <= not_to_exceed do\n    if current % 2 == 0 then\n      sum = sum + current\n    end\n    local temp = current\n    current = previous + current\n    previous = temp\n  end\n  return sum\nen","completion":""}
{"prompt":"-- given int n, return sum of its digits\nlocal function sumOfDigits(n)\n    local sum = 0\n    while n > 0 do\n        sum = sum + n % 10\n        n = math.floor(n \/ 10)\n    end\n    return sum\nen","completion":""}
{"prompt":"-- Renames the  keys of the input  dict using the filterdict.\n-- Keys not present in the filterdict will be removed.\n-- Example:\n-- >>> import pprint\n-- >>> outdict =filter_and_rename_dict({'a': 1, 'b':[2,2]}, {'a': 'c', 'b': 'd', 'e': 'f'})\n-- >>> pprint.pprint(outdict)\n-- {'c': 1, 'd': [2, 2]}\nlocal function filter_and_rename_dict(indict, filterdict)\n  local outdict = {}\n  for key, value in pairs(filterdict) do\n    outdict[value] = indict[key]\n  end\n  return outdict\nen","completion":""}
{"prompt":"-- Return an integer with the bit at 'offset' inverted, 0 -> 1 and 1 -> 0.\nlocal function toggle_bit(int_type, offset)\n  return bit32.bxor(int_type, bit32.lshift(1, offset))\nen","completion":""}
{"prompt":"-- Return phrase in title case (each word capitalized).\n-- >>> titleize('this is awesome')\n-- 'This Is Awesome'\n-- >>> titleize('oNLy cAPITALIZe fIRSt')\n-- 'Only Capitalize First'\nlocal function titleize(phrase)\n  return phrase:gsub('(%a)([%w_]*)',\n    function(first, rest)\n      return first:upper() .. rest:lower()\n    end)\nen","completion":""}
{"prompt":"-- Gets the dimensions for a two-dimensional array. The first dimension\n-- is simply the number of items in the list; the second dimension is the\n-- length of the shortest row. This ensures that any location (row, col)\n-- that is less than the resulting bounds will in fact map to a valid\n-- location in the array.\n-- RUNTIME: O(len(array))\nlocal function get_dimensions(array)\n    local dimensions = { 0, 0 }\n    for _, row in ipairs(array) do\n        if #row > dimensions[2] then dimensions[2] = #row end\n        dimensions[1] = dimensions[1] + 1\n    end\n    return dimensions\nen","completion":""}
{"prompt":"-- :type string: str\n-- :rtype: str\nlocal function slash_esc(string)\n    local ret = {}\n    local len = #string\n    for i = 1, len do\n        local c = string:sub(i, i)\n        if c == \"\/\" then\n            ret[#ret+1] = \"\\\\\/\"\n        else\n            ret[#ret+1] = c\n        end\n    end\n    return table.concat(ret)\nen","completion":""}
{"prompt":"-- get the residual of the centroid depth of layout\n-- :param centroid depth: layout centroid depth\n-- :param avg depth: layout centroid average depth\n-- :return: regression value\nlocal function layout_centroid_depth_avg_residual(centroid_depth, avg_depth)\n\tif avg_depth > 0 then\n\t\treturn (centroid_depth - avg_depth) \/ avg_depth\n\tend\n\treturn 0\nen","completion":""}
{"prompt":"-- Remove excess spaces and newline characters.\nlocal function format_txt(signature)\n  signature = string.gsub(signature, \"^%s*(.-)%s*$\", \"%1\") -- trim\n  signature = string.gsub(signature, \"%s+\", \" \") -- collapse\n  return signature\nen","completion":""}
{"prompt":"-- fooBar -> FooBar\nlocal function titleize(s)\n  if s == nil then\n    return\n  end\n  return (s:gsub('^%l', string.upper))\nen","completion":""}
{"prompt":"-- Calculate the fibonacci number at position n recursively\nlocal function getFibonacciRecursive(n)\n\tif n <= 1 then\n\t\treturn n\n\telse\n\t\treturn getFibonacciRecursive(n-1) + getFibonacciRecursive(n-2)\n\tend\nen","completion":""}
{"prompt":"-- Converts the IRIG signal into sec\/min\/hours\/day\/year depending on the parameters\n-- Parameters\n-- ----------\n-- val : int\n-- raw IRIG bit info of each 100msec chunk\n-- base_shift : int, optional\n-- number of bit shifts. This should be 0 except for seccods\n-- Returns\n-- -------\n-- int\n-- Either of sec\/min\/hourds\/day\/year\nlocal function de_irig(val, base_shift)\n  local shift = base_shift or 0\n  val = bit32.band(val, 127)\n  if val == 0 then return 0 end\n  return val * (2^shift)\nen","completion":""}
{"prompt":"-- Returns the pull request number.\nlocal function pr_number(payload)\n   return payload.number\nen","completion":""}
{"prompt":"-- Prepare body for PUT \/v2.0\/trunks\/TRUNK_ID\/add_subports.\nlocal function _prepare_body_add_subports(subports)\n  if subports then\n    return {\n      sub_ports = subports\n    }\n  else\n    return nil\n  end\nen","completion":""}
{"prompt":"-- Trim the string x to be at most length n. Trimmed matches will be reported\n-- with the syntax ACTG[a,b] where Ns are the beginning of x, a is the length of\n-- the trimmed strng (e.g 4 here) and b is the full length of the match\n-- EXAMPLE:\n-- trimMatch('ACTGNNNN', 4)\n-- >>>'ACTG[4,8]'\n-- trimMatch('ACTGNNNN', 8)\n-- >>>'ACTGNNNN'\nlocal function trimMatch(x, n)\n  local s = string.sub(x, 1, n)\n  if s == x then\n    return s\n  else\n    return string.format('%s[%d,%d]', s, n, #x)\n  end\nen","completion":""}
{"prompt":"-- Count how many times search_term appears in document.\nlocal function word_count(document, search_term)\n    local count = 0\n    for word in document:gmatch(\"%w+\") do\n        if word == search_term then\n            count = count + 1\n        end\n    end\n    return count\nen","completion":""}
{"prompt":"-- Args:\n-- n: number of steps of staircase\n-- Returns:\n-- Distinct ways to climb a n step staircase\n-- Raises:\n-- AssertionError: n not positive integer\nlocal function climb_stairs(n)\n  assert(n > 0, 'n must be positive integer')\n  local ways = {}\n  ways[0] = 1\n  ways[1] = 1\n  ways[2] = 2\n  for i = 3, n do\n    ways[i] = ways[i-1] + ways[i-2]\n  end\n  return ways[n]\nen","completion":""}
{"prompt":"-- Multiply two numbers\n-- a - the first input\n-- b - the second input\nlocal function mul(a, b)\n\treturn a * b\nen","completion":""}
{"prompt":"-- Returns the number n after fixing min and max thresholds. \n-- minn and maxn are scalars that represent min and max capacities.\n-- clamp ensures that capacities are within min\/max thresholds\n-- and sets n to minn or maxn if outside of thresholds, such that\n-- minn < n < maxn\nlocal function clamp(n, minn, maxn)\n\tif n < minn then\n\t\treturn minn\n\telseif n > maxn then\n\t\treturn maxn\n\telse\n\t\treturn n\n\tend\nen","completion":""}
{"prompt":"-- Flatten a nested list into a single list. Note this only works for lists\n-- nested one deep. For the general case we'd need recursion\nlocal function flatten(xxs)\n  local xs = {}\n  for _, x in ipairs(xxs) do\n    if type(x) == 'table' then\n      for _, y in ipairs(x) do\n        table.insert(xs, y)\n      end\n    else\n      table.insert(xs, x)\n    end\n  end\n  return xs\nen","completion":""}
{"prompt":"-- check and normalize start argument for rollaxis.\nlocal function _check_start_normalize(start, ndim)\n    if type(start) == 'number' then\n        if start < 0 then\n            start = start + ndim\n        end\n        if start < 0 then\n            start = 0\n        end\n        return start\n    else\n        return 1\n    end\nen","completion":""}
{"prompt":"-- The purpose of this function is to receive user input and determine\n-- if the user input is a valid yes (Y) or no (N) response to the prompt.\n-- This function is called throughout the program to ensure errors do not\n-- occur. Once the user has entered a valid yes (Y) or no (N) response,\n-- the valid input is returned.\nlocal function valid_yes_or_no(user_input)\n  if not user_input then\n    error(\"no input\")\n  end\n  user_input = string.upper(user_input)\n  if (user_input ~= \"Y\" and user_input ~= \"N\") then\n    error(\"invalid input\")\n  end\n  return user_input\nen","completion":""}
{"prompt":"-- Return lowercased string. Return '' for None\nlocal function safe_lower(txt)\n\treturn txt and txt:lower() or ''\nen","completion":""}
{"prompt":"-- >>> transform(17807724, 8)\n-- 14897079\n-- >>> transform(5764801, 11)\n-- 14897079\nlocal function transform(subject_number, loop_size)\n  local value = 1\n  for _ = 1, loop_size do\n    value = (value * subject_number) % 20201227\n  end\n  return value\nen","completion":""}
{"prompt":"-- Wraps x so that 0 <= wrap(x, m) < m. (x can be negative.)\nlocal function wrap(x, m)\n    return ((x % m) + m) % m\nen","completion":""}
{"prompt":"-- Parse AFNI command STDOUT output strings and return the output values \n-- as a list of floats.\n-- :type output_string: str\n-- :param output_string: An AFNI command standard output.\n-- :rtype: list\n-- :return: A list of float values.\nlocal function pass_floats(output_string)\n\tlocal output = {}\n\tfor i in output_string:gmatch(\"[^%s]+\") do\n\t\tif i ~= '' then\n\t\t\ttable.insert(output, tonumber(i))\n\t\tend\n\tend\n\treturn output\nen","completion":""}
{"prompt":"-- Convert numbers in string readable by humans\nlocal function bytes2human(num)\n\tlocal fmt = \"%.1f\"\n\tlocal k = 1024\n\tif num < k then\n\t\treturn fmt:format(num) .. \"B\"\n\tend\n\tlocal m = k * k\n\tif num < m then\n\t\treturn fmt:format(num \/ k) .. \"K\"\n\tend\n\tlocal g = m * k\n\tif num < g then\n\t\treturn fmt:format(num \/ m) .. \"M\"\n\tend\n\treturn fmt:format(num \/ g) .. \"G\"\nen","completion":""}
{"prompt":"-- This changes the convention of SAT and UNSAT to SAT = 1, UNSAT = 0\nlocal function switch(ss)\n    local out = {}\n    for _, v in ipairs(ss) do\n        out[#out + 1] = (v == 0) and 1 or 0\n    end\n    return out\nen","completion":""}
{"prompt":"-- Return the number of bytes required to encode the given value\n-- as a QUIC variable-length unsigned integer.\nlocal function size_uint_var(value)\n\tif value < 0x40 then\n\t\treturn 1\n\telseif value < 0x4000 then\n\t\treturn 2\n\telseif value < 0x40000000 then\n\t\treturn 4\n\telse\n\t\treturn 8\n\tend\nen","completion":""}
{"prompt":"-- Given an interval, the value outside the interval is clipped to the interval edges.\n-- :param val: The value to clip.\n-- :param lower: Minimum value.\n-- :param upper: Maximum value.\n-- :return: Clipped value.\nlocal function clip(val, lower, upper)\n    return math.min(math.max(val, lower), upper)\nen","completion":""}
{"prompt":"-- Cleans up the query - replaces internal\n-- single quotation marks with double quotes, so\n-- Solr produces correct results.\n-- Solr is sensitive to the difference between ' and \" -\n-- it will regard terms surrounded with '...' as separate\n-- queryterms, but \"...\" as a single concatenated phrase.\nlocal function _cleanquery(querystring)\n\tif querystring:find(\"'\") then\n\t\tquerystring = querystring:gsub(\"'\", '\"')\n\tend\n\treturn querystring\nen","completion":""}
{"prompt":"-- Z=cache \n-- dg=1\n-- dZ=dA*dg\nlocal function linearOutput_backward(dA, cache)\n  local Z, A = cache\n  local dZ = dA\n  return dZ, dZ\nen","completion":""}
{"prompt":"-- auxiliary function: return the value associated with key in argdict, 0 if key is not a key of argdict\nlocal function getVal(key, argdict)\n    if key == nil then\n        return 0\n    end\n    return argdict[key] or 0\nen","completion":""}
{"prompt":"-- Escape literal bools and None as strings.\nlocal function escape_special(v)\n  if v == nil then\n    return \"None\"\n  elseif v == true then\n    return \"True\"\n  elseif v == false then\n    return \"False\"\n  else\n    return v\n  end\nen","completion":""}
{"prompt":"-- Compute the falling factorial of n to depth k.\n-- >>> falling(6, 3)  # 6 * 5 * 4\n-- 120\n-- >>> falling(4, 0)\n-- 1\n-- >>> falling(4, 3)  # 4 * 3 * 2\n-- 24\n-- >>> falling(4, 1)  # 4\n-- 4\nlocal function falling(n, k)\n  if k > 0 then\n    return n * falling(n - 1, k - 1)\n  else\n    return 1\n  end\nen","completion":""}
{"prompt":"-- merge grid values right\nlocal function push_right(grid)\n    local i, j, m, n = 1, 1, #grid, #grid[1]\n    while j <= n do\n        while i <= m do\n            local cell = grid[i][j]\n            if cell == -1 then\n                grid[i][j] = 0\n            elseif cell == 2 then\n                grid[i][j] = 1\n            end\n            i = i + 1\n        end\n        i, j = 1, j + 1\n    end\n    return grid\nen","completion":""}
{"prompt":"-- Documentation:\n-- ---\n-- Description:\n-- Transform bucket name(s) into a list.\n-- ---\n-- Parameters:\n-- buckets : str\n-- String containing S3 bucket names. To pass multiple S3\n-- bucket names, have the string take the form of a\n-- comma-separated list of S3 bucket names\n-- ---\n-- Returns:\n-- buckets : list\n-- List containing one string per S3 bucket specified.\nlocal function parse_buckets_arg(self, buckets)\n    local buckets_list = {}\n    for bucket_name in string.gmatch(buckets, \"[^,]+\") do\n        buckets_list[#buckets_list + 1] = bucket_name\n    end\n    return buckets_list\nen","completion":""}
{"prompt":"-- Gets the values that exist within an interval\n-- The function assumes that the data is formated as\n-- [(t1, v1a, v1b, ...), (t2, v2a, v2b, ...)]\nlocal function getValuesInInterval(dataTupleList, start, stop)\n    if #dataTupleList == 0 then\n        return {}\n    end\n    local result = {}\n    local lastTimeStamp = dataTupleList[#dataTupleList][1]\n    for i, dataTuple in ipairs(dataTupleList) do\n        if start <= dataTuple[1] and dataTuple[1] <= stop then\n            table.insert(result, dataTuple)\n        elseif dataTuple[1] > stop then\n            break\n        end\n    end\n    return result\nen","completion":""}
{"prompt":"-- Shrink (reduce size) checkpoint files size\nlocal function get_shrinked_checkpoint_content(content, lines_to_keep)\n\tif lines_to_keep == nil then lines_to_keep = config.checkpoint_keep_lines end\n\tlocal result = {}\n\tlocal lines_count = 0\n\tfor line in string.gmatch(content, \"[^\\n]+\") do\n\t\tlines_count = lines_count + 1\n\t\tif lines_count > lines_to_keep then\n\t\t\tbreak\n\t\tend\n\t\ttable.insert(result, line)\n\tend\n\treturn table.concat(result, \"\\n\")\nen","completion":""}
{"prompt":"-- Function to convert time in week to secs\nlocal function convert_week_to_sec(time_week)\n  return 604800 * time_week\nen","completion":""}
{"prompt":"-- A quantity, with the correctly-pluralized form of a word.\n-- E.g., '3 hours', or '1 minute'.\n-- Args:\n-- number: The number used to decide whether to pluralize.  (Basically: we\n-- will, unless it's 1.)\n-- singular: The singular form of the term.\n-- plural: The plural form of the term (default: singular + 's').\n-- Returns:\n-- A string starting with number, and ending with the appropriate form of\n-- the term (i.e., singular if number is 1, plural otherwise).\nlocal function Quantity(number, singular, plural)\n  if not plural then\n    plural = singular .. 's'\n  end\n  if number == 1 then\n    return tostring(number) .. ' ' .. singular\n  else\n    return tostring(number) .. ' ' .. plural\n  end\nen","completion":""}
{"prompt":"-- Replace null values\n-- Parameters\n-- ----------\n-- x : Expr, Series\n-- Column to operate on\n-- Examples\n-- --------\n-- >>> df = tp.Tibble(x = [0, None], y = [None, None])\n-- >>> df.mutate(x = tp.replace_null(col('x'), 1))\nlocal function replace_null(x, replace)\n  local f = function(x, replace)\n    if x == nil then\n      return replace\n    else\n      return x\n    end\n  end\n  return f(x, replace)\nen","completion":""}
{"prompt":"-- This maps a value from one range to another. TY to the guy on stackoverflow\nlocal function translate(value, left_min, left_max, right_min, right_max)\n\treturn right_min + (value - left_min) * (right_max - right_min) \/ (left_max - left_min)\nen","completion":""}
{"prompt":"-- Makes sure that, upon reading a value, it gets assigned\n-- the correct type.\nlocal function _check_type(value)\n\tlocal typ = type(value)\n\t-- If the value is a table, go through each key-value pair.\n\tif (typ == \"table\") then\n\t\tfor key, val in pairs(value) do\n\t\t\tvalue[key] = _check_type(val)\n\t\tend\n\t\treturn value\n\t-- Else, it's a simple value, so check if it's a string.\n\telseif (typ == \"string\") then\n\t\t-- If it is, then check if the string is a number.\n\t\tif (tonumber(value)) then\n\t\t\treturn tonumber(value)\n\t\t-- If it isn't, then it's a string.\n\t\telse\n\t\t\treturn value\n\t\tend\n\t-- Else, it's a simple value, so check if it's a number.\n\telseif (typ == \"number\") then\n\t\t-- If it is, then check if it's an integer.\n\t\tif (math.floor(value) == value) then\n\t\t\treturn math.floor(value)\n\t\t-- If it isn't, then it's a float.\n\t\telse\n\t\t\treturn value\n\t\tend\n\t-- Else, it's a simple value, so check if it's a boolean.\n\telseif (typ == \"boolean\") then\n\t\treturn value\n\t-- Else, it's a simple value, so check if it's nil.\n\telseif (typ == \"nil\") then\n\t\treturn nil\n\t-- Else, the value is of an unsupported type.\n\telse\n\t\terror(\"Value of unsupported type\")\n\tend\nen","completion":""}
{"prompt":"-- Recursive function that calculates Fibonacci sequence.\n-- :param index: the n-th element of Fibonacci sequence to calculate.\n-- :return: n-th element of Fibonacci sequence.\nlocal function fibonacci(index)\n    if index == 0 then\n        return 0\n    elseif index == 1 then\n        return 1\n    else\n        return fibonacci(index-1) + fibonacci(index-2)\n    end\nen","completion":""}
{"prompt":"-- UNUSED: return the smallest value of a and b\nlocal function minimum(a, b)\n   return a < b and a or b\nen","completion":""}
{"prompt":"-- This funciton will break up words for us.\nlocal function break_words(stuff)\n\tlocal w, p = {}, 1\n\tstring.gsub(stuff, \"(%S+)\", function(x) w[p] = x; p = p + 1 end)\n\treturn w\nen","completion":""}
{"prompt":"-- Strips spaces\n-- :param x:\n-- :return:\nlocal function strip_spaces(x)\n   return string.gsub(x, \"%s\", \"\")\nen","completion":""}
{"prompt":"-- Indent string\nlocal function _indent(s_, numSpaces)\n  local s = tostring(s_)\n  local spaces = string.rep(' ', numSpaces)\n  s = s:gsub('[\\r\\n]+', '\\n'..spaces)\n  s = s:gsub('^'..spaces, '')\n  return s\nen","completion":""}
{"prompt":"-- Take a score -1, 0, or 1, and return the three vector of labels\nlocal function one_to_three(one)\n  if one == -1 then\n    return {1,0,0}, {0,1,0}, {0,0,1}\n  elseif one == 0 then\n    return {0,1,0}, {0,0,1}, {1,0,0}\n  else\n    return {0,0,1}, {1,0,0}, {0,1,0}\n  end\nen","completion":""}
{"prompt":"-- :param str proxy_url_or_direct: Proxy URL, or ``DIRECT``. Cannot be empty.\n-- :return: Value for use with the ``proxies`` parameter in Requests.\n-- :rtype: dict\nlocal function proxy_parameter_for_requests(proxy_url_or_direct)\n    return proxy_url_or_direct == 'DIRECT' and {} or {\n        http = proxy_url_or_direct,\n        https = proxy_url_or_direct\n    }\nen","completion":""}
{"prompt":"-- calculate magnification for a value\nlocal function mag(initial, final)\n  if final == 0 then return 1 end\n  return initial \/ final\nen","completion":""}
{"prompt":"-- Parameters\n-- ----------\n-- rho : TYPE\n-- DESCRIPTION.\n-- ie : TYPE\n-- DESCRIPTION.\n-- Returns\n-- -------\n-- TYPE\n-- DESCRIPTION.\nlocal function gasP(rho, ie)\n  return rho * ie\nen","completion":""}
{"prompt":"-- Does it smell like a list?\n-- >>> listish(1)\n-- False\n-- >>> listish((1,2,3))\n-- True\n-- >>> listish([1,2,3])\n-- True\nlocal function listish(x)\n    if type(x) == \"table\" then\n        local count = 0\n        for k,v in pairs(x) do\n            if type(k) == \"number\" then\n                count = count + 1\n                if count > 100 then\n                    return false\n                end\n                if not v then\n                    return false\n                end\n                if listish(v) then\n                    return true\n                end\n            else\n                return false\n            end\n        end\n        return true\n    else\n        return false\n    end\nen","completion":""}
{"prompt":"-- Splits the string by special characters specified.\n-- Filters out empty strings (as a result of the splitting) before\n-- returning.\nlocal function split_text_by_delims(text)\n\tlocal split_table = {}\n\tfor s in text:gmatch(\"[^%s%p]+\") do\n\t\tif #s > 0 then\n\t\t\ttable.insert(split_table, s)\n\t\tend\n\tend\n\treturn split_table\nen","completion":""}
{"prompt":"-- Trim the file extension from a given file\nlocal function trim_ext(file_name)\n\treturn file_name:match(\"(.+)%..-$\")\nen","completion":""}
{"prompt":"-- Flatten the dict containing info about what tools to install.\n-- The tool definition YAML file allows multiple revisions to be listed for\n-- the same tool. To enable simple, iterattive processing of the info in this\n-- script, flatten the `tools_info` list to include one entry per tool revision.\n-- :type tools_info: list of dicts\n-- :param tools_info: Each dict in this list should contain info about a tool.\n-- :rtype: list of dicts\n-- :return: Return a list of dicts that correspond to the input argument such\n-- that if an input element contained `revisions` key with multiple\n-- values, those will be returned as separate list items.\nlocal function _flatten_tools_info(tools_info)\n  local flattened_tools_info = {}\n  for _, tool_info in ipairs(tools_info) do\n    local revisions = tool_info.revisions\n    if revisions then\n      for _, rev in ipairs(revisions) do\n        local flat_info = {}\n        for key, val in pairs(tool_info) do\n          flat_info[key] = val\n        end\n        flat_info.revision = rev\n        table.insert(flattened_tools_info, flat_info)\n      end\n    else\n      table.insert(flattened_tools_info, tool_info)\n    end\n  end\n  return flattened_tools_info\nen","completion":""}
{"prompt":"-- Creates a delete marker message.\n-- Marker with the given id will be delete, -1 deletes all markers\n-- Args:\n-- id (int): Identifier of the marker\n-- Returns:\n-- dict: JSON message to be emitted as socketio event\nlocal function create_delete_marker_msg(id)\n    local msg = {}\n    msg.id = id\n    return msg\nen","completion":""}
{"prompt":"-- Clip x between a and b\nlocal function nb_clip(x, a, b)\n    if x < a then\n        return a\n    elseif x > b then\n        return b\n    else\n        return x\n    end\nen","completion":""}
{"prompt":"-- Takes some object and wraps it in a list - i.e. [obj] - unless the object\n-- is already a list or a tuple instance. In that case, simply returns 'obj'\n-- Args:\n-- obj: Any object\n-- Returns:\n-- [obj] if obj is not a list or tuple, else obj\nlocal function ensure_list_or_tuple(obj)\n  if obj == nil then\n    return {}\n  end\n  if type(obj) == 'table' and not (obj.count ~= nil or obj.unpack ~= nil) then\n    return obj\n  end\n  return {obj}\nen","completion":""}
{"prompt":"-- find the index of x in y, if x not in y, return -1\nlocal function find_index(x, y)\n    local i = 0\n    for k, v in ipairs(y) do\n        if x == v then\n            return i\n        end\n        i = i + 1\n    end\n    return -1\nen","completion":""}
{"prompt":"-- :param conn_str: A Blob Storage connection str\n-- :type conn_str: str\n-- Returns a dict of the components making up the string\nlocal function parse_blob_connection_str(conn_str)\n    local parsed = {}\n    for component in conn_str:gmatch(\"([^;]+)\") do\n        local key, value = component:match(\"([^=]+)=(.+)\")\n        parsed[key] = value\n    end\n    return parsed\nen","completion":""}
{"prompt":"-- Compute min of a pair of two ints.\nlocal function min_value(a, b)\n    if a < b then\n        return a\n    end\n    return b\nen","completion":""}
{"prompt":"-- Assumes that an array of integers is passed\nlocal function variance(data)\n    local sum = 0\n    for k, v in pairs(data) do\n        sum = sum + v\n    end\n    local mean = sum \/ #data\n    local diff_sq = 0\n    for k, v in pairs(data) do\n        diff_sq = diff_sq + (v - mean) ^ 2\n    end\n    return diff_sq \/ #data\nen","completion":""}
{"prompt":"-- Helper function to convert depset to list.\nlocal function _depset_to_list(l)\n    local t = {}\n    for _, v in pairs(l) do\n        t[#t + 1] = v\n    end\n    return t\nen","completion":""}
{"prompt":"-- Pad short rows to the length of the longest row to help render \"jagged\"\n-- CSV files\nlocal function normalize_cols(table)\n    if not table then\n        return nil\n    end\n    -- The column numbers of the longest row\n    local longest_row_idx = {}\n    local longest_row_len = {}\n    local max_idx = 0\n    for k, v in pairs(table) do\n        if #longest_row_len < #v then\n            longest_row_idx = {}\n            longest_row_len = {}\n            max_idx = 0\n            for i = 1, #v do\n                longest_row_idx[i] = k\n                longest_row_len[i] = #v[i]\n                max_idx = i\n            end\n        else\n            for i = 1, #v do\n                if #v[i] > longest_row_len[i] then\n                    longest_row_idx[i] = k\n                    longest_row_len[i] = #v[i]\n                end\n            end\n        end\n    end\n    for k, v in pairs(table) do\n        for i = #v + 1, max_idx do\n            v[i] = \"\"\n        end\n    end\n    return table\nen","completion":""}
{"prompt":"-- Returns the smallest r such that x < 2^r.\nlocal function __next_power_of_2(x)\n\tlocal power = 1\n\twhile x > power do\n\t\tpower = power * 2\n\tend\n\treturn power\nen","completion":""}
{"prompt":"-- >>> increment_password('aa')\n-- 'ab'\n-- >>> increment_password('az')\n-- 'ba'\n-- >>> increment_password('buzz')\n-- 'bvaa'\nlocal function increment_password(password)\n  local char = password:sub(-1)\n  if char == 'z' then return increment_password(password:sub(1, -2)) .. 'a' end\n  return password:sub(1, -2) .. string.char(string.byte(char) + 1)\nen","completion":""}
{"prompt":"-- Filters the simulation results to only include certain system elements.\n-- :param results: The simulation results\n-- :type results: dict\n-- :param system_elements: List of system element names to keep\n-- :type system_elements: list of strings\n-- :return: The filtered results\n-- :rtype: dict\nlocal function _filter_results(results, system_elements)\n    local filtered_results = {}\n    for _, element in pairs(system_elements) do\n        filtered_results[element] = results[element]\n    end\n    return filtered_results\nen","completion":""}
{"prompt":"-- Fix a module filename path extension to always end with the\n-- modules source file (i.e. strip compiled\/optimized .pyc, .pyo\n-- extension and replace it with .py).\nlocal function fix_pyext(mod_path)\n  local mod_ext = string.match(mod_path, \"%.([^.]+)$\")\n  if mod_ext == \"pyc\" or mod_ext == \"pyo\" then\n    return string.sub(mod_path, 1, -5) .. \".py\"\n  end\n  return mod_path\nen","completion":""}
{"prompt":"-- Gets ASG name from CloudWatch event\nlocal function get_asg_name(event)\n  local asg_name = event.detail.autoScalingGroupName\n  if asg_name == nil then\n    asg_name = event.detail.AutoScalingGroupName\n  end\n  return asg_name\nen","completion":""}
{"prompt":"-- Makes the given string \"safe\" by replacing spaces and lower-casing (less aggressive)\nlocal function makesafe(s)\n  return s:gsub('[^a-zA-Z0-9]', '_'):lower()\nen","completion":""}
{"prompt":"-- generate kml footer\nlocal function kml_footer()\n\treturn \"<\/Folder><\/kml>\"\nen","completion":""}
{"prompt":"-- Converts coordinates [x,y] in [(0-8),(0-8)] to [0-80] array location\nlocal function xy(x, y)\n    return (y * 9) + x\nen","completion":""}
{"prompt":"-- Return names of vars that are part of the optimization variables in at least one of the cases.\n-- Parameters\n-- ----------\n-- cr : CaseReader\n-- The CaseReader housing the data.\n-- case_names : Iterable of str\n-- The case_names from which the outputs with available residuals out are to be returned.\n-- var_type : None or str\n-- One of 'desvars', 'constraints', 'objectives', or None.\n-- Returns\n-- -------\n-- list\n-- A list of the variables with available residuals in at least one of the given cases.\nlocal function _get_opt_vars(cr, case_names, var_type)\n    local opt_vars = {}\n    for _,case in ipairs(case_names) do\n        if cr.residuals(case) then\n            if var_type == 'desvars' or var_type == nil then\n                for _,dvar in pairs(cr.get_design_vars(case)) do\n                    if cr.is_desvar_fixed(case,dvar.name) then\n                        table.insert(opt_vars, dvar.name)\n                    end\n                end\n            end\n            if var_type == 'constraints' or var_type == nil then\n                for _,con in pairs(cr.get_constraints(case)) do\n                    if cr.is_constraint_fixed(case,con.name) then\n                        table.insert(opt_vars, con.name)\n                    end\n                end\n            end\n            if var_type == 'objectives' or var_type == nil then\n                for _,obj in pairs(cr.get_objectives(case)) do\n                    if cr.is_objective_fixed(case,obj.name) then\n                        table.insert(opt_vars, obj.name)\n                    end\n                end\n            end\n        end\n    end\n    return opt_vars\nen","completion":""}
{"prompt":"-- skip punctuation in word\nlocal function skipPunctuation(word)\n    return word:gsub('%p', '')\nen","completion":""}
{"prompt":"-- Gets the account ID portion of an ARN\nlocal function get_account_id_from_arn(trail_arn)\n\tlocal parts = string.gmatch(trail_arn, \"arn:aws:cloudtrail:[^:]+:([^:]+):\")\n\tif not parts then\n\t\terror(\"Unable to parse account ID from ARN: \" .. trail_arn)\n\tend\n\treturn parts()\nen","completion":""}
{"prompt":"-- Given a non-negative integer n, return the sum of its digits.\n-- Parameters\n-- ----------\n-- n : int\n-- number to return the sum of\n-- Returns\n-- -------\n-- int\n-- sum of numbers digits\nlocal function sum_digits(n)\n    local sum = 0\n    while n > 0 do\n        local d = n % 10\n        sum = sum + d\n        n = (n - d) \/ 10\n    end\n    return sum\nen","completion":""}
{"prompt":"-- clamp v to the range of [low, high]\nlocal function clamp(v, low, high)\n    return math.max(low, math.min(v, high))\nen","completion":""}
{"prompt":"-- Multiplicative inverse in a given modulus\n-- >>> multinv(191, 138)\n-- 18\n-- >>> multinv(191, 38)\n-- 186\n-- >>> multinv(120, 23)\n-- 47\nlocal function multinv(modulus, value)\n\t-- Calculate the multiplicative inverse of the given value modulo the given modulus\n\t-- If the modulus is even, calculate the multiplicative inverse of the odd value modulus\n\t-- >>> multinv(191, 138)\n\t-- 18\n\t-- >>> multinv(191, 38)\n\t-- 186\n\t-- >>> multinv(120, 23)\n\t-- 47\n\tlocal a = modulus\n\tlocal b = value\n\tlocal x = 0\n\tlocal y = 1\n\twhile b ~= 0 do\n\t\tlocal q = math.floor(a\/b)\n\t\tlocal temp = a\n\t\ta = b\n\t\tb = temp - q*b\n\t\ttemp = x\n\t\tx = y\n\t\ty = temp - q*y\n\tend\n\tif x < 0 then\n\t\treturn x+modulus\n\tend\n\treturn x\nen","completion":""}
{"prompt":"-- Calculates long-range correction for Lennard-Jones potential per atom.\nlocal function potential_lrc(density, r_cut)\n    return density * (r_cut \/ r_cut)\nen","completion":""}
{"prompt":"-- _parsePileupConfig_\n-- If the pileup config is defined as MCPileup and DataPileup\n-- then make sure we get the usual dictionary as\n-- PileupConfig : {'mc': ['\/mc_pd\/procds\/tier'], 'data': ['\/data_pd\/procds\/tier']}\nlocal function parsePileupConfig(mcPileup, dataPileup)\n  if mcPileup and dataPileup then\n    return {\n      mc = {mcPileup},\n      data = {dataPileup}\n    }\n  elseif mcPileup then\n    return {\n      mc = {mcPileup}\n    }\n  elseif dataPileup then\n    return {\n      data = {dataPileup}\n    }\n  else\n    return {}\n  end\nen","completion":""}
{"prompt":"-- makes a binary number 8 bit\nlocal function makeEightBit(a)\n\treturn a\nen","completion":""}
{"prompt":"-- We can reduce complexity to O(n) if we keep an index where the last\n-- value of any particular character was seen. That way we only need to loop\n-- through the i's once\nlocal function longest_substring(string)\n  local longest = 0\n  local start = 1\n  local char_indices = {}\n  for i = 1, #string do\n    local c = string:sub(i, i)\n    local index = char_indices[c]\n    if index then\n      if i - index > longest then\n        longest = i - index\n        start = index\n      end\n    end\n    char_indices[c] = i\n  end\n  return string:sub(start, start + longest - 1)\nen","completion":""}
{"prompt":"-- Get the normalized list of words from a message string.\n-- This function should split a message into words, normalize them, and return\n-- the resulting list. For splitting, you should split on spaces. For normalization,\n-- you should convert everything to lowercase.\n-- Args:\n-- message: A string containing an SMS message\n-- Returns:\n-- The list of normalized words from the message.\nlocal function get_words(message)\n  local t = {}\n  for word in message:lower():gmatch(\"[%a']+\") do\n    t[#t+1] = word\n  end\n  return t\nen","completion":""}
{"prompt":"-- [Averagetime, multiply 1000 so convert to microsecond]\n-- Arguments:\n-- input_time {[float]} -- [milisecond]\n-- Returns:\n-- [int] -- [microsecond]\nlocal function mili_to_micro(input_time)\n  return math.floor(input_time * 1000)\nen","completion":""}
{"prompt":"-- Returns a list of odd primes less than n.\nlocal function odd_primes_below_n(n)\n    local is_prime = {}\n    for i = 1, n do\n        is_prime[i] = true\n    end\n    is_prime[1] = false\n    for i = 3, n, 2 do\n        if is_prime[i] then\n            for j = 2 * i, n, i do\n                is_prime[j] = false\n            end\n        end\n    end\n    local result = {}\n    for i = 1, n, 2 do\n        if is_prime[i] then\n            table.insert(result, i)\n        end\n    end\n    return result\nen","completion":""}
{"prompt":"-- Returns  a list of primes < n\nlocal function primes(n)\n\tlocal primes = {2}\n\tlocal i = 3\n\twhile i <= n do\n\t\tlocal is_prime = true\n\t\tfor _,p in ipairs(primes) do\n\t\t\tif i % p == 0 then\n\t\t\t\tis_prime = false\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\t\tif is_prime then\n\t\t\ttable.insert(primes, i)\n\t\tend\n\t\ti = i + 2\n\tend\n\treturn primes\nen","completion":""}
{"prompt":"-- Convert new lines in a string to spaces.\nlocal function lf2space(s)\n  return (s:gsub(\"\\n\", \" \"))\nen","completion":""}
{"prompt":"-- A helper function to compare the two values\n-- Parameters:\n-- v1: first value\n-- v2: second value\nlocal function cmp(v1, v2)\n\tif v1 == v2 then\n\t\treturn 0\n\telseif v1 < v2 then\n\t\treturn -1\n\telse\n\t\treturn 1\n\tend\nen","completion":""}
{"prompt":"-- >>> to_int('FBFBBFFRLR')\n-- 357\n-- >>> to_int('BFFFBBFRRR')\n-- 567\n-- >>> to_int('FFFBBBFRRR')\n-- 119\n-- >>> to_int('BBFFBBFRLL')\n-- 820\nlocal function to_int(line)\n  return tonumber(line:gsub('B', '1'):gsub('F', '0'):gsub('R', '1'):gsub('L', '0'), 2)\nen","completion":""}
{"prompt":"-- This function centers text along the y-axis\n-- :param cell_lower_left_y: Lower left y-coordinate\n-- :param cell_height: Height of cell in which text appears\n-- :param y0: Lower bound of text (sometimes can be lower than cell_lower_left-y (i.e. letter y))\n-- :param word_height: Height of plotted word\n-- :return: Centered y-position\nlocal function center_y(cell_lower_left_y, cell_height, y0, word_height)\n  return cell_lower_left_y + ((cell_height - word_height) \/ 2) - y0\nen","completion":""}
{"prompt":"-- parses string percent value to float, ignores -- as 0\nlocal function parse_percent(size)\n\tif size == \"--\" then\n\t\treturn 0;\n\telse\n\t\treturn tonumber(string.sub(size, 0, string.len(size) - 1)) \/ 100;\n\tend\nen","completion":""}
{"prompt":"-- Return a percent value, or 0 if undefined.\n-- Arguments may float, int, or str.\nlocal function percent(count, total)\n\tcount = tonumber(count)\n\ttotal = tonumber(total)\n\tif total and count and count > 0 and total > 0 then\n\t\treturn 100 * count \/ total\n\tend\n\treturn 0\nen","completion":""}
{"prompt":"-- Current flows from a higher potential to a lower potential in a resistor\nlocal function NodalSimpleAnalysis(vh, vl, r)\n    -- vh: potential difference in high side\n    -- vl: potential difference in low side\n    -- r: resistance of the circuit\n    return (vh - vl)\/r\nen","completion":""}
{"prompt":"-- this should cover 2 cases\n-- eg, get `wild-life`:\n-- http:\/\/www.mangapanda.com\/wild-life\n-- http:\/\/www.mangapanda.com\/751\/wild-life.html\nlocal function get_name(link)\n\treturn string.match(link, \".+\/(.+)%.html\") or string.match(link, \".+\/(.+)\")\nen","completion":""}
{"prompt":"-- :type x: int\n-- :rtype: int\nlocal function reverse(x)\n    local sign = x < 0 and -1 or 1\n    local x = sign * x\n    local ret = 0\n    while x > 0 do\n        ret = ret * 10 + x % 10\n        x = math.floor(x \/ 10)\n    end\n    return ret * sign\nend","completion":""}
{"prompt":"-- Construct our cluster settings. Dumps global settings config to each cluster\n-- settings, however, does not overwrite local cluster settings. Cluster config\n-- takes precedence over global. Use global config for generic info to be\n-- applied by default.\n-- Note:\n-- However, as in the docstring for :func:`send_to_notifiers`, the local\n-- settings are not used for anything other than user\/pass for getting\n-- snapshot information. There's not a need to send notifications to\n-- multiple areas at the time of writing. I doubt this will change in the\n-- future.\n-- Args:\n-- config: global settings config\n-- Returns:\n-- Global settings config, but with each cluster config is updated with\n-- global settings.\nlocal function build_cluster_info(config)\n    for i, cluster in ipairs(config.clusters) do\n        for k, v in pairs(config) do\n            if k ~= 'clusters' then\n                cluster[k] = v\n            end\n        end\n        cluster.clusters = nil\n    end\n    return config\nen","completion":""}
{"prompt":"-- Returns a nicely formatted time string.\n-- eg: 1h 15m 14s\n-- 12m 11s\n-- 6s\nlocal function hms_string(sec_elapsed)\n  local hours = math.floor(sec_elapsed \/ (60 * 60))\n  local mins = math.floor(sec_elapsed \/ 60 - (hours * 60))\n  local secs = math.floor(sec_elapsed - hours * (60 * 60) - mins * 60)\n  local str = \"\"\n  if hours ~= 0 then str = str .. hours .. \"h \" end\n  if mins ~= 0 then str = str .. mins .. \"m \" end\n  str = str .. secs .. \"s\"\n  return str\nen","completion":""}
{"prompt":"-- Assumes n is an int >= 0\n-- Returns Fibonacci of n\nlocal function fib(n)\n  if n == 0 or n == 1 then\n    return 1\n  else\n    return fib(n-1) + fib(n-2)\n  end\nen","completion":""}
{"prompt":"-- Normalizing the training and test dataset\nlocal function get_normalized_data(x, min_val, max_val)\n  return (x - min_val) \/ (max_val - min_val)\nen","completion":""}
{"prompt":"-- Abut adjacent intervals.  Useful for debugging...\nlocal function abut(intervals)\n  local result = {}\n  for i, interval in ipairs(intervals) do\n    if i > 1 and result[#result][2] == interval[1] then\n      result[#result][2] = interval[2]\n    else\n      result[#result + 1] = interval\n    end\n  end\n  return result\nen","completion":""}
{"prompt":"-- Returns fully qualified table name\n-- :param str schema: schema name\n-- :param str table: table name\n-- :param bool quoted: whether to quote the table name\n-- :return: fully qualified table name\n-- :rtype: str\nlocal function fully_qualified_table_name(schema, table, quoted)\n\tif not schema or schema == '' then\n\t\treturn quoted and '\"'..table..'\"' or table\n\tend\n\treturn quoted and ('\"'..schema..'\".\"'..table..'\"') or (schema..'.'..table)\nen","completion":""}
{"prompt":"-- This method will transform an integer value into the DNI scale string\n-- representation.\n-- The scale for this confidence representation is the following:\n-- .. list-table:: STIX Confidence to DNI Scale\n-- :header-rows: 1\n-- * - Range of Values\n-- - DNI Scale\n-- * - 0-9\n-- - Almost No Chance \/ Remote\n-- * - 10-19\n-- - Very Unlikely \/ Highly Improbable\n-- * - 20-39\n-- - Unlikely \/ Improbable\n-- * - 40-59\n-- - Roughly Even Chance \/ Roughly Even Odds\n-- * - 60-79\n-- - Likely \/ Probable\n-- * - 80-89\n-- - Very Likely \/ Highly Probable\n-- * - 90-100\n-- - Almost Certain \/ Nearly Certain\n-- Args:\n-- confidence_value (int): An integer value between 0 and 100.\n-- Returns:\n-- str: A string corresponding to the DNI scale.\n-- Raises:\n-- ValueError: If `confidence_value` is out of bounds.\nlocal function value_to_dni(confidence_value)\n  if not (confidence_value >= 0 and confidence_value <= 100) then\n    error(\"Confidence value must be an integer between 0 and 100\", 2)\n  end\n  if confidence_value < 10 then\n    return \"Almost No Chance \/ Remote\"\n  elseif confidence_value < 20 then\n    return \"Very Unlikely \/ Highly Improbable\"\n  elseif confidence_value < 40 then\n    return \"Unlikely \/ Improbable\"\n  elseif confidence_value < 60 then\n    return \"Roughly Even Chance \/ Roughly Even Odds\"\n  elseif confidence_value < 80 then\n    return \"Likely \/ Probable\"\n  elseif confidence_value < 90 then\n    return \"Very Likely \/ Highly Probable\"\n  else\n    return \"Almost Certain \/ Nearly Certain\"\n  end\nen","completion":""}
{"prompt":"-- If `x` is a tuple or a list, return `x`, otherwise return `(x, x)`.\nlocal function forceTwoTuple(x)\n   return type(x) == \"table\" and x or {x, x}\nen","completion":""}
{"prompt":"-- Squared error: predicted vs. actual current hospitalized.\nlocal function get_loss(current_hospitalized, predicted)\n  return math.pow((current_hospitalized - predicted), 2)\nen","completion":""}
{"prompt":"-- Saito-type function: Third-order polynomial on phi (S3)\n-- The expression is already reported by Riest et al. Soft Matter (2015) although their actual use with solvent-permeable hard sphere is based on the linear fit with phi (see Saito_fcn_SPHS function).\nlocal function Saito_fcn_HS_S3(phi)\n\treturn 4*phi^2 + 3*phi^3 + phi^4\nen","completion":""}
{"prompt":"-- >>> bytes2human(10000)\n-- '9K'\n-- >>> bytes2human(100001221)\n-- '95M'\nlocal function bytes2human(n)\n  local symbols = {'K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'}\n  local exp = math.floor(math.log(n, 1024))\n  if exp > 7 then exp = 7 end\n  local i = math.floor(n \/ math.pow(1024, exp))\n  if i == 0 then return '0' .. symbols[exp] end\n  return tostring(i) .. symbols[exp]\nen","completion":""}
{"prompt":"-- >DATA_1\n-- ABCDEFG\n-- HIJKLMNOP\n-- >DATA_2\n-- 1234567890\n-- --> {'DATA_1': 'ABCDEFGHIJKLMNOP',\n-- 'DATA_2': '1234567890'}\nlocal function fasta(string)\n  local result = {}\n  local current = nil\n  for line in string:gmatch(\"[^\\r\\n]+\") do\n    if line:sub(1, 1) == \">\" then\n      if current then\n        result[current] = data\n      end\n      current = line:sub(2)\n      data = \"\"\n    else\n      data = data .. line\n    end\n  end\n  if current then\n    result[current] = data\n  end\n  return result\nen","completion":""}
{"prompt":"-- calculate the hit number of recommend result\n-- :param origin: dict {user:[item,...]} the user click or behave items\n-- :param res: dict {user:[item,...]} the algorithm recommend result\n-- :return: int the number of res result in origin\nlocal function hits(origin, res)\n    local user_hit = {}\n    for user, items in pairs(origin) do\n        local hit = 0\n        for i, item in ipairs(items) do\n            if res[user][i] == item then\n                hit = hit + 1\n            end\n        end\n        user_hit[user] = hit\n    end\n    return user_hit\nen","completion":""}
{"prompt":"-- Linearly interpolate a value y given range y0...y1 that is proportional\n-- to x in range x0...x1 .\nlocal function lerp(x, x0, x1, y0, y1)\n  return y0 + (y1-y0)*(x-x0)\/(x1-x0)\nen","completion":""}
{"prompt":"-- Source: https:\/\/rosettacode.org\/wiki\/Chinese_remainder_theorem#Python\nlocal function _mul_inv(a, b)\n\tlocal b0 = b\n\tlocal x0 = 0\n\tlocal x1 = 1\n\tif b == 1 then return 1 end\n\twhile a > 1 do\n\t\tlocal q = a \/ b\n\t\tlocal q_int = math.floor(q)\n\t\ta, b = b, a % b\n\t\tx0, x1 = x1 - q_int * x0, x0\n\tend\n\tif x1 < 0 then x1 = x1 + b0 end\n\treturn x1\nen","completion":""}
{"prompt":"-- Computes the canonical residue of value mod modulus.\n-- Parameters:\n-- value (int): The value to compute the residue of\n-- modulus (int): The modulus used to calculate the residue\n-- Returns:\n-- An integer \"r\" between 0 and modulus - 1, where value - r is divisible\n-- by the modulus.\n-- Remarks:\n-- See the Q# source for the \"Modulus\" function at \n-- https:\/\/github.com\/Microsoft\/QuantumLibraries\/blob\/master\/Canon\/src\/Math\/Functions.qs\nlocal function get_modulus_residue(value, modulus)\n    return value - modulus * math.floor(value \/ modulus)\nen","completion":""}
{"prompt":"-- Ensure a 2D shape.\n-- Args:\n-- a: a int or tuple\/list of length 2\n-- Returns:\n-- list: of length 2. if ``a`` is a int, return ``[a, a]``.\nlocal function _shape2d(a)\n  if type(a) == \"number\" then\n    return { a, a }\n  elseif type(a) == \"table\" then\n    assert(#a == 2, \"Shape must be 2D\")\n    return { a[1], a[2] }\n  else\n    error(\"Shape must be a number or a table of length 2\")\n  end\nen","completion":""}
{"prompt":"-- _summary_\n-- Parameters:\n-- reduction_factor (int): _description_\n-- your_list (list): _description_\n-- Returns:\n-- reduced_list (_type_): _description_\nlocal function list_size_reducer(reduction_factor, your_list)\n\tlocal reduced_list = {}\n\tfor i = 1, #your_list, reduction_factor do\n\t\treduced_list[#reduced_list+1] = your_list[i]\n\tend\n\treturn reduced_list\nen","completion":""}
{"prompt":"-- Get nested key value of the configuration\n-- Args:\n-- conf (dict): mappings config dict\n-- keys (list): nested keys\n-- Returns:\n-- env_vars (dict): nested dict of env vars to be exported\nlocal function get_nested_key_vals(conf, keys)\n    local env_vars = {}\n    local key_vals = conf\n    for i = 1, #keys do\n        if type(key_vals) == \"table\" then\n            key_vals = key_vals[keys[i]]\n        end\n    end\n    return key_vals\nen","completion":""}
{"prompt":"-- Take a score -1, 0, or 1, and return the three vector of labels\nlocal function one_to_three(one)\n    if one == -1 then\n        return {1, 0, 0}\n    elseif one == 0 then\n        return {0, 1, 0}\n    elseif one == 1 then\n        return {0, 0, 1}\n    end\n    error(\"invalid one value\")\nen","completion":""}
{"prompt":"-- return a list of the last names of students with the major, thisMajor\n-- >>> majorToLNames(\"MATH\",[Student(\"MARY\",\"KAY\",\"MATH\"), Student(\"FRED\",\"CRUZ\",\"HISTORY\"), Student(\"CHRIS\",\"GAUCHO\",\"UNDEC\")])\n-- ['KAY']\n-- >>>\nlocal function majorToLNames(thisMajor, listOfStudents)\n  local names = {}\n  for i = 1, #listOfStudents do\n    if (thisMajor == listOfStudents[i].major) then\n      names[#names+1] = listOfStudents[i].lastName\n    end\n  end\n  return names\nen","completion":""}
{"prompt":"-- clamps a number to the minimum and maximum.\n-- :param v:\n-- :param minimum:\n-- :param maximum:\n-- :return:\nlocal function clamp(v, minimum, maximum)\n\treturn math.min(math.max(v, minimum), maximum)\nen","completion":""}
{"prompt":"-- Returns the trailing digit of `n`\nlocal function trailing_digit(n)\n  return n % 10\nen","completion":""}
{"prompt":"-- n: number of elements in the sequence\n-- Returns a Fibonacci sequence of n elements by iterative method\nlocal function build_fib_iterative(n)\n    local a, b = 0, 1\n    local fib = {}\n    for i = 1, n do\n        fib[i] = a\n        local tmp = a\n        a = b\n        b = tmp + b\n    end\n    return fib\nen","completion":""}
{"prompt":"-- Checks if the time of a segment overlaps with the times of existing segments.\n-- Arguments:\n-- segment_time -- a tuple of (segment_start, segment_end) for the new segment\n-- previous_segments -- a list of tuples of (segment_start, segment_end) for the existing segments\n-- Returns:\n-- True if the time segment overlaps with any of the existing segments, False otherwise\nlocal function is_overlapping(segment_time, previous_segments)\n  for _, prev in pairs(previous_segments) do\n    if (segment_time[1] <= prev[2] and segment_time[2] >= prev[1]) then\n      return true\n    end\n  end\n  return false\nen","completion":""}
{"prompt":"-- >>> _decode_feed_ids('123,456')\n-- [123, 456]\nlocal function _decode_feed_ids(option_feeds)\n\tlocal _feeds = {}\n\tfor i in string.gmatch(option_feeds, '(%d+)') do\n\t\ttable.insert(_feeds, tonumber(i))\n\tend\n\treturn _feeds\nen","completion":""}
{"prompt":"-- Linear mapping\n-- Parameters\n-- ----------\n-- x : float\n-- input value\n-- smi : float\n-- input range's minimum\n-- sma : float\n-- input range's maximum\n-- dmi : float\n-- input range's minimum\n-- dma :\n-- Returns\n-- -------\n-- _ : float\n-- mapped output\nlocal function linlin(x, smi, sma, dmi, dma)\n  return (x - smi) \/ (sma - smi) * (dma - dmi) + dmi\nen","completion":""}
{"prompt":"-- Counts how often word appears in file file_name.\n-- Example: if file contains \"one two one two three four\"\n-- and word is \"one\", then this function returns 2\nlocal function count_word_occurrence_in_file(file_name, word)\n    local count = 0\n    local file = io.open(file_name, \"r\")\n    if file then\n        local line = file:read(\"*line\")\n        while line do\n            if string.find(line, word) then\n                count = count + 1\n            end\n            line = file:read(\"*line\")\n        end\n        io.close(file)\n    end\n    return count\nen","completion":""}
{"prompt":"-- Given principal, compute equal coupon per period.\nlocal function p_to_equal_c(p, r, comp_period, n, adj)\n\treturn p * (1 + r\/comp_period) ^ n \/ math.pow((1 + r\/comp_period), n)\nen","completion":""}
{"prompt":"-- Return a dictionary mapping parent classes to the attributes inherited from \n-- those classes.\nlocal function find_inherited_attrs(cls)\n  if not cls then return {} end\n  local attrs = {}\n  local parents = cls:parents()\n  for _, p in ipairs(parents) do\n    for _, attr in ipairs(p:attributes()) do\n      if not attrs[attr] then\n        attrs[attr] = true\n      end\n    end\n  end\n  return attrs\nen","completion":""}
{"prompt":"-- calculate the inverse of a mod m\n-- that is, find b such that (a * b) % m == 1\nlocal function modinv(a, m)\n    local m0 = m\n    local y = 0\n    local x = 1\n    if (m == 1) then return 0 end\n    while (a > 1) do\n        local q = a \/\/ m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    end\n    if (x < 0) then x = x + m0 end\n    return x\nen","completion":""}
{"prompt":"-- perform math operation, by default addition\nlocal function show_math_result(a, b, show_lower)\n    local result = a\n    if show_lower then\n        result = string.lower(result)\n    end\n    if string.match(result, \"%d\") then\n        result = tonumber(result)\n    end\n    if b then\n        if string.match(b, \"%d\") then\n            b = tonumber(b)\n        end\n        result = result + b\n    end\n    return result\nen","completion":""}
{"prompt":"-- Convert percentage to absolute value 0..255.\nlocal function brightness_from_percentage(percent)\n  return 255 * percent \/ 100\nen","completion":""}
{"prompt":"-- Returns 1 if sentence contains question mark, 0 otherwise\nlocal function question_mark_finder(sentence)\n    local q = string.find(sentence, \"?\")\n    if q == nil then\n        return 0\n    end\n    return 1\nen","completion":""}
{"prompt":"-- Get the type of maze from folder\nlocal function get_habituation_folder(s)\n  if s == \"test\" then\n    return \"test\"\n  elseif s == \"test1\" then\n    return \"test1\"\n  elseif s == \"test2\" then\n    return \"test2\"\n  elseif s == \"test3\" then\n    return \"test3\"\n  elseif s == \"train\" then\n    return \"train\"\n  elseif s == \"train1\" then\n    return \"train1\"\n  elseif s == \"train2\" then\n    return \"train2\"\n  elseif s == \"train3\" then\n    return \"train3\"\n  elseif s == \"train4\" then\n    return \"train4\"\n  elseif s == \"train5\" then\n    return \"train5\"\n  elseif s == \"train6\" then\n    return \"train6\"\n  elseif s == \"train7\" then\n    return \"train7\"\n  elseif s == \"train8\" then\n    return \"train8\"\n  else\n    print(\"No habituation folder found\")\n    os.exit()\n  end\nen","completion":""}
{"prompt":"-- Converts a color from a 24-bit integer to a tuple.\n-- :param value: RGB LED desired value - can be a RGB tuple or a 24-bit integer.\nlocal function _color_to_tuple(value)\n  if type(value) == \"table\" then\n    if #value == 3 then\n      return { value[1], value[2], value[3] }\n    end\n  elseif type(value) == \"number\" then\n    return {\n      bit32.band(bit32.rshift(value, 16), 0xFF),\n      bit32.band(bit32.rshift(value, 8), 0xFF),\n      bit32.band(value, 0xFF),\n    }\n  end\nen","completion":""}
{"prompt":"-- Removes all non-digit characters from `string`.\n-- >>> numify('800-555-1212')\n-- '8005551212'\n-- >>> numify('800.555.1212')\n-- '8005551212'\nlocal function numify(string)\n  string = tostring(string)\n  return (string:gsub('[^%d]', ''))\nen","completion":""}
{"prompt":"-- Convert brightness from absolute 0..255 to percentage.\nlocal function brightness_to_percentage(byt)\n  local per = byt \/ 255 * 100\n  per = tonumber(string.format(\"%.0f\", per))\n  return per\nen","completion":""}
{"prompt":"-- Similar to string.replace() but is case insensitive\n-- Code borrowed from: http:\/\/forums.devshed.com\/python-programming-11\/case-insensitive-string-replace-490921.html\nlocal function replace_insensitive(string, target, replacement)\n\tstring = string or \"\"\n\tlocal first, rest = string.lower(string), string.lower(target)\n\tlocal index = string.find(first, rest, 1, true)\n\tif index == nil then return string end\n\treturn string.sub(string, 1, index - 1) .. replacement .. string.sub(string, index + string.len(rest))\nen","completion":""}
{"prompt":"-- Print results to stream\nlocal function print_worklists_to_stream(all_results, stream, error_level)\n    local error_level = error_level or 0\n    local function print_worklist_to_stream(worklist, stream)\n        local file_path = worklist.path\n        local line_number = worklist.line_number\n        local errors = worklist.errors\n        local error_count = 0\n        local function print_error(error)\n            if error.level <= error_level then\n                stream:write(string.format(\"%s:%d: %s\", file_path, line_number, error.message))\n                error_count = error_count + 1\n            end\n        end\n        local function print_errors(errors)\n            for _, error in ipairs(errors) do\n                print_error(error)\n            end\n        end\n        print_errors(errors)\n        local nested_worklists = worklist.nested_worklists\n        for _, nested_worklist in ipairs(nested_worklists) do\n            print_worklist_to_stream(nested_worklist, stream)\n        end\n        return error_count\n    end\n    local error_count = 0\n    for _, worklist in ipairs(all_results) do\n        error_count = error_count + print_worklist_to_stream(worklist, stream)\n    end\n    return error_count\nen","completion":""}
{"prompt":"-- >>> greatest_common_divisor(4, 8)\n-- 4\n-- >>> greatest_common_divisor(8, 4)\n-- 4\n-- >>> greatest_common_divisor(4, 7)\n-- 1\n-- >>> greatest_common_divisor(0, 10)\n-- 10\nlocal function greatest_common_divisor(a, b)\n  if a < b then\n    return greatest_common_divisor(b, a)\n  elseif b == 0 then\n    return a\n  else\n    return greatest_common_divisor(b, a % b)\n  end\nen","completion":""}
{"prompt":"-- Get the number of model expression nodes in an expression or list of expressions\n-- Args:\n-- expr:   Expression or list of expressions\n-- Returns:\n-- Total number of nodes\nlocal function get_node_count(expr)\n    local count = 0\n    if type(expr) == \"table\" then\n        for _, v in pairs(expr) do\n            count = count + get_node_count(v)\n        end\n    else\n        count = count + 1\n    end\n    return count\nen","completion":""}
{"prompt":"-- >>> fibo_r(0)\n-- 1\n-- >>> fibo_r(1)\n-- 1\n-- >>> fibo_r(2)\n-- 2\n-- >>> fibo_r(3)\n-- 3\n-- >>> fibo_r(4)\n-- 5\n-- >>> fibo_r(7)\n-- 21\nlocal function fibo_r(n)\n    if n < 2 then return 1 end\n    return fibo_r(n - 1) + fibo_r(n - 2)\nen","completion":""}
{"prompt":"-- :param hand_value: int - current hand value.\n-- :return: int - value of the upcoming ace card (either 1 or 11).\nlocal function value_of_ace(hand_value)\n    if hand_value <= 10 then\n        return 11\n    else\n        return 1\n    end\nen","completion":""}
{"prompt":"-- Handle converter type \"path\"\n-- :param args:\n-- :param kwargs:\n-- :return: return schema dict\nlocal function convert_path()\n  return {\n    type = \"string\",\n    format = \"path\",\n  }\nen","completion":""}
{"prompt":"-- Provides the basic categories of data\n-- - confirmed: Confirmed cases\n-- - deaths: Deaths\n-- - recovered: Recovered cases\n-- - active: Active cases (confirmed - deaths - recovered)\nlocal function get_categories()\n  return { \"confirmed\", \"deaths\", \"recovered\", \"active\" }\nen","completion":""}
{"prompt":"-- Decorates a set of data (as produced by `normalised_sheet`)\n-- with metadata. At this time, this only wraps the results in\n-- a `data` key\nlocal function add_metadata(data)\n\treturn {\n\t\tdata = data,\n\t\tmeta = metadata,\n\t}\nen","completion":""}
{"prompt":"-- If a string has single or double quotes around it, remove them.\n-- Make sure the pair of quotes match.\n-- If a matching pair of quotes is not found, return the string unchanged.\nlocal function dequote(s)\n  local q = string.sub(s, 1, 1)\n  if (q == '\"' or q == \"'\") then\n    if (string.sub(s, -1) == q) then\n      return string.sub(s, 2, -2)\n    end\n  end\n  return s\nen","completion":""}
{"prompt":"-- Strip strings, convert NaN and None to empty string\nlocal function strip(raw_input)\n    if raw_input == nil or type(raw_input) ~= \"string\" then\n        return \"\"\n    end\n    local strip_input = string.gsub(raw_input, \"^%s*(.-)%s*$\", \"%1\")\n    if string.lower(strip_input) == \"none\" or string.lower(strip_input) == \"nan\" then\n        return \"\"\n    end\n    return strip_input\nen","completion":""}
{"prompt":"-- >>> from .pycompat import bytechr as chr\n-- >>> d = {b'nl': chr(10), b'bs': chr(92), b'cr': chr(13), b'nul': chr(0)}\n-- >>> s = b\"ab%(nl)scd%(bs)s%(bs)sn%(nul)sab%(cr)scd%(bs)s%(nl)s\" % d\n-- >>> s\n-- 'ab\\ncd\\\\\\\\n\\x00ab\\rcd\\\\\\n'\n-- >>> res = _string_escape(s)\n-- >>> s == util.unescapestr(res)\n-- True\nlocal function _string_escape(text)\n    if not text or text == \"\" then return text end\n    local res = text\n    res = res:gsub('\\\\', '\\\\\\\\')\n    res = res:gsub('\\n', '\\\\n')\n    res = res:gsub('\\r', '\\\\r')\n    res = res:gsub('\\t', '\\\\t')\n    res = res:gsub('%b\"\"', function(t) return util.format('\\\\x%02X', t:byte(2)) end)\n    return res\nen","completion":""}
{"prompt":"-- Split a list of raw collections into a list of database\/collection tuples\n-- :param list[str] collections:\n-- :rtype: list[(str, str|None)]\nlocal function _resolve_collections(collections)\n    local results = {}\n    for _, collection in ipairs(collections) do\n        local database, collection_name = string.match(collection, \"^([^%.]+)%.(.+)$\")\n        if database then\n            results[#results + 1] = {database, collection_name}\n        else\n            results[#results + 1] = {collection, nil}\n        end\n    end\n    return results\nen","completion":""}
{"prompt":"-- Apply a polygon recoverer to input polygons in-place.\n-- Parameters\n-- ----------\n-- psois : list of imgaug.augmentables.polys.PolygonsOnImage or imgaug.augmentables.polys.PolygonsOnImage\n-- The possibly broken polygons, e.g. after augmentation.\n-- The `recoverer` is applied to them.\n-- psois_orig : list of imgaug.augmentables.polys.PolygonsOnImage or imgaug.augmentables.polys.PolygonsOnImage\n-- Original polygons that were later changed to `psois`.\n-- They are an extra input to `recoverer`.\n-- recoverer : imgaug.augmentables.polys._ConcavePolygonRecoverer\n-- The polygon recoverer used to repair broken input polygons.\n-- random_state : None or int or RNG or numpy.random.Generator or numpy.random.BitGenerator or numpy.random.SeedSequence or numpy.random.RandomState\n-- An RNG to use during the polygon recovery.\n-- Returns\n-- -------\n-- list of imgaug.augmentables.polys.PolygonsOnImage or imgaug.augmentables.polys.PolygonsOnImage\n-- List of repaired polygons. Note that this is `psois`, which was\n-- changed in-place.\nlocal function recover_psois_(psois, psois_orig, recoverer, random_state)\n    local psois_aug = psois\n    local psois_orig_aug = psois_orig\n    for i, psoi in ipairs(psois_aug) do\n        if psoi.is_valid then\n            local psoi_orig = psois_orig_aug[i]\n            psoi_orig.polygons = _ConcavePolygonRecoverer.recover_single_polygon(recoverer, psoi_orig.polygons, psoi.polygons, random_state)\n            psoi.polygons = psoi_orig.polygons\n        end\n    end\n    return psois_aug\nen","completion":""}
{"prompt":"-- Calculate the Nth Fibonacci Number.\nlocal function fibonacci(n, f0, f1)\n    f0 = f0 or 0\n    f1 = f1 or 1\n    if n == 0 then\n        return f0\n    elseif n == 1 then\n        return f1\n    end\n    return fibonacci(n - 1, f1, f0 + f1)\nen","completion":""}
{"prompt":"-- triangle_area\nlocal function trangle_area(a, b, c)\n    return 0.5 * ((a[1] - c[1]) * (b[2] - c[2]) - (a[2] - c[2]) * (b[1] - c[1]))\nen","completion":""}
{"prompt":"-- Go 1 unit in positive y-direction and 1 unit in negative x-direction\n-- :param x: x-coordinate of the node\n-- :param y: y-coordinate of the node\n-- :return: new coordinates of the node after moving diagonally up-left\nlocal function go_up_left(x, y)\n  return {x - 1, y + 1}\nen","completion":""}
{"prompt":"-- Convert a string representation of truth to true (1) or false (0).\n-- True values are 'y', 'yes', 't', 'true', 'on', and '1'; false values\n-- are 'n', 'no', 'f', 'false', 'off', and '0'.  Raises ValueError if\n-- 'val' is anything else.\nlocal function strtobool(val)\n\tif type(val) ~= \"string\" then\n\t\treturn val\n\tend\n\tval = string.lower(val)\n\tif val == \"y\" or val == \"yes\" or val == \"t\" or val == \"true\" or val == \"on\" or val == \"1\" then\n\t\treturn 1\n\telseif val == \"n\" or val == \"no\" or val == \"f\" or val == \"false\" or val == \"off\" or val == \"0\" then\n\t\treturn 0\n\telse\n\t\treturn nil, \"Invalid boolean value '\" .. val .. \"'\"\n\tend\nen","completion":""}
{"prompt":"-- Handle converter type \"float\"\n-- :param args:\n-- :param kwargs:\n-- :return: return schema dict\nlocal function convert_float()\n    return { type = \"number\", format = \"float\" }\nen","completion":""}
{"prompt":"-- Round value to next power of 2 value - max 16\nlocal function _round_pow_2(value)\n\tlocal rounded = 2^math.ceil(math.log(value)\/math.log(2))\n\tif rounded > 16 then return 16 end\n\treturn rounded\nen","completion":""}
{"prompt":"-- >>> cube(0)\n-- 0\n-- >>> cube(1)\n-- 1\n-- >>> cube(2)\n-- 8\nlocal function cube(a)\n  return a * a * a\nen","completion":""}
{"prompt":"-- Takes in two nonnegative numbers and return the multiplication result of the two numbers without using the multiplication operator *\n-- Examples:\n-- >>> RecMult(0,500)\n-- 0\n-- >>> RecMult(500,0)\n-- 0\n-- >>> RecMult(1,500)\n-- 500\n-- >>> RecMult(500,1)\n-- 500\n-- >>> RecMult(78,16)\n-- 1248\nlocal function RecMult(num_1, num_2)\n    if (num_1 == 0 or num_2 == 0) then\n        return 0\n    else\n        return num_1 + RecMult(num_1, num_2 - 1)\n    end\nen","completion":""}
{"prompt":"-- this should cover 2 cases\n-- eg, get `1`:\n-- http:\/\/www.mangapanda.com\/wild-life\/1\n-- http:\/\/www.mangapanda.com\/751-35090-1\/wild-life\/chapter-1.html\n-- problem:\n-- http:\/\/www.mangapanda.com\/wild-life\nlocal function get_chapter(link)\n    -- get chapter id: 1, 2, 10, ...\n    local chapter = (link:match(\"\/chapter%-(%d+)%.html$\") or link:match(\"\/(%d+)$\") or '1')\n    return chapter\nen","completion":""}
{"prompt":"-- Return command name by splitting up DExTer command contained in\n-- command_raw on the first opening paranthesis and further stripping\n-- any potential leading or trailing whitespace.\nlocal function _get_command_name(command_raw)\n   local command_name = command_raw:match('^[^(]+')\n   command_name = command_name:gsub('^%s*(.-)%s*$', '%1')\n   return command_name\nen","completion":""}
{"prompt":"-- This function is a fast way to calculate binomial coefficients, commonly\n-- known as nCk, i.e. the number of combinations of n things taken k at a time.\n-- (https:\/\/en.wikipedia.org\/wiki\/Binomial_coefficient).\n-- This is the *scipy.special.comb()* with long integer computation but this\n-- approximation is faster, see https:\/\/github.com\/nltk\/nltk\/issues\/1181\n-- >>> choose(4, 2)\n-- 6\n-- >>> choose(6, 2)\n-- 15\n-- :param n: The number of things.\n-- :type n: int\n-- :param r: The number of times a thing is taken.\n-- :type r: int\nlocal function choose(n, k)\n  if k < 0 or k > n then return 0 end\n  if k * 2 > n then k = n - k end\n  local ans = 1\n  for i=1,k do\n    ans = ans * (n-k+i)\/i\n  end\n  return ans\nen","completion":""}
{"prompt":"-- Info:\n-- Check if a number is even, if so return True if not return False\n-- Paramaters:\n-- number: int - The number to check if is even.\n-- Usage:\n-- is_even(number)\n-- Returns:\n-- bool\nlocal function is_even(number)\n    return (number % 2 == 0)\nen","completion":""}
{"prompt":"-- Read amount and species from settings file\nlocal function get_amount_and_variables(settings)\n  local species = settings.species\n  local amount = settings.amount\n  if species == nil then\n    print('Error: no species specified')\n    os.exit()\n  end\n  if amount == nil then\n    print('Error: no amount specified')\n    os.exit()\n  end\n  return amount, species\nen","completion":""}
{"prompt":"-- 1. number of times around loop is n\n-- 2. number of operations inside loop is a constant\n-- 3. overall just O(n)\n-- >>> fact_iter(5)\n-- 120\n-- >>> fact_iter(12)\n-- 479001600\n-- >>> fact_iter(10)\n-- 3628800\n-- >>> fact_iter(16)\n-- 20922789888000\n-- >>> fact_iter(4)\n-- 24\nlocal function fact_iter(n)\n  if n == 1 or n == 0 then\n    return 1\n  else\n    return n * fact_iter(n-1)\n  end\nen","completion":""}
{"prompt":"-- Takes in a list filepaths and removes any trailing \/'s\n-- :param arg: list of string file paths\n-- :return: list of filepaths with trailing \/'s removed\nlocal function __trimTrailingSlash__(args)\n  local res = {}\n  for _, v in ipairs(args) do\n    res[#res+1] = string.gsub(v, \"\/$\", \"\")\n  end\n  return res\nen","completion":""}
{"prompt":"-- Return first power of 2 >= n.\n-- >>> next_pow2(3)\n-- 4\n-- >>> next_pow2(8)\n-- 8\n-- >>> next_pow2(0)\n-- 1\n-- >>> next_pow2(1)\n-- 1\nlocal function next_pow2(n)\n    local m = 1\n    while m < n do\n        m = m * 2\n    end\n    return m\nen","completion":""}
{"prompt":"-- Calculate precision from tp and fp\nlocal function calc_precision(tp, fp)\n    if tp + fp == 0 then\n        return 0\n    end\n    return tp \/ (tp + fp)\nen","completion":""}
{"prompt":"-- ensure that values in a vector are below a ceiling\n-- Note this performs an operation in-place, i.e.\n-- the original vector will change\n-- :param a: vector, as an array or list\n-- :return: vector with some modified values\nlocal function ceiling_vec(a, c)\n   local i = 1\n   while i <= #a do\n      if a[i] > c then a[i] = c end\n      i = i + 1\n   end\n   return a\nen","completion":""}
{"prompt":"-- Returns the area of a rectangle\nlocal function rectangle_area(base, height)\n  return base * height\nen","completion":""}
{"prompt":"-- Return a tuple of symbols:\n-- ! # $ % & ( ) , + * - = . : ; ? @ [ ] ^ _\nlocal function init_symbols()\n   return { \"!\", \"#\", \"$\", \"%\", \"&\", \"(\", \")\",\n             \",\", \"+\", \"*\", \"-\", \"=\", \".\", \":\",\n             \";\", \"?\", \"@\", \"[\", \"]\", \"^\", \"_\",\n           }\nen","completion":""}
{"prompt":"-- GC content of a given sequence.\nlocal function gc_content(seq)\n\tlocal gc = 0\n\tfor base in seq:gmatch(\".\") do\n\t\tif base == \"G\" or base == \"C\" then gc = gc + 1 end\n\tend\n\treturn gc \/ #seq\nen","completion":""}
{"prompt":"-- Caluclate the Julian Century from Julian Day or Julian Ephemeris Day\nlocal function _julian_century(jd)\n    return (jd - 2451545.0) \/ 36525.0\nen","completion":""}
{"prompt":"-- Converts initial condition index (ci) and perturbation index (pi) subscripts\n-- to an instance number (ii)\n-- instances use 1-based indexes and vary according to this function:\n-- ii = ci * len(PERTURBATIONS) + pi + 1\n-- where both pi and ci use 0-based indexes.\nlocal function _sub2instance(initial_condition, perturbation_index, total_perturbations)\n    local instance_index = (initial_condition * total_perturbations) + perturbation_index + 1\n    return instance_index\nen","completion":""}
{"prompt":"-- Bound speed to the limits allowed by crickit motor.throttle\nlocal function boundMotorSpeed(speed)\n  return math.min(math.max(speed, -1), 1)\nen","completion":""}
{"prompt":"-- :param bin: index in the discretization\n-- :param num_bins: the total number of bins in the discretization\n-- :param limits: 2 x d ndarray, where row[0] is a row vector of the lower\n-- limit of each discrete dimension, and row[1] are corresponding upper\n-- limits.\n-- .. note::\n-- This is the inverse of state2bin function.\n-- Given an index ``bin``, the number of the bins ``num_bins``, and the limits\n-- on a single state dimension, this function returns the corresponding value\n-- in the middle of the bin (ie, the average of the discretizations around it)\nlocal function bin2state(bin, num_bins, limits)\n\treturn limits[1] + (limits[2] - limits[1]) * (bin + 0.5) \/ num_bins\nen","completion":""}
{"prompt":"-- Generation of a SPARQL Filter clause to exclude small molecules\n-- Produces something like\n-- FILTER( str(?controllerType) != \"http:\/\/www.biopax.org\/release\/biopax-level3.owl#SmallMolecule\")\nlocal function gen_small_mol_filter(skip_small_molecules, networktype)\n   if skip_small_molecules then\n      local res = 'FILTER( str(?controllerType) != \"'..networktype..'\/SmallMolecule\")'\n      return res\n   else\n      return ''\n   end\nen","completion":""}
{"prompt":"-- Adjust to (-180, 180]\nlocal function adjust_text_angle(text_angle)\n  if text_angle < -180 then\n    text_angle = text_angle + 360\n  elseif text_angle > 180 then\n    text_angle = text_angle - 360\n  end\n  return text_angle\nen","completion":""}
{"prompt":"-- (int) -> list\n-- Builds a list of factors for a positive integer <num>. \n-- Returns the list\nlocal function factors_singles(num)\n\tlocal factors = {}\n\tlocal i = 1\n\twhile (i * i <= num) do \n\t\tif (num % i == 0) then \n\t\t\tif (num \/ i == i) then \n\t\t\t\t-- perfect square\n\t\t\t\ttable.insert(factors, i)\n\t\t\telse \n\t\t\t\ttable.insert(factors, i)\n\t\t\t\ttable.insert(factors, num \/ i)\n\t\t\tend\n\t\tend\n\t\ti = i + 1\n\tend\n\ttable.sort(factors)\n\treturn factors\nen","completion":""}
{"prompt":"-- Check for a nonnegative integer argument; raise ``ValueError`` if not.\n-- (Directive option conversion function.)\nlocal function nonnegative_int(argument)\n  local n = tonumber(argument)\n  if n >= 0 then return n\n  else error(\"Value out of range\", 2) end\nen","completion":""}
{"prompt":"-- Return a string. The `line_number` is formatted as 3 digits\n-- number with a dot and a space preceding the `line`. The empty\n-- space before line number will be replaced by '0's.\n-- Example:\n-- >>> put_number(1, \"Hello World!\")\n-- '001. Hello World'\nlocal function put_number(line_number, line)\n    return string.format(\"%03d. %s\", line_number, line)\nen","completion":""}
{"prompt":"-- Switch string s from snake_form_naming to CamelCase\nlocal function snake2camel(s)\n    local parts = {}\n    for part in s:gmatch(\"[^_]+\") do\n        parts[#parts+1] = part:gsub(\"^%l\", string.upper)\n    end\n    return table.concat(parts)\nen","completion":""}
{"prompt":"-- Convert time in milliseconds to float seconds\n-- :type val: str or int\n-- :rtype: float\nlocal function str_ms2seconds(val)\n    val = tonumber(val)\n    if val == nil then return val end\n    return val \/ 1000.0\nen","completion":""}
{"prompt":"-- If type is string, return string in list\nlocal function _single_list_check_str(X)\n\tif type(X) == 'string' then\n\t\treturn {X}\n\telse\n\t\treturn X\n\tend\nen","completion":""}
{"prompt":"-- Predicts the points that a team would score by themselves.\n-- calculated_data is the data for a team that is calculated in the\n-- 'team_calculations()' function. Used to calculate the team's ability\n-- to complete each of the scoring objectives.\nlocal function calculate_predicted_solo_points(calculated_data)\n    local points = 0\n    for i = 1, #calculated_data do\n        local calculation = calculated_data[i]\n        if not calculation.ignored then\n            points = points + calculation.points\n        end\n    end\n    return points\nen","completion":""}
{"prompt":"-- Return the interval of recall classified to 11 equal intervals of 10 (the field range is 0-100)\nlocal function recall_interval(recall)\n\tlocal interval = math.floor(recall * 10)\n\treturn interval * 10\nen","completion":""}
{"prompt":"-- A sign function that won't return 0\nlocal function nonzero_sign(xy)\n    return (xy >= 0) and 1 or -1\nen","completion":""}
{"prompt":"-- Return a value clipped to the range [min_val, max_val].\nlocal function limit(value, min_val, max_val)\n  return math.max(min_val, math.min(value, max_val))\nen","completion":""}
{"prompt":"-- leave only digits\nlocal function onlydigits(s)\n  return s:gsub(\"%D+\",\"\")\nen","completion":""}
{"prompt":"-- Generates an empty board.\n-- >>> genBoard()\n-- [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\"]\nlocal function genBoard()\n  local t = {}\n  for i = 1, 9 do\n    t[i] = string.format(\"%c\", 65+i-1)\n  end\n  return t\nen","completion":""}
{"prompt":"-- Returns the area of a rhombus\nlocal function rhombus_area(diagonal_1, diagonal_2)\n  return diagonal_1 * diagonal_2 \/ 2\nen","completion":""}
{"prompt":"-- Calculate the number of pairs\nlocal function num_pairs(num_elements)\n    return num_elements * (num_elements - 1) \/ 2\nen","completion":""}
{"prompt":"-- returns the depth of the tree\n-- - count    -- 32 bit value\n-- eg: If any number between 9 and 16 is passed the function returns 4\nlocal function get_depth(count)\n  local bitdepth = 0\n  while count > 1 do\n    count = count \/ 2\n    bitdepth = bitdepth + 1\n  end\n  return bitdepth\nen","completion":""}
{"prompt":"-- Removes quotes around a value.\n-- Also strips the whitespace.\n-- >>> _remove_quotes('\"hello\"')\n-- 'hello'\n-- >>> _remove_quotes(\"'hello'\")\n-- 'hello'\n-- >>> _remove_quotes(\"hello\")\n-- 'hello'\nlocal function _remove_quotes(value)\n  local v = value:gsub('\"', '')\n  v = v:gsub(\"'\", \"\")\n  return v\nen","completion":""}
{"prompt":"-- Returns: Class name of encapsulating class or None\nlocal function is_inside_class()\n  local slineinfo = debug.getinfo(2, \"Sl\")\n  if slineinfo then\n    return slineinfo.what == \"main\" and slineinfo.short_src or nil\n  end\nen","completion":""}
{"prompt":"-- Return the number of set bits in a word.\n-- O(k) -- k is the number of set bits in a word (i.e. 2 if x = 0110)\nlocal function count_bits_better(x)\n\tlocal sum = 0\n\twhile x ~= 0 do\n\t\tx = x & (x - 1) --clears the least significant set bit in x\n\t\tsum = sum + 1\n\tend\n\treturn sum\nen","completion":""}
{"prompt":"-- escape Prolog meta characters\nlocal function prolog_escape(word)\n    if word == \"\" then return word end\n    local escaped = {}\n    local i = 1\n    while i <= #word do\n        local c = word:sub(i,i)\n        if c == \"%\" then\n            i = i + 1\n            local c = word:sub(i,i)\n            if c == \"t\" then\n                c = \"\\t\"\n            elseif c == \"n\" then\n                c = \"\\n\"\n            elseif c == \"r\" then\n                c = \"\\r\"\n            elseif c == \"v\" then\n                c = \"\\v\"\n            elseif c == \"f\" then\n                c = \"\\f\"\n            elseif c == \"a\" then\n                c = \"\\a\"\n            elseif c == \"b\" then\n                c = \"\\b\"\n            end\n        elseif c == \"\\\\\" then\n            c = \"\\\\\\\\\"\n        elseif c == \"'\" then\n            c = \"\\\\'\"\n        end\n        table.insert(escaped,c)\n        i = i + 1\n    end\n    return table.concat(escaped)\nen","completion":""}
{"prompt":"-- Return positive if p-q-r are clockwise, neg if ccw, zero if colinear.\nlocal function orientation(p, q, r)\n  local dx1, dy1 = q[1] - p[1], q[2] - p[2]\n  local dx2, dy2 = r[1] - p[1], r[2] - p[2]\n  return (dy1 * dx2) - (dy2 * dx1)\nen","completion":""}
{"prompt":"-- Recursive implementation\n-- :param n: nth number of series that we want to calculate\n-- :return: nth number of series\nlocal function fibonacci(n)\n    if n <= 2 then\n        return 1\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2)\n    end\nen","completion":""}
{"prompt":"-- estima la raiz cuadrada en 20 intervalos\nlocal function raizCuadrada(n)\n  return math.sqrt(n)\nen","completion":""}
{"prompt":"-- Remove html tags from a string\nlocal function remove_html_tags(text)\n\ttext = string.gsub(text, \"<.*>\", \"\")\n\ttext = string.gsub(text, \"%s\", \" \")\n\treturn text\nen","completion":""}
{"prompt":"-- transposed  data\n-- :param data: list\n-- :return: list\nlocal function trans_data(data)\n    local transposed_data = {}\n    for i=1,#data do\n        local row = data[i]\n        if #transposed_data == 0 then\n            for j=1,#row do\n                transposed_data[j] = {}\n            end\n        end\n        for j=1,#row do\n            transposed_data[j][i] = row[j]\n        end\n    end\n    return transposed_data\nen","completion":""}
{"prompt":"-- Returns as bit mask with bit_num set.\n-- :param bit_num: The bit number.\n-- :type bit_num: int\n-- :returns: int -- the bit mask\n-- :raises: RangeError\n-- >>> bin(pifacecommon.core.get_bit_mask(0))\n-- 1\n-- >>> pifacecommon.core.get_bit_mask(1)\n-- 2\n-- >>> bin(pifacecommon.core.get_bit_mask(3))\n-- '0b1000'\nlocal function get_bit_mask(bit_num)\n\treturn 2 ^ bit_num\nen","completion":""}
{"prompt":"-- Convert RGB to hex.\nlocal function color_float_to_hex(r, g, b)\n    r = r * 255\n    g = g * 255\n    b = b * 255\n    r = math.floor(r + 0.5)\n    g = math.floor(g + 0.5)\n    b = math.floor(b + 0.5)\n    r = r < 0 and 0 or r > 255 and 255 or r\n    g = g < 0 and 0 or g > 255 and 255 or g\n    b = b < 0 and 0 or b > 255 and 255 or b\n    return string.format(\"#%02x%02x%02x\", r, g, b)\nen","completion":""}
{"prompt":"-- Add slash to the end of string if needed.\nlocal function add_trailing_slash(value)\n  return value .. (value:sub(-1) == \"\/\" and \"\" or \"\/\")\nen","completion":""}
{"prompt":"-- Convert a 6-digit hexadecimal RGB number to an RGB tuple.\n-- Args:\n-- rgb (:obj:`int`): 6-digit hex number to convert to a tuple.\n-- Returns:\n-- Tuple[ :obj:`int`]: RGB tuple.\n-- Note:\n-- This function converts an int into a tuple of ints. To parse strings, check :obj:`~.parse.parse`.\nlocal function hex_to_rgb(rgb)\n\tlocal r = bit32.band(bit32.rshift(rgb, 16), 0xFF)\n\tlocal g = bit32.band(bit32.rshift(rgb, 8), 0xFF)\n\tlocal b = bit32.band(rgb, 0xFF)\n\treturn {r, g, b}\nen","completion":""}
{"prompt":"-- Return an anchor '#a-title' for a title 'A title'\nlocal function anchor(title)\n    local anchor_title = title:lower():gsub(\"%s+\", \"-\")\n    return \"#\" .. anchor_title\nen","completion":""}
{"prompt":"-- Calculates the markedness meassure of the supplied data, using the equation as per: http:\/\/www.flinders.edu.au\/science_engineering\/fms\/School-CSEM\/publications\/tech_reps-research_artfcts\/TRRA_2007.pdf (page 5)\n-- Markedness = PPV+NPV-1\n-- Input:\n-- PPV: Positive Prediction Value\n-- NPV: Negative Pediction Value\n-- Output:\n-- Markedness\nlocal function calculate_markedness(PPV, NPV)\n  return PPV+NPV-1\nen","completion":""}
{"prompt":"-- return 1 if True, else 0\nlocal function lt(a, b)\n  return a < b and 1 or 0\nen","completion":""}
{"prompt":"-- returns the average of the squares of a and b\n-- :param a: integer\n-- :param b: integer\n-- :return: average of a and b\nlocal function average_function(a, b)\n    return (a + b) \/ 2\nen","completion":""}
{"prompt":"-- Returns the area of a triangle\n-- Parameters\n-- ----------\n-- base : float\n-- length of the triangle's base\n-- height : function\n-- height of the triangle\n-- Returns\n-- -------\n-- area : float\n-- area of the triangle\nlocal function triangle_area(base, height)\n  return base * height \/ 2\nen","completion":""}
{"prompt":"-- Reset a bit at offset position\n-- :param value: value of integer where reset the bit\n-- :type value: int\n-- :param offset: bit offset (0 is lsb)\n-- :type offset: int\n-- :returns: value of integer with bit reset\n-- :rtype: int\nlocal function reset_bit(value, offset)\n  local mask = 1 << offset\n  value = value & ~mask\n  return value\nen","completion":""}
{"prompt":"-- Check that s is number\n-- If s is a number, returns it as a float. If not, returns s without modification.\n-- Inputs:\n-- s - An input string or number\n-- Outputs:\n-- value - Either float(s) or False if s cannot be cast to float\nlocal function get_number(s)\n  if tonumber(s) then\n    return tonumber(s)\n  end\n  return s\nen","completion":""}
{"prompt":"-- Bin the hours per week variable into 0-30, 31-40, 41-50, 50+ bins.\nlocal function bin_hours_per_week(hpw)\n  if hpw <= 30 then\n    return 0\n  elseif hpw <= 40 then\n    return 1\n  elseif hpw <= 50 then\n    return 2\n  else\n    return 3\n  end\nen","completion":""}
{"prompt":"-- specifically for 4x4 affine matrices\nlocal function mmult(m1, m2)\n    local m1r, m1c = #m1, #m1[1]\n    local m2r, m2c = #m2, #m2[1]\n    if m1r ~= m2c then error(\"Incompatible matrices for multiplication\") end\n    local result = {}\n    for i = 1, m1r do\n        local row = {}\n        for j = 1, m2c do\n            local sum = 0\n            for k = 1, m1c do sum = sum + m1[i][k] * m2[k][j] end\n            row[j] = sum\n        end\n        result[i] = row\n    end\n    return result\nen","completion":""}
{"prompt":"-- Determine the number of trailing b's in vector x.\n-- Parameters\n-- ----------\n-- b: int\n-- Integer for counting at tail of vector.\n-- x: array\n-- Vector of integers.\n-- Returns\n-- -------\n-- tail: int\n-- Number of trailing b's in x.\nlocal function tail(_b, _x)\n    assert(type(_b) == \"number\", \"tail: arg #1 must be a number\")\n    assert(type(_x) == \"table\", \"tail: arg #2 must be a table\")\n    -- Count b's at end of vector\n    local n_t = 0\n    for i = #_x, 1, -1 do\n        if (_x[i] == _b) then\n            n_t = n_t + 1\n        else\n            break\n        end\n    end\n    return n_t\nen","completion":""}
{"prompt":"-- A tail-recursive implementation which will run in constant space.\nlocal function tail_add(x, y)\n    if y == 0 then return x\n    else return tail_add(x + 1, y - 1)\n    end\nen","completion":""}
{"prompt":"-- The reflection coefficient\n-- Equation 8.15\n-- :param float transmission_coef_1: the transmission coefficients of the first layer\n-- :param float reflection_coef_1: the reflection coefficients of the first layer\n-- :param float reflection_coef_2: the reflection coefficients of the second layer\n-- :return: The reflection coefficient\nlocal function double_layer_cover_reflection_coefficient(transmission_coef_1, reflection_coef_1, reflection_coef_2)\n  return reflection_coef_1 + reflection_coef_2 * transmission_coef_1\nen","completion":""}
{"prompt":"-- quaternion addition\n-- :param quat1: first quaternion\n-- :param quat2: second quaternion\n-- :return: sum of the two quaternions; q_out = quat1 + quat2\nlocal function qadd(quat1, quat2)\n\tlocal out = {0, 0, 0, 0}\n\tout[1] = quat1[1] + quat2[1]\n\tout[2] = quat1[2] + quat2[2]\n\tout[3] = quat1[3] + quat2[3]\n\tout[4] = quat1[4] + quat2[4]\n\treturn out\nen","completion":""}
{"prompt":"-- box area\n-- :param a:\n-- :return:\nlocal function bboxArea(a)\n\tlocal x0 = a[1]\n\tlocal y0 = a[2]\n\tlocal x1 = a[3]\n\tlocal y1 = a[4]\n\treturn (x1 - x0) * (y1 - y0)\nen","completion":""}
{"prompt":"-- Sets positive rewards to +1 and negative rewards to -1.\n-- Args:\n-- rew: A scalar reward signal.\n-- Returns:\n-- +1. if the scalar is positive, -1. if is negative and 0 otherwise.\nlocal function reward_clipping(rew)\n  if rew < 0 then\n    return -1\n  elseif rew > 0 then\n    return 1\n  end\n  return 0\nen","completion":""}
{"prompt":"-- Get maximum value in a list of lists.\n-- :param ll: 2D list\n-- :return: max value in the 2D list\nlocal function maxval_of_2dlist(ll)\n   local mv = 0\n   for i,v in ipairs(ll) do\n      for j,w in ipairs(v) do\n         if w > mv then\n            mv = w\n         end\n      end\n   end\n   return mv\nen","completion":""}
{"prompt":"-- Create an ordinal from a number.\nlocal function make_ordinal(n)\n\tlocal suffix = \"th\"\n\tif n % 10 == 1 and n % 100 ~= 11 then suffix = \"st\"\n\telseif n % 10 == 2 and n % 100 ~= 12 then suffix = \"nd\"\n\telseif n % 10 == 3 and n % 100 ~= 13 then suffix = \"rd\" end\n\treturn tostring(n) .. suffix\nen","completion":""}
{"prompt":"-- Removes double slashes in URLs, and ensures the protocol is doubleslahed\nlocal function fixSlashes(url)\n\turl = string.gsub(url, \"([^:])\/\/+\", \"%1\/\")\n\tif string.match(url, \"^\/\/\") then\n\t\turl = \"http:\" .. url\n\tend\n\treturn url\nen","completion":""}
{"prompt":"-- Return the n'th number of the fabonacci sequence\nlocal function fabonacci(n)\n\tif (n == 0) then\n\t\treturn 0;\n\telseif (n == 1) then\n\t\treturn 1;\n\telse\n\t\treturn fabonacci(n - 1) + fabonacci(n - 2);\n\tend\nen","completion":""}
{"prompt":"-- From the given list of numbers, find the group of 3 numbers that sum up to 2020. \n-- This function returns the product of those 3 numbers.\nlocal function product_of_3(numbers)\n    for i = 1, #numbers do\n        for j = i + 1, #numbers do\n            for k = j + 1, #numbers do\n                if (numbers[i] + numbers[j] + numbers[k] == 2020) then\n                    return numbers[i] * numbers[j] * numbers[k]\n                end\n            end\n        end\n    end\nen","completion":""}
{"prompt":"-- Replace the built-in round function to achieve accurate rounding with 2 decimal places\n-- :param value:object\n-- :return:object\nlocal function round_up(value)\n  if value % 1 >= 0.5 then\n    return math.floor(value) + 1\n  else\n    return math.floor(value)\n  end\nen","completion":""}
{"prompt":"-- Fake function for pytest\nlocal function arg_process(number)\n    return number + 1\nen","completion":""}
{"prompt":"-- Encodes ampersand, greater and lower characters in a given string to HTML-entities.\nlocal function encode_to_xml(text)\n    return string.gsub(text, \"([<>&])\", { [\"<\"] = \"&lt;\", [\">\"] = \"&gt;\", [\"&\"] = \"&amp;\" })\nen","completion":""}
{"prompt":"-- Last letter.\n-- Params: s (string) \n-- Returns: (string) last letter of s\nlocal function lastLetter(s)\n   return s:sub(-1)\nen","completion":""}
{"prompt":"-- Take the old file and append it piecemeal to a new list.\n-- This function checks that the old element exists, that the\n-- word and the next word don't match, and that the item doesn't\n-- start with an :kbd:`!`. These are words that are considered\n-- incorrect and can be safely ignored.\n-- Parameters\n-- ----------\n-- wordlist : list\n-- List of correct words.\n-- Returns\n-- -------\n-- new_wordlist : list\n-- Filtered list of words.\nlocal function fix_spellfile(wordlist)\n  local new_wordlist = {}\n  local old_wordlist = {}\n  local old_line\n  for _, word in ipairs(wordlist) do\n    if word:match(\"^%:\") then\n      if old_wordlist[#old_wordlist] ~= nil then\n        new_wordlist[#new_wordlist+1] = old_wordlist[#old_wordlist]\n        old_wordlist[#old_wordlist] = nil\n      end\n    else\n      old_wordlist[#old_wordlist+1] = word\n    end\n  end\n  return new_wordlist\nen","completion":""}
{"prompt":"-- Computes the nth triangle number.\nlocal function triangle(n)\n    return math.floor(n * (n + 1) \/ 2)\nen","completion":""}
{"prompt":"-- Calculate a checksum for the specified data and register, simply by XORing each byte in turn with the current value\n-- of the checksum. The value is initialised to be the register, then each byte of the data array is used in turn. This\n-- is intended to inter-operate with the code on the Arduino, it's not a particularly generic checksum routine and\n-- won't work with arbitrary I2C devices.\n-- :param int register:\n-- The register to which we're sending the data. This is used because the first part of the data transaction\n-- is actually the register, we want to calculate the checksum including the register part.\n-- :param int[] data:\n-- The data array to use\n-- :return:\n-- A checksum, this should be appended onto the data sent to the Arduino\nlocal function compute_checksum(register, data)\n  local checksum = register\n  for _, byte in pairs(data) do\n    checksum = checksum ~ byte\n  end\n  return checksum\nen","completion":""}
{"prompt":"-- Gets fuel from mass.\n-- Args:\n-- mass (int): mass for the fuel\n-- Returns:\n-- int: fuel necessary for the mass\nlocal function get_fuel_from(mass)\n  return math.floor(mass \/ 3) - 2\nen","completion":""}
{"prompt":"-- applies a list of case changes to a message; assumes input message all lowercase \n-- note: ASCII\nlocal function restore_cases(lower_message, cases)\n\tlocal message = lower_message\n\tfor _, case in pairs(cases) do\n\t\tif case == 0 then -- lower\n\t\t\tmessage = message:lower()\n\t\telseif case == 1 then -- upper\n\t\t\tmessage = message:upper()\n\t\telseif case == 2 then -- title\n\t\t\tmessage = message:title()\n\t\tend\n\tend\n\treturn message\nen","completion":""}
{"prompt":"-- Funcion que nos permite intecarlar 2 listas solamente \n-- si se garantiza que ambas listas tengana la misma longitud\n-- @param listaTiempo list\n-- @param listaDecisiones list\n-- @param listaDecisiones listaJugador\nlocal function juntarTiempoConDecision(listaTiempo, listaDecisiones, listaJugador)\n    local listaTiempoJugador = {}\n    for i, t in ipairs(listaTiempo) do\n        table.insert(listaTiempoJugador, t)\n        table.insert(listaTiempoJugador, listaDecisiones[i])\n        table.insert(listaTiempoJugador, listaJugador[i])\n    end\n    return listaTiempoJugador\nen","completion":""}
{"prompt":"-- Takes a number n and returns n + n-2 + n-4 + n-6 + ... + 0.\n-- >>> skip_add(5)  # 5 + 3 + 1 + 0\n-- 9\n-- >>> skip_add(10) # 10 + 8 + 6 + 4 + 2 + 0\n-- 30\n-- >>> # Do not use while\/for loops!\n-- >>> from construct_check import check\n-- >>> # ban iteration\n-- >>> check(this_file, 'skip_add',\n-- ...       ['While', 'For'])\n-- True\nlocal function skip_add(n)\n  local sum = 0\n  for i = n, 0, -2 do\n    sum = sum + i\n  end\n  return sum\nen","completion":""}
{"prompt":"-- prepossess sentence, all as lower characters and remove special chars\n-- :param str sentence:\n-- :return [str]:\n-- >>> s = 'Hi there, how are you?'\n-- >>> sentence_tokenize(s)\n-- ['hi', 'there', 'how', 'are', 'you']\nlocal function sentence_tokenize(sentence, spec_chars)\n  local special_chars = spec_chars or {\"\\n\", \"\\r\", \" \", \"\\t\", \".\", \",\", \";\", \":\", \"?\", \"!\"};\n  local tokens = {};\n  for w in string.gmatch(string.lower(sentence), \"[^\" .. table.concat(special_chars, \"\") .. \"]+\") do\n    table.insert(tokens, w);\n  end\n  return tokens;\nen","completion":""}
{"prompt":"-- Given a list of dictionaries, it returns the first dictionary that\n-- contains the given key, and the item for that key.\n-- :param list_of_dictionaries: list(dict())\n-- :param key: key of dictionary wanted\n-- :return: contents of list(dict[key])\nlocal function get_item(list_of_dictionaries, key)\n  for _, dictionary in pairs(list_of_dictionaries) do\n    if dictionary[key] then\n      return dictionary[key]\n    end\n  end\n  return nil\nen","completion":""}
{"prompt":"-- Compute the binomial coefficient 'n choose k'.\n-- n: number of trials\n-- k: number of successes\nlocal function binomial_coeff(n, k)\n    if (k > n) then\n        return 0\n    elseif (k == 0 or k == n) then\n        return 1\n    elseif (k == 1 or k == n - 1) then\n        return n\n    else\n        return binomial_coeff(n - 1, k - 1) + binomial_coeff(n - 1, k)\n    end\nen","completion":""}
{"prompt":"-- Use the Sieve of Eratosthenes to find all the primes from 2 up to a given number.\n-- A simple, ancient algorithm for finding all prime numbers up to any given limit.\n-- It does so by iteratively marking as composite (i.e. not prime) the multiples of each prime,\n-- starting with the multiples of 2. It does not use any division or remainder operation.\n-- The algorithm consists of repeating the following over and over:\n-- - take the next available unmarked number in your list (it is prime)\n-- - mark all the multiples of that number (they are not prime)\n-- Repeat until you have processed each number in your range.\n-- :param limit int - the limit to find primes up to.\n-- :return list - list of prime numbers.\nlocal function primes(limit)\n    local sieve = {}\n    for n=2, limit do\n        sieve[n] = true\n    end\n    for n=2,limit do\n        if sieve[n] then\n            for m=n*n,limit,n do\n                sieve[m] = false\n            end\n        end\n    end\n    local primes = {}\n    for n=2,limit do\n        if sieve[n] then\n            table.insert(primes, n)\n        end\n    end\n    return primes\nen","completion":""}
{"prompt":"-- Retrieve the size of each block_layer in the ResNet model.\nlocal function _get_block_sizes(resnet_size)\n    local block_sizes = {\n        [18] = {2, 2, 2, 2},\n        [34] = {3, 4, 6, 3},\n        [50] = {3, 4, 6, 3},\n        [101] = {3, 4, 23, 3},\n        [152] = {3, 8, 36, 3},\n        [200] = {3, 24, 36, 3},\n        [269] = {3, 30, 48, 8}\n    }\n    assert(block_sizes[resnet_size],\n        'invalid resnet_size: ' .. tostring(resnet_size))\n    return block_sizes[resnet_size]\nen","completion":""}
{"prompt":"-- returns the longest common substring from the beginning of sa and sb\nlocal function common_start(sa, sb)\n    local result = \"\"\n    for i = 1, #sa do\n        if sa:sub(i, i) == sb:sub(i, i) then\n            result = result .. sa:sub(i, i)\n        else\n            return result\n        end\n    end\n    return result\nen","completion":""}
{"prompt":"-- Transform Python False, True into false, true\n-- >>> get_javascript_value(True)\n-- true\n-- >>> get_javascript_value(10)\n-- 10\nlocal function get_lowcase_bool(value)\n  if value == false then\n    return \"false\"\n  elseif value == true then\n    return \"true\"\n  else\n    return value\n  end\nen","completion":""}
{"prompt":"-- 3D curved surface function\nlocal function smooth_surface(data, a, b, c)\n\treturn data[a] + (data[b] - data[a]) * c + (data[c] - data[a]) * c * c \/ 2\nen","completion":""}
{"prompt":"-- Removes duplicates from l, where l is a List of Lists.\n-- :param l: a List\nlocal function remove_duplicates(l)\n  local seen = {}\n  local out = {}\n  for _, item in ipairs(l) do\n    local item_type = type(item)\n    if item_type == \"table\" then\n      local key = table.concat(item, \"|\")\n      if not seen[key] then\n        table.insert(out, item)\n        seen[key] = true\n      end\n    else\n      if not seen[item] then\n        table.insert(out, item)\n        seen[item] = true\n      end\n    end\n  end\n  return out\nen","completion":""}
{"prompt":"-- Replace specific characters with another character\n-- using multiple string replace operations.\nlocal function multiple_str_repl(text, repl_chars)\n    local n = #text\n    for i=1, n do\n        local ch = string.sub(text, i, i)\n        local repl_ch = repl_chars[ch]\n        if repl_ch ~= nil then\n            text = string.sub(text, 1, i-1)..repl_ch..string.sub(text, i+1, n)\n        end\n    end\n    return text\nen","completion":""}
{"prompt":"-- Remove surrounding single or double quotes\n-- >>> print strip_quotes('hello')\n-- hello\n-- >>> print strip_quotes('\"hello\"')\n-- hello\n-- >>> print strip_quotes(\"'hello'\")\n-- hello\n-- >>> print strip_quotes(\"'hello\")\n-- 'hello\nlocal function strip_quotes(s)\n    return (string.gsub(s, \"^%s*([\\\"'])(.-)%1%s*$\", \"%2\"))\nen","completion":""}
{"prompt":"-- Creates a raster for one axis each\n-- Parameters:\n-- steps (int): amount of parts the axis shall be split into\n-- steps_size (int): average pixel size for each step\n-- step_rest (int): amount of pixels which are added in last iteration\n-- Returns:\n-- list: [step_start_coordinate, step_end_coordinate]\nlocal function createRasterPreset(steps, step_size, step_rest)\n    local current = 0\n    local result = {}\n    for i=1, steps do\n        local start = current\n        local end_ = current + step_size\n        local end__ = math.ceil(end_ - step_rest)\n        local step = {start, end__}\n        result[i] = step\n        current = end__\n    end\n    return result\nen","completion":""}
{"prompt":"-- Accepts one integer and prints its factorial (recursive)\nlocal function factorial(a)\n   if a <= 1 then return 1\n   else return a * factorial(a - 1) end\nen","completion":""}
{"prompt":"-- Parse cookie data into key-value pairs\nlocal function parse_cookie_data(data)\n  local pairs = {}\n  for pair in data:gmatch(\"([^;]+)\") do\n    local key, value = pair:match(\"([^=]+)=(.*)\")\n    if key then\n      pairs[key:match(\"^%s*(.-)%s*$\")] = value:match(\"^%s*(.-)%s*$\")\n    end\n  end\n  return pairs\nen","completion":""}
{"prompt":"-- Convert the given HASS light level (0-255) to Loxone (0.0-100.0).\nlocal function hass_to_lox(level)\n  local l = math.floor(level \/ 2.55)\n  return math.min(100.0, math.max(0.0, l))\nen","completion":""}
{"prompt":"-- Set a bit at offset position\n-- :param value: value of integer where set the bit\n-- :type value: int\n-- :param offset: bit offset (0 is lsb)\n-- :type offset: int\n-- :returns: value of integer with bit set\n-- :rtype: int\nlocal function set_bit(value, offset)\n\tlocal bit = 2 ^ offset\n\treturn value | bit\nen","completion":""}
{"prompt":"-- Converts the GitHub Link header to a dict:\n-- Example::\n-- >>> link2dict('<https:\/\/api.github.com\/repos\/sympy\/sympy\/pulls?page=2&state=closed>; rel=\"next\", <https:\/\/api.github.com\/repos\/sympy\/sympy\/pulls?page=21&state=closed>; rel=\"last\"')\n-- {'last': 'https:\/\/api.github.com\/repos\/sympy\/sympy\/pulls?page=21&state=closed', 'next': 'https:\/\/api.github.com\/repos\/sympy\/sympy\/pulls?page=2&state=closed'}\nlocal function link2dict(l)\n    local ret = {}\n    for l in l:gmatch('([^,]+)') do\n        ret[l:match('rel=\"([^\"]+)\"')] = l:match('<(.*)>;%s*rel=\"([^\"]+)\"')\n    end\n    return ret\nen","completion":""}
{"prompt":"-- Go through source, extracting every key\/value pair where the key starts\n-- with the given prefix.\nlocal function get_stripped_prefix(source, prefix)\n  local result = {}\n  for k, v in pairs(source) do\n    if k:sub(1, #prefix) == prefix then\n      result[k:sub(#prefix + 1)] = v\n    end\n  end\n  return result\nen","completion":""}
{"prompt":"-- Normalizing data to a new range (e.g. to [-1, 1] or [1, 1])\n-- :param original_array:   input array\n-- :param original_min: current minimum (array, can be derived from a larger sample)\n-- :param original_max: current max (array, can be derived from a larger sample)\n-- :param new_min: new minimum (float)\n-- :param new_max: new maximum (float)\n-- :return: normalized array\nlocal function normalize_range(original_array, original_min, original_max, new_min, new_max)\n\tlocal normalized_array = original_array\n\tif original_min ~= original_max then\n\t\tnormalized_array = normalized_array - original_min\n\t\tnormalized_array = normalized_array \/ (original_max - original_min)\n\t\tnormalized_array = normalized_array * (new_max - new_min)\n\t\tnormalized_array = normalized_array + new_min\n\tend\n\treturn normalized_array\nen","completion":""}
{"prompt":"-- Returns a cleaned list from the provided header string.\nlocal function _get_filter_list(filter_header)\n\tlocal list = {}\n\tif filter_header then\n\t\tfor filter in filter_header:gmatch('([^,]+)') do\n\t\t\tlist[#list + 1] = filter:match('^%s*(.-)%s*$') -- trim the filter\n\t\tend\n\tend\n\treturn list\nen","completion":""}
{"prompt":"-- Checks j >= min\n-- If false, returns j mod min\n-- Else j\nlocal function check_min_range(j, min)\n  if (j < min) then\n    return j % min\n  else\n    return j\n  end\nen","completion":""}
{"prompt":"-- Return integer one (dummy method for equally weighting).\nlocal function equal_weight(x, y)\n    return 1\nen","completion":""}
{"prompt":"-- ! @brief Converts a list of lists to a single list.\nlocal function flatten_args(args)\n  local flat_args = {}\n  for _, arg in ipairs(args) do\n    for _, subarg in ipairs(arg) do\n      table.insert(flat_args, subarg)\n    end\n  end\n  return flat_args\nen","completion":""}
{"prompt":"-- Compute moduli of a 3x3 matrix.\n-- Parameters\n-- ----------\n-- A : 'list' ['float']\n-- 3x3 matrix.\n-- m : 'float'\n-- modulus.\n-- Returns\n-- -------\n-- res : 'list' ['float']\n-- 3x3 matrix.\nlocal function mat33_mod(A, m)\n    local res = {\n        {A[1][1] % m, A[1][2] % m, A[1][3] % m},\n        {A[2][1] % m, A[2][2] % m, A[2][3] % m},\n        {A[3][1] % m, A[3][2] % m, A[3][3] % m}\n    }\n    return res\nen","completion":""}
{"prompt":"-- >>> [fuel(i) for i in [12,14,1969,100756]]\n-- [2, 2, 654, 33583]\nlocal function fuel(i)\n  return math.floor(i \/ 3) - 2\nen","completion":""}
{"prompt":"-- Optimized dynamic programming algorithm for\n-- counting the length of the longest increasing subsequence\n-- using segment tree data structure to achieve better complexity\n-- type sequence: list[int]\n-- rtype: int\nlocal function longest_increasing_subsequence_optimized2(sequence)\n  local size = #sequence\n  if size <= 1 then\n    return size\n  end\n  local max = 1\n  local tree = make_segment_tree(sequence, size, max)\n  local left = 1\n  local right = size\n  while left < right do\n    local mid = (left + right) \/\/ 2\n    if tree[mid].max > max then\n      max = tree[mid].max\n      left = mid + 1\n    else\n      right = mid\n    end\n  end\n  return max\nen","completion":""}
{"prompt":"-- Replace an empty string or None with a space.\nlocal function replace_empty(s)\n  return s and (s:gsub(\"^$\", \" \")) or \" \"\nen","completion":""}
{"prompt":"-- Return input_value if valid, raise an exception in other case.\nlocal function positive_integer(input_value)\n\tlocal value = tonumber(input_value)\n\tif value == nil then\n\t\terror('Expected a number', 3)\n\telseif value < 0 then\n\t\terror('Expected a positive number', 3)\n\tend\n\treturn value\nen","completion":""}
{"prompt":"-- checks answer against guess. returns the number of turns remaining\nlocal function check_answer(guess, answer, turns)\n\tturns = turns - 1\n\tguess = tonumber(guess)\n\tanswer = tonumber(answer)\n\t\n\tlocal correct = guess == answer\n\tlocal response = string.format(\"The answer is %d\", answer)\n\t\n\tif correct then\n\t\tresponse = string.format(\"Correct! You win! %d turns remaining!\", turns)\n\telseif turns > 0 then\n\t\tresponse = string.format(\"Incorrect! %d turns remaining...\", turns)\n\telse\n\t\tresponse = string.format(\"Incorrect! You lost! The correct answer was %d\", answer)\n\tend\n\t\n\treturn turns, response\nen","completion":""}
{"prompt":"-- If given a non-list, encapsulate in a single-element list.\nlocal function listify(item)\n\tif type(item) == \"table\" then\n\t\treturn item\n\tend\n\treturn { item }\nen","completion":""}
{"prompt":"-- Returns ``(s, d, w)`` with unique ``(s, d)`` values and `w` minimized.\n-- :param E:       a set of edges\n-- :type E:        [(int, int, float)]\n-- :return:        a subset of edges `E`\n-- :rtype:         [(int, int, float), ...]\nlocal function remove_multiedges(E)\n    local R = {}\n    local M = {}\n    for _, e in ipairs(E) do\n        if not M[e[1]] then\n            M[e[1]] = {}\n        end\n        if not M[e[1]][e[2]] then\n            M[e[1]][e[2]] = true\n            table.insert(R, e)\n        end\n    end\n    return R\nen","completion":""}
{"prompt":"-- The validators used in the proxy contract. This replaces the\n-- fixture with the same name from conftest.py\nlocal function proxy_validators(all_proxy_validators, number_of_validators)\n  local validators = {}\n  local validators_to_add = all_proxy_validators\n  for i = 1, number_of_validators do\n    table.insert(validators, validators_to_add[i])\n  end\n  return validators\nen","completion":""}
{"prompt":"-- Escape the special characters that are used by Slack\n-- in their messaging API.\n-- See `Slack API docs <https:\/\/api.slack.com\/reference\/surfaces\/formatting#escaping>`_.\n-- Args:\n-- raw (str): String to be escaped\n-- Returns:\n-- (str) String with problematic escape strings\nlocal function escape_slack_characters(raw)\n    return raw:gsub('&', '&amp;'):gsub('<', '&lt;'):gsub('>', '&gt;')\nen","completion":""}
{"prompt":"-- Return an integer with the bit at 'offset' cleared.\nlocal function clear_bit(int_type, offset)\n    local mask = 2 ^ offset\n    return int_type & ~mask\nen","completion":""}
{"prompt":"-- sum values from 1 to nn\nlocal function sumof(nn)\n   local sum = 0\n   for i = 1, nn do\n      sum = sum + i\n   end\n   return sum\nen","completion":""}
{"prompt":"-- Computes the number of spherical functions for a given angular momentum.\n-- Parameters\n-- ----------\n-- L : int\n-- The input angular momentum\n-- Returns\n-- -------\n-- nspherical : int\n-- The number of spherical functions\nlocal function nspherical(L)\n    return 2 * L + 1\nen","completion":""}
{"prompt":"-- For example: if n = 4321, return 4+3+2+1\nlocal function sum_digits_of_integer(num)\n  local sum = 0\n  while num > 0 do\n    sum = sum + num % 10\n    num = math.floor(num \/ 10)\n  end\n  return sum\nen","completion":""}
{"prompt":"-- :type s: str\n-- :rtype: int\nlocal function lengthOfLongestSubstring(s)\n  local map = {}\n  local max = 0\n  local start = 1\n  for i = 1, #s do\n    if map[s:sub(i, i)] ~= nil then\n      start = math.max(map[s:sub(i, i)] + 1, start)\n    end\n    map[s:sub(i, i)] = i\n    max = math.max(max, i - start + 1)\n  end\n  return max\nen","completion":""}
{"prompt":"-- Gives the sum of all the positive numbers before input number\nlocal function sumNumber(num)\n    local sum = 0\n    for i = 1, num do\n        if i <= num then\n            sum = sum + i\n        end\n    end\n    return sum\nen","completion":""}
{"prompt":"-- Function that takes a list, each of whose entries is a list\n-- containing two entries, and assembles two separate lists, one\n-- for each of these entries\nlocal function splitOneListIntoTwo(inputList)\n  local outputLists = { { }, { } }\n  for i, row in ipairs(inputList) do\n    outputLists[1][i] = row[1]\n    outputLists[2][i] = row[2]\n  end\n  return outputLists\nen","completion":""}
{"prompt":"-- Return the inner_echo function.\nlocal function echo(n)\n    return function(s)\n        return string.rep(s, n)\n    end\nen","completion":""}
{"prompt":"-- Get number of active users, using https:\/\/api.slack.com\/methods\/users.getPresence\nlocal function get_nb_active_users(sc, response)\n  local nb_active_users = 0\n  local res = response.result\n  if res then\n    for k, v in pairs(res) do\n      if v.presence == 'active' then\n        nb_active_users = nb_active_users + 1\n      end\n    end\n  end\n  return nb_active_users\nen","completion":""}
{"prompt":"-- Attempt to extract config[heading][key], with error handling.\n-- This function wraps config access with a try-catch to print out informative\n-- error messages and then exit.\nlocal function try_config(config, heading, key)\n  local status, value = pcall(function() return config[heading][key] end)\n  if not status then\n    local msg = string.format(\n      'Error: Missing required config: %s.%s',\n      heading,\n      key)\n    error(msg)\n  end\n  return value\nen","completion":""}
{"prompt":"-- Multiply rotation matrix by a vector.\nlocal function apply_rot_to_vec(rot, vec, unstack)\n    local x, y, z = vec[1], vec[2], vec[3]\n    if unstack then\n        return {\n            rot[1][1]*x + rot[2][1]*y + rot[3][1]*z,\n            rot[1][2]*x + rot[2][2]*y + rot[3][2]*z,\n            rot[1][3]*x + rot[2][3]*y + rot[3][3]*z\n        }\n    else\n        return {\n            x*rot[1][1] + y*rot[1][2] + z*rot[1][3],\n            x*rot[2][1] + y*rot[2][2] + z*rot[2][3],\n            x*rot[3][1] + y*rot[3][2] + z*rot[3][3]\n        }\n    end\nen","completion":""}
{"prompt":"-- >>> add_scheme_if_missing(\"example.com\/foo\")\n-- 'http:\/\/example.com\/foo'\n-- >>> add_scheme_if_missing(\"https:\/\/example.com\/foo\")\n-- 'https:\/\/example.com\/foo'\n-- >>> add_scheme_if_missing(\"\/\/example.com\/foo\")\n-- 'http:\/\/example.com\/foo'\nlocal function add_scheme_if_missing(url)\n  if string.sub(url, 1, 1) == \"\/\" then\n    url = \"http:\" .. url\n  end\n  if string.sub(url, 1, 7) == \"http:\/\/\" or string.sub(url, 1, 8) == \"https:\/\/\" then\n    return url\n  end\n  return \"http:\/\/\" .. url\nen","completion":""}
{"prompt":"-- Sort by last name, uniquely.\nlocal function sort_by_name(names)\n\ttable.sort(names, function(a, b)\n\t\tlocal a_last_name = string.match(a, \"^%w+\")\n\t\tlocal b_last_name = string.match(b, \"^%w+\")\n\t\treturn a_last_name < b_last_name\n\tend)\n\treturn names\nen","completion":""}
{"prompt":"-- Convert a string facing to a vector2d.\n-- Parameter\n-- ---------\n-- vector: vector2d to convert in facing (tuple(int, int)).\n-- Return\n-- ------\n-- facing: facing <up|down|left|right|up-left|up-right|down-left|down-right>(str).\n-- Version\n-- -------\n-- Specification: Nicolas Van Bossuyt (v1. 18\/04\/17)\n-- Implementation: Nicolas Van Bossuyt (v1. 18\/04\/17)\nlocal function vector2d_to_facing(vector)\n  if vector[2] == 0 then\n    if vector[1] == 0 then return \"none\"\n    elseif vector[1] > 0 then return \"right\"\n    else return \"left\"\n    end\n  elseif vector[1] == 0 then\n    if vector[2] > 0 then return \"up\"\n    else return \"down\"\n    end\n  else\n    if vector[1] > 0 and vector[2] > 0 then return \"up-right\"\n    elseif vector[1] > 0 and vector[2] < 0 then return \"down-right\"\n    elseif vector[1] < 0 and vector[2] < 0 then return \"down-left\"\n    else return \"up-left\"\n    end\n  end\nen","completion":""}
{"prompt":"-- Counts with a for loop and a dict.\nlocal function count_characters_one(string)\n    local counts = {}\n    for i = 1, #string do\n        local c = string:sub(i, i)\n        if counts[c] then\n            counts[c] = counts[c] + 1\n        else\n            counts[c] = 1\n        end\n    end\n    return counts\nen","completion":""}
{"prompt":"-- Returns the dominant color with the greater frequency\n-- Example: num_dominating = [paper, paper, paper, spock, spock, spock, spock, spock]\n-- Returns: spock\nlocal function most_freq(neighbors)\n   local counts = {}\n   local max = 0\n   local max_color\n   for _, n in pairs(neighbors) do\n      if counts[n] == nil then\n         counts[n] = 0\n      end\n      counts[n] = counts[n] + 1\n      if counts[n] > max then\n         max = counts[n]\n         max_color = n\n      end\n   end\n   return max_color\nen","completion":""}
{"prompt":"-- Return the maximum integer that has at most ``x`` digits:\n-- >>> max_digits(4)\n-- 9999\n-- >>> max_digits(0)\n-- 0\nlocal function max_digits(x)\n  local r = 1\n  for i = 1, x do r = r * 10 end\n  return r - 1\nen","completion":""}
{"prompt":"-- Kronecker's delta\nlocal function dl(Jp, J)\n    if Jp ~= J then\n        return 0\n    end\n    return 1\nen","completion":""}
{"prompt":"-- This is the function used to calculate the dot     product between two vectors, which will be used as     numerator for angle calculation\nlocal function dotproduct(point1, point2)\n  local result = 0\n  for i = 1, #point1 do\n    result = result + point1[i] * point2[i]\n  end\n  return result\nen","completion":""}
{"prompt":"-- Deep merge dicts\n-- >>> a = { 'first' : { 'all_rows' : { 'pass' : 'dog', 'number' : '1' } } }\n-- >>> b = { 'first' : { 'all_rows' : { 'fail' : 'cat', 'number' : '5' } } }\n-- >>> merge(b, a) == { 'first' : { 'all_rows' : {\n-- >>>     'pass' : 'dog', 'fail' : 'cat', 'number' : '5'\n-- >>> } } }\n-- True\nlocal function deep_merge_dicts(source, destination)\n    for k,v in pairs(source) do\n        if type(v) == \"table\" and type(destination[k] or false) == \"table\" then\n            destination[k] = deep_merge_dicts(v, destination[k] or {})\n        else\n            destination[k] = v\n        end\n    end\n    return destination\nen","completion":""}
{"prompt":"-- Return a list of n Fibonacci element\n-- :param n: number of list element\n-- :return: a list\nlocal function fibonacci_list(n)\n\tif n <= 0 then return {} end\n\tif n == 1 then return {0} end\n\tif n == 2 then return {0, 1} end\n\tlocal l = {0, 1}\n\tlocal index = 3\n\twhile index <= n do\n\t\tlocal item = l[index-2] + l[index-1]\n\t\ttable.insert(l, item)\n\t\tindex = index + 1\n\tend\n\treturn l\nen","completion":""}
{"prompt":"-- Returns ENUM names from vtype. E.g. i64 -> NLS_I64.\nlocal function enumize(text)\n  local name = text:gsub('%w', function(c)\n    return string.upper(c)\n  end)\n  return 'NLS_'..name\nen","completion":""}
{"prompt":"-- Normalizes an index per sequence indexing.\n-- >>> normalize_index(0, 10)\n-- 0\n-- >>> normalize_index(9, 10)\n-- 9\n-- >>> normalize_index(-2, 10)\n-- 8\nlocal function normalize_index(index, length)\n  if index < 0 then\n    index = index + length\n  end\n  return index\nen","completion":""}
{"prompt":"-- Get Patsy formula string that has the first order terms for the variables\n-- that range from start_i to end_i (inclusive).\n-- >>> get_linear_formula(4, 9)\n-- 'x4 + x5 + x6 + x7 + x8 + x9'\nlocal function get_linear_formula(start_i, end_i)\n    local linear_formula = ''\n    for i = start_i, end_i do\n        linear_formula = linear_formula .. ' + x' .. tostring(i)\n    end\n    return linear_formula:sub(4)\nen","completion":""}
{"prompt":"-- Reverse complement function\nlocal function revcomp(s)\n  local t = string.gsub(s, '[acgtACGT]', {\n    ['a'] = 't'; ['c'] = 'g'; ['g'] = 'c'; ['t'] = 'a';\n    ['A'] = 'T'; ['C'] = 'G'; ['G'] = 'C'; ['T'] = 'A';\n  })\n  return string.reverse(t)\nen","completion":""}
{"prompt":"-- Return the mth fibonacci number using Pascal's triangle.\nlocal function fib_from_pascal(m)\n\tif m < 0 then return 0 end\n\tif m == 0 then return 0 end\n\tif m == 1 then return 1 end\n\treturn (fib_from_pascal(m-1) + fib_from_pascal(m-2))\nen","completion":""}
{"prompt":"-- If value is between low and high, return value.\n-- If value is below low, return low.\n-- If value is above high, return high.\n-- If low is below high, raise an exception.\nlocal function bound(low, value, high)\n\tif (value < low) then return low end\n\tif (value > high) then return high end\n\treturn value\nen","completion":""}
{"prompt":"-- Get the pos value\nlocal function get_pos_value(my_pos, dict_tagset)\n    -- Get pos of word\n    local my_pos_value = dict_tagset[my_pos]\n    if not my_pos_value then\n        return 0\n    else\n        return my_pos_value\n    end\nen","completion":""}
{"prompt":"-- Find the number of digits in a number.\n-- abs() is used for negative numbers\n-- >>> num_digits_faster(12345)\n-- 5\n-- >>> num_digits_faster(123)\n-- 3\n-- >>> num_digits_faster(0)\n-- 1\n-- >>> num_digits_faster(-1)\n-- 1\n-- >>> num_digits_faster(-123456)\n-- 6\nlocal function num_digits_faster(n)\n  if n < 0 then\n    n = -n\n  end\n  return string.len(tostring(n))\nen","completion":""}
{"prompt":"-- Return values as percentage\n-- Arguments:\n-- num (float): number to express as percentage\n-- denom (float): denominator\n-- Returns:\n-- Float: value expressed as a percentage.\nlocal function percent(num, denom)\n\tif denom == 0 then\n\t\treturn 0\n\telse\n\t\treturn num \/ denom * 100\n\tend\nen","completion":""}
{"prompt":"-- Remove the .git suffix from a URL.\nlocal function remove_dot_git(text)\n\tif string.sub(text,-4) == \".git\" then\n\t\treturn string.sub(text,1,-5)\n\telse\n\t\treturn text\n\tend\nen","completion":""}
{"prompt":"-- :param float n: 0-1\n-- :return: Tweened value\nlocal function ease_in_out_quartic(n)\n    if n <= 0.5 then\n        return 8*n*n*n*n\n    else\n        n = n - 1\n        return 1-8*(n*n*n*n)\n    end\nen","completion":""}
{"prompt":"-- Turn a list of lists sideways, making columns into rows and vice-versa.\n-- ``array`` must be rectangular; i.e., all elements must be the same \n-- length. Otherwise the behavior is undefined: you may get ``IndexError``\n-- or missing items.\n-- Examples::\n-- >>> transpose([[\"A\", \"B\", \"C\"], [\"D\", \"E\", \"F\"]])\n-- [['A', 'D'], ['B', 'E'], ['C', 'F']]\n-- >>> transpose([[\"A\", \"B\"], [\"C\", \"D\"], [\"E\", \"F\"]])\n-- [['A', 'C', 'E'], ['B', 'D', 'F']]\n-- >>> transpose([])\n-- []\n-- Here's a pictoral view of the first example::\n-- A B C    =>    A D\n-- D E F          B E\n-- C F\n-- This can be used to turn an HTML table into a group of div columns. An HTML\n-- table is row major: it consists of several <tr> rows, each containing\n-- several <td> cells.  But a <div> layout consists of only one row, each\n-- containing an entire subarray. The <div>s have style \"float:left\", which\n-- makes them appear horizontally. The items within each <div> are placed in\n-- their own <div>'s or separated by <br \/>, which makes them appear\n-- vertically.  The point is that an HTML table is row major (``array[0]`` is\n-- the first row), while a group of div columns is column major (``array[0]``\n-- is the first column). ``transpose()`` can be used to switch between the\n-- two.\nlocal function transpose(array)\n   local n = #array\n   if n == 0 then return array end\n   local m = #array[1]\n   local r = {}\n   for i=1,m do\n      local c = {}\n      for j=1,n do\n         c[j] = array[j][i]\n      end\n      r[i] = c\n   end\n   return r\nen","completion":""}
{"prompt":"-- Return cross product (a X b)\n-- Parameters\n-- ----------\n-- a : 3-element list of floats\n-- first set of values in cross-product calculation\n-- b : 3-element list of floats\n-- second set of values in cross-product calculation\n-- Returns\n-- -------\n-- c :  3-element list of floats\n-- result of cross-product calculation\nlocal function crossproduct(a, b)\n\tlocal c = {0, 0, 0}\n\tc[1] = a[2] * b[3] - a[3] * b[2]\n\tc[2] = a[3] * b[1] - a[1] * b[3]\n\tc[3] = a[1] * b[2] - a[2] * b[1]\n\treturn c\nen","completion":""}
{"prompt":"-- Return the Fibonacci number with index n. n starts from 1. \n-- For example: \n-- fibo(1) -> 1\n-- fibo(2) -> 1\n-- fibo(3) -> 2\n-- fibo(4) -> 3\n-- fibo(5) -> 5\n-- Parameters\n-- ---------\n-- n : int \n-- The index of Fibonacci number (starts from 1). \n-- Returns\n-- -------\n-- int \n-- The Fibonacci number of index n.\nlocal function fibo(n)\n    if n == 1 then\n        return 1\n    elseif n == 2 then\n        return 1\n    else\n        return fibo(n - 1) + fibo(n - 2)\n    end\nen","completion":""}
{"prompt":"-- To avoid dividing by zero\n-- :param nm: Nominator\n-- :param dm: Dominator\n-- :return: Float\nlocal function safe_divide(nm, dm)\n  return (dm ~= 0) and nm \/ dm or 0\nen","completion":""}
{"prompt":"-- Normalized a value given max and min\nlocal function get_normalized(x, xmax, xmin)\n    return (x - xmin) \/ (xmax - xmin)\nen","completion":""}
{"prompt":"-- Enclose a reading within a container, e.g. '[]'.\nlocal function _enclose_readings(container, readings)\n  return string.format('%s%s%s', container[1], readings, container[2])\nen","completion":""}
{"prompt":"-- returns the temperature in degrees Fahrenheit\nlocal function fahrenheit(T_in_celsius)\n    return T_in_celsius * 9 \/ 5 + 32\nen","completion":""}
{"prompt":"-- Returns first multiple of num >= above\nlocal function _first_multiple_of(num, above)\n\treturn math.ceil(above \/ num) * num\nen","completion":""}
{"prompt":"-- Converts a list of references into a string\nlocal function lrefs_to_srefs(refs)\n  if type(refs) == 'string' then\n    return refs\n  elseif type(refs) == 'table' then\n    local result = {}\n    for _, r in ipairs(refs) do\n      if type(r) == 'string' then\n        table.insert(result, r)\n      elseif type(r) == 'table' and r.ref then\n        table.insert(result, r.ref)\n      end\n    end\n    return table.concat(result, ',')\n  end\n  return ''\nen","completion":""}
{"prompt":"-- Calculate the recursive fuel needed to launch a mass of fuel.\nlocal function calculate_recursive_fuel(fuel_mass)\n    local fuel_needed = 0\n    while fuel_mass > 0 do\n        local fuel = math.floor(fuel_mass \/ 3) - 2\n        if fuel <= 0 then\n            break\n        end\n        fuel_mass = fuel\n        fuel_needed = fuel_needed + fuel\n    end\n    return fuel_needed\nen","completion":""}
{"prompt":"-- Takes a string and removes multiple blank lines\nlocal function remove_multiple_blank_lines(instring)\n    local outstring = \"\"\n    local first = true\n    for line in instring:gmatch(\"[^\\r\\n]+\") do\n        if first then\n            outstring = line\n            first = false\n        else\n            if line ~= \"\" then\n                outstring = outstring..\"\\n\"..line\n            end\n        end\n    end\n    return outstring\nen","completion":""}
{"prompt":"-- Convierte una lista de ciudades en un string separado por ->\nlocal function formatear_camino(pila)\n    local camino = \"\"\n    for i, ciudad in pairs(pila) do\n        if i == 1 then\n            camino = camino .. ciudad\n        else\n            camino = camino .. \" -> \" .. ciudad\n        end\n    end\n    return camino\nen","completion":""}
{"prompt":"-- Escape any dash or dots in a characteristics name.\nlocal function escape_characteristic_name(char_name)\n  return char_name:gsub(\"[%-\\\\.]\", \"_\")\nen","completion":""}
{"prompt":"-- Subtracts corresponding elements of 2 vectors\nlocal function vector_subtract(vect1, vect2)\n    local new_vect = {}\n    for i = 1, #vect1 do\n        new_vect[i] = vect1[i] - vect2[i]\n    end\n    return new_vect\nen","completion":""}
{"prompt":"-- NMT length re-ranking score from\n-- \"Google's Neural Machine Translation System\" :cite:`wu2016google`.\nlocal function length_wu(length, logprobs, alpha)\n  -- This score is also known as length normalization.\n  -- See https:\/\/arxiv.org\/pdf\/1609.08144.pdf\n  local length_penalty = 1.0\n  if length < 0 then\n    length_penalty = math.pow((1 + length) \/ 6, alpha)\n  end\n  -- Return the result.\n  return logprobs \/ length_penalty\nen","completion":""}
{"prompt":"-- >>> calc_fuel(12)\n-- 2\n-- >>> calc_fuel(14)\n-- 2\n-- >>> calc_fuel(1969)\n-- 654\n-- >>> calc_fuel(100756)\n-- 33583\nlocal function calc_fuel(mass)\n    return math.floor(mass \/ 3) - 2\nen","completion":""}
{"prompt":"-- Escape all elements of 'args' that need escaping.\n-- 'args' may be any sequence and is not modified by this function.\n-- Return a new list where every element that needs escaping has\n-- been escaped.\n-- An element needs escaping when it starts with two ASCII hyphens\n-- ('--'). Escaping consists in prepending an element composed of\n-- two ASCII hyphens, i.e., the string '--'.\nlocal function _dash_escape(args)\n  local ret = {}\n  for _, s in ipairs(args) do\n    if type(s) == \"string\" and string.sub(s,1,2) == '--' then\n      ret[#ret+1] = \"--\"\n      ret[#ret+1] = s\n    else\n      ret[#ret+1] = s\n    end\n  end\n  return ret\nen","completion":""}
{"prompt":"-- Entran dos numeros para verificar si es el cuadrado del primero, si es mayor o menos que la misma operacion\n-- num -> string\n-- :param num1: Primer numero\n-- :param num2: Segundo numero\n-- :return: Mensaje se verificacion\n-- >>> cuadrado_primero(2,4)\n-- 'Segundo cuadrado del primero'\n-- >>> cuadrado_primero(2,3)\n-- 'Segundo es menor al cuadrado del primero'\n-- >>> cuadrado_primero(2,5)\n-- 'Segundo es mayor al cuadrado del primero'\n-- >>> cuadrado_primero(-2,4)\n-- 'Segundo cuadrado del primero'\n-- >>> cuadrado_primero('q',3)\n-- Traceback (most recent call last):\n-- ..\n-- TypeError: No es valido\n-- >>> cuadrado_primero(3,'i')\n-- Traceback (most recent call last):\n-- ..\n-- TypeError: No es valido\nlocal function cuadrado_primero(num1, num2)\n  -- Verifica que sea un numero\n  if type(num1) ~= 'number' or type(num2) ~= 'number' then\n    error(\"No es valido\")\n  end\n  -- Verifica si el segundo numero es cuadrado del primero\n  if num1 * num1 == num2 then\n    return \"Segundo cuadrado del primero\"\n  elseif num1 * num1 > num2 then\n    return \"Segundo es menor al cuadrado del primero\"\n  else\n    return \"Segundo es mayor al cuadrado del primero\"\n  end\nen","completion":""}
{"prompt":"-- Parses the summary string from vvtest output, such as\n-- Summary: pass=0, fail=1, diff=0, timeout=0, notdone=0, notrun=1, skip=0\n-- Returns dictionary of these names to their values.\nlocal function parse_summary_string(summary_string)\n    local summary = {}\n    for name, value in string.gmatch(summary_string, \"(%w+)=(%d+)\") do\n        summary[name] = tonumber(value)\n    end\n    return summary\nen","completion":""}
{"prompt":"-- Sets the low byte of a 16 bit (or longer) target value (*not* a little endian word!) to lo_byte\nlocal function set_low_byte(target, lo_byte)\n  return bit32.bor(bit32.band(target, 0xff00), bit32.band(lo_byte, 0xff))\nen","completion":""}
{"prompt":"-- Shortest distance between `a` and `b` in the modular integers base `base`.\n-- The smallest distance between a and b is returned.\n-- Example: mod_abs_diff(1, 99, 100) ==> 2. It is not 98.\n-- mod_abs_diff is symmetric, i.e. `a` and `b` are interchangeable.\n-- Args:\n-- a: First argument. An int.\n-- b: Seconds argument. An int.\n-- base: The modulo base. A positive int.\n-- Returns:\n-- Shortest distance.\nlocal function mod_abs_diff(a, b, base)\n    local mod_a = a % base\n    local mod_b = b % base\n    local diff = math.abs(mod_a - mod_b)\n    return diff > (base \/ 2) and (base - diff) or diff\nen","completion":""}
{"prompt":"-- :type x: int\n-- :rtype: int\nlocal function reverse(x)\n    local min = -2147483648\n    local max = 2147483647\n    local result = 0\n    local sign = 1\n    if x < 0 then\n        sign = -1\n        x = -x\n    end\n    while x > 0 do\n        result = result * 10 + x % 10\n        if result < min or result > max then\n            return 0\n        end\n        x = math.floor(x \/ 10)\n    end\n    return sign * result\nen","completion":""}
{"prompt":"-- Takes an index and converts it to a string containing a-z, ie.\n-- 0 -> 'a'\n-- 1 -> 'b'\n-- .\n-- .\n-- .\n-- 27 -> 'aa'\n-- 28 -> 'ab'\nlocal function get_character_bullet(index)\n    local first = math.floor(index \/ 26)\n    local second = index % 26\n    local second_char = string.char(97 + second)\n    if first == 0 then\n        return second_char\n    else\n        local first_char = string.char(97 + first - 1)\n        return first_char .. second_char\n    end\nen","completion":""}
{"prompt":"-- Compute an inverse for x modulo p, assuming that x\n-- is not divisible by p.\nlocal function inv_mod_p(x, p)\n  if x % p == 0 then return nil, \"cannot invert 0\" end\n  local x0, x1 = x, p\n  local t0, t1 = 1, 0\n  while x1 > 0 do\n    local q = x0 \/\/ x1\n    x0, x1 = x1, x0 - q * x1\n    t0, t1 = t1, t0 - q * t1\n  end\n  t0 = t0 % p\n  if t0 < 0 then t0 = t0 + p end\n  return t0\nen","completion":""}
{"prompt":"-- Readwise pluralize\nlocal function pluralize(input)\n  return (input == 1 and \"\" or \"s\")\nen","completion":""}
{"prompt":"-- Escapes text to use as plain text in a markdown document\n-- :param text: the original text\n-- :return: the escaped text\nlocal function escape_for_markdown(text)\n    text = text:gsub(\"([`*~_%[%]%(%)#%-])\", \"\\\\%1\")\n    return text\nen","completion":""}
{"prompt":"-- Convert the list of minutes ranges to a list of hour ranges.\n-- >>> convert_int_minutes_to_militar_time_format([[540, 600], [720, 780]])\n-- [['9:00', '10:00'], ['12:00', '13:00']]\nlocal function convert_int_minutes_to_militar_time_format(list)\n    local converted_list = {}\n    for _, minute_range in pairs(list) do\n        local start_time = math.floor(minute_range[1]\/60) .. \":\" .. string.format(\"%02d\", minute_range[1]%60)\n        local end_time = math.floor(minute_range[2]\/60) .. \":\" .. string.format(\"%02d\", minute_range[2]%60)\n        table.insert(converted_list, {start_time, end_time})\n    end\n    return converted_list\nen","completion":""}
{"prompt":"-- Determine the next integer that is 2 raised to some power.\n-- :param x: Number which you would like to find the next power of 2 for\n-- :return: x: Number which is 2 raised to some power\nlocal function next_power_2(x)\n\tlocal p = 1\n\twhile x > p do\n\t\tp = p * 2\n\tend\n\treturn p\nen","completion":""}
{"prompt":"-- Renvoie l'indice de l'element dans la liste, -1 s'il n'est pas dedans.\nlocal function indice(element, liste)\n  local index = 0\n  for _,value in pairs(liste) do\n    if value == element then\n      return index\n    end\n    index = index + 1\n  end\n  return -1\nen","completion":""}
{"prompt":"-- Translates a pair of board indices to a move on a board. For example: (0,0) ==> {'Row':A,'Column':1}\n-- :param row: 1st index\n-- :param column: 2nd index\n-- :return: dict of the row and column.\nlocal function translate_coord_to_move(row, column)\n    local letter = string.char(row + 65)\n    return { Row = letter, Column = column + 1 }\nen","completion":""}
{"prompt":"-- Gets timeout based on backoff_factor\n-- :param backoff_factor: value of backoff factor\n-- :param number_of_retries: current number of retries made\n-- Examples:\n-- >>> __backoff_factor, __number_of_retries = 0.1, 1\n-- >>> timeout = get_timeout(__backoff_factor, __number_of_retries)\n-- >>> assert timeout == 0.1\n-- >>>\n-- >>> __backoff_factor, __number_of_retries = 0.1, 2\n-- >>> timeout = get_timeout(__backoff_factor, __number_of_retries)\n-- >>> assert timeout == 0.2\nlocal function get_timeout(backoff_factor, number_of_retries)\n  return backoff_factor * 2 ^ (number_of_retries - 1)\nen","completion":""}
{"prompt":"-- Returns left, bottom, right and top coordinate values\nlocal function __bounding_box(p1, p2)\n\treturn {\n\t\tmath.min(p1[1], p2[1]),\n\t\tmath.min(p1[2], p2[2]),\n\t\tmath.max(p1[1], p2[1]),\n\t\tmath.max(p1[2], p2[2])\n\t}\nen","completion":""}
{"prompt":"-- converts a standard rgb set from a 0-255 range to 0-1\nlocal function rgb_2_plt_tuple(r, g, b)\n\treturn {r\/255, g\/255, b\/255}\nen","completion":""}
{"prompt":"-- calculates the commonality function for a given degree of bisection (i) at\n-- orders of seperation (j) which a specific level of aggregation.\n-- i: number of bisections\n-- j: order of seperation\n-- n0: abundance\n-- psi: aggregation parameter {0, 1}\n-- Note: Function has only been checked at psi = .5, more testing is needed here\nlocal function chi_bisect(i, j, n0, psi, chi_dict)\n    if chi_dict ~= nil then\n        local chi = chi_dict[i][j]\n        if chi ~= nil then\n            return chi\n        else\n            local chi = 0\n            if psi == 0 then\n                chi = (n0 + j)\/(2*n0)\n                chi = chi^i\n            elseif psi == 1 then\n                chi = 0.5*(n0 + j)\/(2*n0)\n                chi = (1 - chi^i)^2\n            end\n            chi_dict[i][j] = chi\n            return chi\n        end\n    else\n        local chi = 0\n        if psi == 0 then\n            chi = (n0 + j)\/(2*n0)\n            chi = chi^i\n        elseif psi == 1 then\n            chi = 0.5*(n0 + j)\/(2*n0)\n            chi = (1 - chi^i)^2\n        end\n        return chi\n    end\nen","completion":""}
{"prompt":"-- 'x,x,x'string to list\nlocal function listr(s)\n    local t = {}\n    for i in s:gmatch(\"%w+\") do\n        table.insert(t, i)\n    end\n    return t\nen","completion":""}
{"prompt":"-- Total array size of Wigner D matrix\n-- Assuming an array (e.g., Wigner D matrices) in the order\n-- [[ell,mp,m] for ell in range(ell_min, ell_max+1)\n-- for mp in range(-ell,ell+1)\n-- for m in range(-ell,ell+1)]\n-- this function returns the total size of that array.\n-- This can be calculated in sympy as\n-- from sympy import symbols, summation\n-- ell,ell_min,ell_max = symbols('ell,ell_min,ell_max', integer=True)\n-- summation((2*ell + 1)**2, (ell, ell_min, ell_max))\nlocal function LMpM_total_size(ell_min, ell_max)\n   local n = 0\n   for ell = ell_min, ell_max do\n      for mp = -ell,ell do\n         for m = -ell,ell do\n            n = n + 1\n         end\n      end\n   end\n   return n\nen","completion":""}
{"prompt":"-- Determine whether the boot partition \/boot is mounted or not\nlocal function __is_bootdir_mounted()\n  local is_mounted = false\n  local line\n  for line in io.lines(\"\/proc\/mounts\") do\n    if string.find(line, \"on \/boot type\") then\n      is_mounted = true\n      break\n    end\n  end\n  return is_mounted\nen","completion":""}
{"prompt":"-- Hackerrank Problem: https:\/\/www.hackerrank.com\/challenges\/chocolate-feast\/problem\n-- Function that calculates how many chocolates Bobby can purchase and eat.  Problem stated below:\n-- Little Bobby loves chocolate. He frequently goes to his favorite 5&10 store, Penny Auntie, to buy them. They are\n-- having a promotion at Penny Auntie. If Bobby saves enough wrappers, he can turn them in for a free chocolate.\n-- For example, Bobby has n = 15 to spend on bars of chocolate that cost c = 3 each. He can turn in m = 2 wrappers to\n-- receive another bar. Initially, he buys 5 bars and has 5 wrappers after eating them. He turns in 4 of them, leaving\n-- him with 1, for 2 more bars. After eating those two, he has 3 wrappers, turns in 2 leaving him with 1 wrapper and\n-- his new bar. Once he eats that one, he has 2 wrappers and turns them in for another bar. After eating that one, he\n-- only has 1 wrapper, and his feast ends. Overall, he has eaten 5 + 2 + 1 + 1 = 9 bars.\n-- Args:\n-- n (int): Int representing Bobby's initial amount of money\n-- c (int): Int representing the cost of a chocolate bar\n-- m (int): Int representing the number of wrappers he can turn in for a free bar\n-- Returns:\n-- int: The number of chocolate bars Bobby can purchase and eat\nlocal function chocolate_feast(n, c, m)\n    local wrappers = n \/ c\n    local chocolates = wrappers\n    \n    while wrappers >= m do\n        wrappers = wrappers \/ m\n        wrappers = math.floor(wrappers)\n        chocolates = chocolates + wrappers\n    end\n    \n    return chocolates\nen","completion":""}
{"prompt":"-- iso date times are of the form 2018-03-22T11:12:14, this is not a valid\n-- file system name and oses (osx for example,) transform the ':' into '\/'\n-- which is not what we want in our bucket object names.\n-- We transfor the ':' into a '-' so that the iso datetime becomes\n-- 2018-03-22T11-12-14.\nlocal function transform_iso_datetime(iso_datetime)\n    local t = iso_datetime:gsub(':', '-')\n    return t\nen","completion":""}
{"prompt":"-- Return the integer rounded towards +infinitum of n.\nlocal function ceiling(n)\n\treturn math.ceil(n)\nen","completion":""}
{"prompt":"-- Akaike Information Criterion -- the lowest value is preferred.\n-- INPUT:\n-- k - number of parameters in the model\n-- lnL - log likelihood\n-- NOTES:\n-- The relative likelihood is definied as exp(Delta AIC\/2) Grunblatt et al. 2015\n-- https:\/\/en.wikipedia.org\/wiki\/Akaike_information_criterion\nlocal function aic(k, lnL)\n  return 2 * k - 2 * lnL\nen","completion":""}
{"prompt":"-- Escape HTML entities in `s`.\nlocal function escape(s)\n\treturn string.gsub(s, \"([&<>'\\\"])\", { [\"&\"] = \"&amp;\", [\"<\"] = \"&lt;\", [\">\"] = \"&gt;\", [\"'\"] = \"&#39;\", ['\"'] = \"&quot;\" })\nen","completion":""}
{"prompt":"-- Backslash-escape string for proper logstash parsing\nlocal function escape(s)\n    return s:gsub('\\\\', '\\\\\\\\'):gsub('\"', '\\\\\"')\nen","completion":""}
{"prompt":"-- Trims a float to a given number of decimal places\nlocal function with_decimal_places(number, decimal_count)\n    if not decimal_count then decimal_count = 0 end\n    local string_format = \"%.\" .. decimal_count .. \"f\"\n    return string.format(string_format, number)\nen","completion":""}
{"prompt":"-- Takes a string of text and returns a string of normalized text.\nlocal function norm_text(textstring)\n\treturn textstring:lower():gsub('[^%w ]', '')\nen","completion":""}
{"prompt":"-- Helper function to return the square of the distance between\n-- points (x1,y1) and (x2,y2).\n-- :Parameters:\n-- x1: float\n-- X coordinate of first point\n-- y1: float\n-- Y coordinate of first point\n-- x2: float\n-- X coordinate of second point\n-- y2: float\n-- Y coordinate of second point\n-- :Returns:\n-- distsq: float\n-- The square of the distance, (x1-x2)**2 + (y1-y2)**2\nlocal function distance_squared(x1, y1, x2, y2)\n    return (x1-x2)^2 + (y1-y2)^2\nen","completion":""}
{"prompt":"-- Given a STIX 2.x object, determine its spec version.\nlocal function determine_spec_version(obj)\n\tif obj[\"spec_version\"] ~= nil then\n\t\treturn obj[\"spec_version\"]\n\tend\n\treturn \"2.0\"\nen","completion":""}
{"prompt":"-- [summary]\n-- Arguments:\n-- k (int): number\n-- Keyword Arguments:\n-- base (int): [description] (default: {2})\n-- scale (int): [description] (default: {10})\n-- Returns:\n-- int: [description]\nlocal function vdc(k, base, scale)\n  base = base or 2\n  scale = scale or 10\n  return math.floor((k * base) \/ scale) * scale \/ base\nen","completion":""}
{"prompt":"-- Updates a previously calculated average with a new value.\n-- Args:\n-- field: the current average;\n-- value: the new value to include in the average;\n-- tracked: the number of elements used to form the _original_ average\n-- Returns:\n-- float: the updated average\nlocal function update_average(field, value, tracked)\n    if tracked == 0 then\n        return value\n    else\n        return (tracked * field + value) \/ (tracked + 1)\n    end\nen","completion":""}
{"prompt":"-- Takes a nested dictionary and returns the dictionary corresponding to a dot-delimited sub-dict.\n-- >>> test_dict = {'foo': {'bar': {1: 42, 2: 55}}, 'baz': \"Hello\"}\n-- >>> extract_subsection(test_dict, \"foo.bar\")\n-- {1: 42, 2: 55}\nlocal function extract_subsection(conf, section)\n    local sub_dict = conf\n    for section_part in section:gmatch(\"([^.]+)\") do\n        sub_dict = sub_dict[section_part]\n    end\n    return sub_dict\nen","completion":""}
{"prompt":"-- Implements signed right-shift.\n-- See: http:\/\/stackoverflow.com\/a\/5833119\/15677\nlocal function rshift(val, n)\n  return val >> n\nen","completion":""}
{"prompt":"-- Scales cpu ratio originally calculated against total host cpu capacity,\n-- with the corresponding cpu shares limit (at task or container level)\n-- host_cpu_count is multiplied by 1024 to get the total available cpu shares\nlocal function scale_cpu_usage(cpu_usage_ratio, host_cpu_count, cpu_share_limit)\n\treturn cpu_usage_ratio * 1024 * host_cpu_count \/ cpu_share_limit\nen","completion":""}
{"prompt":"-- Fibonacci series\n-- >>> fib(1)\n-- 1\n-- >>> fib(2)\n-- 2\nlocal function fib(x)\n  if x == 0 or x == 1 then\n    return 1\n  else\n    return fib(x-1) + fib(x-2)\n  end\nen","completion":""}
{"prompt":"-- Put obj in list if it is not a list.\nlocal function _to_list(obj)\n    return type(obj) == \"table\" and obj or {obj}\nen","completion":""}
{"prompt":"-- Return a list of ``num_letters`` unique letters.\n-- Args:\n-- num_letters (int): Number of requested unique letters.\n-- Returns:\n-- str: Unique letters, concatenated as a string.\n-- Raises:\n-- ValueError: If the number of requested letters exceeds the alphabet size.\nlocal function get_letters(num_letters)\n   if num_letters > 26 then\n      error(\"Number of letters exceeded the alphabet size\")\n   end\n   local letters = {}\n   for i = 0, num_letters - 1 do\n      letters[i + 1] = string.char(i + 97)\n   end\n   return table.concat(letters)\nen","completion":""}
{"prompt":"-- calc distance between two 3d points\nlocal function distance(point1, point2)\n\tlocal dist = math.sqrt((point1[1] - point2[1])^2 + (point1[2] - point2[2])^2 + (point1[3] - point2[3])^2)\n\treturn dist\nen","completion":""}
{"prompt":"-- STFT center frequency\n-- Notebook: C8\/C8S2_SalienceRepresentation.ipynb\n-- Args:\n-- k (int): Coefficient number\n-- Fs  (scalar): Sampling rate in Hz\n-- N (int): Window length in samples\n-- Returns:\n-- freq (float): STFT center frequency\nlocal function f_coef(k, Fs, N)\n    return Fs * k \/ N\nen","completion":""}
{"prompt":"-- a pure recursive fib\nlocal function fib(n)\n  if n == 0 or n == 1 then\n    return 1\n  end\n  return fib(n-1) + fib(n-2)\nen","completion":""}
{"prompt":"-- Calculate a linear diffusion for a current year. If\n-- the current year is identical to the base year, the\n-- start value is returned\n-- Arguments\n-- ----------\n-- base_yr : int\n-- The year of the current simulation\n-- curr_yr : int\n-- The year of the current simulation\n-- value_start : float\n-- Fraction of population served with fuel_enduse_switch in base year\n-- value_end : float\n-- Fraction of population served with fuel_enduse_switch in end year\n-- yr_until_changed : str\n-- Year until changed is fully implemented\n-- Returns\n-- -------\n-- fract_cy : float\n-- The fraction in the simulation year\nlocal function linear_diff(base_yr, curr_yr, value_start, value_end, yr_until_changed)\n    if curr_yr == base_yr then\n        return value_start\n    elseif curr_yr < yr_until_changed then\n        return value_start + (curr_yr-base_yr) * (value_end-value_start) \/ (yr_until_changed-base_yr)\n    else\n        return value_end\n    end\nen","completion":""}
{"prompt":"-- Given an iterable of string contents, make a table row.\n-- Args:\n-- contents: An iterable yielding strings.\n-- tag: The tag to place contents in. Defaults to 'td', you might want 'th'.\n-- Returns:\n-- A string containing the content strings, organized into a table row.\n-- Example: make_table_row(['one', 'two', 'three']) == '''\n-- <tr>\n-- <td>one<\/td>\n-- <td>two<\/td>\n-- <td>three<\/td>\n-- <\/tr>'''\nlocal function make_table_row(contents, tag)\n    tag = tag or 'td'\n    local result = '<tr>\\n'\n    for _, content in ipairs(contents) do\n        result = result .. '<' .. tag .. '>' .. content .. '<\/' .. tag .. '>\\n'\n    end\n    result = result .. '<\/tr>\\n'\n    return result\nen","completion":""}
{"prompt":"-- Replaces NaN with null values\n-- Parameters\n-- ----------\n-- json_string: str\n-- json string for which to apply the replacement\n-- Returns\n-- -------\n-- str\n-- json string with 'null' strings in place of 'NaN' ones.\nlocal function remove_nan(json_string)\n  return json_string:gsub(\"NaN\",\"null\")\nen","completion":""}
{"prompt":"-- >>> host_from_jira_server(\"https:\/\/jira.HOST.TLD\/rest\/api\/2\/\")\n-- 'jira.HOST.TLD'\n-- >>> host_from_jira_server(\"https:\/\/jira.HOST.TLD\")\n-- 'jira.HOST.TLD'\nlocal function host_from_jira_server(prefix)\n  local match = prefix:match(\"^https?:\/\/([%w.-]+)\")\n  if match then return match end\nen","completion":""}
{"prompt":"-- Return ceiling(log_2(n)) for a positive integer `n`.\nlocal function ceil_lg(n)\n\tlocal c = 0\n\twhile n > 1 do\n\t\tn = n \/ 2\n\t\tc = c + 1\n\tend\n\treturn c\nen","completion":""}
{"prompt":"-- Replace umlauts\nlocal function umlauts(string)\n    return string:gsub(\"\u00c4\", \"AE\"):gsub(\"\u00dc\", \"UE\"):gsub(\"\u00d6\", \"OE\"):gsub(\"\u00e4\", \"ae\"):gsub(\"\u00fc\", \"ue\"):gsub(\"\u00f6\", \"oe\"):gsub(\"\u00df\", \"ss\")\nen","completion":""}
{"prompt":"-- Write a function that takes in a string of one or more words, and returns the same string, but with all five or more\n-- letter words reversed (Just like the name of this Kata). Strings passed in will consist of only letters and spaces.\n-- Spaces will be included only when more than one word is present.\n-- :param sentence: A string which may be a sentence.\n-- :return: the same string however, if the letters in a word are five or more reverse it.\nlocal function spin_words(sentence)\n\tlocal words = {}\n\tfor word in sentence:gmatch(\"%w+\") do\n\t\tif #word >= 5 then\n\t\t\ttable.insert(words, word:reverse())\n\t\telse\n\t\t\ttable.insert(words, word)\n\t\tend\n\tend\n\treturn table.concat(words, \" \")\nen","completion":""}
{"prompt":"-- cmake_quote_string(value) -> str\n-- Return a quoted form of the given value that is suitable for use in CMake\n-- language files.\nlocal function cmake_quote_string(value)\n  value = value:gsub(\"\\\\\", \"\\\\\\\\\")\n  value = value:gsub('\"', '\\\\\"')\n  value = value:gsub(\"'\", \"\\\\'\")\n  value = value:gsub(\"\\r\", \"\\\\r\")\n  value = value:gsub(\"\\n\", \"\\\\n\")\n  value = value:gsub(\"%${\", \"\\\\${\")\n  return value\nen","completion":""}
{"prompt":"-- Turn annotations into annotation index dictionary with\n-- image id as key and list of coco-like annotation objects as value.\n-- :param annotations: coco-like annotations list;\n-- :return: annotation index dictionary with image id as key and\n-- list of coco-like annotation objects as value;\nlocal function generate_annotation_index(annotations)\n    -- annotation index dictionary\n    local annotation_index = {}\n    -- for each annotation in the list\n    for _, annotation in pairs(annotations) do\n        -- get image id\n        local image_id = annotation.image_id\n        -- if image_id is not in annotation_index, create a new list\n        if not annotation_index[image_id] then\n            annotation_index[image_id] = {}\n        end\n        -- add annotation to annotation index\n        table.insert(annotation_index[image_id], annotation)\n    end\n    -- return annotation index\n    return annotation_index\nen","completion":""}
{"prompt":"-- Return a copy of seq (or string) with all occurences of item removed.\nlocal function removeall(item, seq)\n    local t = type(seq)\n    if t == 'table' then\n        local res = {}\n        for i, v in ipairs(seq) do\n            if v ~= item then\n                table.insert(res, v)\n            end\n        end\n        return res\n    elseif t == 'string' then\n        return seq:gsub(item, '')\n    end\nen","completion":""}
{"prompt":"-- Average a list of coordinates.\nlocal function average(coords)\n  local avg = {0, 0}\n  for i = 1, #coords do\n    avg[1] = avg[1] + coords[i][1]\n    avg[2] = avg[2] + coords[i][2]\n  end\n  avg[1] = avg[1] \/ #coords\n  avg[2] = avg[2] \/ #coords\n  return avg\nen","completion":""}
{"prompt":"-- Finding factorial iteratively\nlocal function fact(n)\n   local product = 1\n   for i = 2, n do\n      product = product * i\n   end\n   return product\nen","completion":""}
{"prompt":"-- Convert speed in knots to km\/h\nlocal function _parse_speed(speed_in_knots)\n  local speed_in_kmh = speed_in_knots * 1.852\n  return speed_in_kmh\nen","completion":""}
{"prompt":"-- return a two character hexadecimal string representation of integer d\nlocal function dec2hex(d)\n\treturn string.format(\"%02X\", d)\nen","completion":""}
{"prompt":"-- The usual function for the Mandelbrot set.\nlocal function func(f, c)\n    return f * f + c\nen","completion":""}
{"prompt":"-- Format a float as a dollar amount.\nlocal function _money(f)\n\treturn string.format(\"$%.2f\",f)\nen","completion":""}
{"prompt":"-- Function which returns the list of students who play cricket and badminton both.\nlocal function cricket_and_badminton_both(cricket, badminton)\n    local list = {}\n    for key, value in pairs(cricket) do\n        for key1, value1 in pairs(badminton) do\n            if value == value1 then\n                table.insert(list, value)\n            end\n        end\n    end\n    return list\nen","completion":""}
{"prompt":"-- convert silly C:\\names\\like\\this.txt to c:\/names\/like\/this.txt\nlocal function forwardSlash(listOfFiles)\n  local function replace(str)\n    return str:gsub('\\\\', '\/')\n  end\n  local result = listOfFiles\n  if type(listOfFiles) == 'string' then\n    result = replace(listOfFiles)\n  else\n    for i, v in ipairs(listOfFiles) do\n      result[i] = replace(v)\n    end\n  end\n  return result\nen","completion":""}
{"prompt":"-- Returns the visitor_method name for `node_name`, e.g.::\n-- >>> visitor_name('expression')\n-- 'on_expression'\nlocal function visitor_name(node_name)\n  return string.format('on_%s', node_name)\nen","completion":""}
{"prompt":"-- Cross Product function\n-- Given vectors a and b, calculate the cross product.\n-- Parameters\n-- ----------\n-- a : list\n-- First 3D vector.\n-- b : list\n-- Second 3D vector.\n-- Returns\n-- -------\n-- c : list\n-- The cross product of vector a and vector b.\n-- Examples\n-- --------\n-- >>> from .pycgmStatic import cross\n-- >>> a = [12.83, 61.25, 99.6]\n-- >>> b = [14.8, 61.72, 95.44]\n-- >>> np.around(cross(a, b), 2)\n-- array([-301.61,  249.58, -114.63])\nlocal function cross(a, b)\n\tlocal c = {}\n\tc[1] = a[2]*b[3] - a[3]*b[2]\n\tc[2] = a[3]*b[1] - a[1]*b[3]\n\tc[3] = a[1]*b[2] - a[2]*b[1]\n\treturn c\nen","completion":""}
{"prompt":"-- Determines the order of an element\n-- :param alpha: the element we want to find the order of\n-- :param p: the prime modulus\n-- :returns: the order of alpha\nlocal function order(alpha, p)\n  local e = 1\n  local x = alpha\n  while x ~= 1 do\n    x = (x * alpha) % p\n    e = e + 1\n  end\n  return e\nen","completion":""}
{"prompt":"-- Calculate the number of points for the regular grid based on the full width at half maximum.\n-- :param min_x: the lowest m\/z value\n-- :param max_x: the highest m\/z value\n-- :param points_per_mz: number of points per fwhm\n-- :return: total number of points\n-- :rtype: int\nlocal function total_points(min_x, max_x, points_per_mz)\n    return math.floor((max_x - min_x) * points_per_mz + 1)\nen","completion":""}
{"prompt":"-- Integer division (a\/b) that truncates towards 0, instead of -infinity as\n-- is default for Python. Assumes b is positive, but a can be negative or\n-- positive.\nlocal function div_to_zero(a, b)\n    if b == 0 then\n        return 0\n    elseif a > 0 then\n        return math.floor(a \/ b)\n    elseif a < 0 then\n        return math.ceil(a \/ b)\n    else\n        return 0\n    end\nen","completion":""}
{"prompt":"-- Round value with 2 decimals.\nlocal function f_string_2(value)\n    value = tonumber(value)\n    if value then\n        return string.format(\"%0.2f\", value)\n    end\n    return \"\"\nen","completion":""}
{"prompt":"-- Choose correct matrix index with periodic\n-- boundary conditions\n-- Input:\n-- - i:     Base index\n-- - limit: Highest \"legal\" index\n-- - add:   Number to add or subtract from i\nlocal function periodic(i, limit, add)\n    return (i+add)%limit\nen","completion":""}
{"prompt":"-- Standard division but it denominator is 0 then return 0\nlocal function _safe_divide(num, dem)\n\tif num == 0 or dem == 0 then\n\t\treturn 0\n\telse\n\t\treturn num \/ dem\n\tend\nen","completion":""}
{"prompt":"-- Cleans text.\n-- Only cleans superfluous whitespace at the moment.\nlocal function clean_text(text)\n\t-- Remove superfluous whitespace\n\tlocal cleaned = text:gsub(\"%s+\", \" \"):gsub(\"^%s+\", \"\"):gsub(\"%s+$\", \"\")\n\t-- Remove line breaks\n\tcleaned = cleaned:gsub(\"\\n\", \" \")\n\treturn cleaned\nen","completion":""}
{"prompt":"-- Count the number of '1' bits the given number has (also known as the Hamming weight).\n-- - Time complexity: O(n)\n-- - Space complexity: O(1)\n-- :param n: given unsigned numebr\n-- :type n: int\n-- :return: the number of '1' bits the given number has\n-- :rtype: int\nlocal function hamming_weight_2(n)\n\tlocal cnt = 0\n\tfor i = 0, 31 do\n\t\tif n % 2 == 1 then\n\t\t\tcnt = cnt + 1\n\t\tend\n\t\tn = math.floor(n \/ 2)\n\tend\n\treturn cnt\nen","completion":""}
{"prompt":"-- Convierte el tiempo en segundos \n-- :param horas: horas\n-- :horas type: int\n-- :param minutos: minutos\n-- :minutos type: int\n-- :param segundos: segundos\n-- :segundos type: int\n-- :return: tiempo en segundos\n-- :rtype: int\nlocal function tiempo_a_segundos(horas, minutos, segundos)\n\treturn (horas * 60 * 60) + (minutos * 60) + segundos\nen","completion":""}
{"prompt":"-- Set figure dimensions to avoid scaling in LaTeX.\n-- Parameters\n-- ----------\n-- width: float or string\n-- Document width in points, or string of predined document type\n-- fraction: float, optional\n-- Fraction of the width which you wish the figure to occupy\n-- subplots: array-like, optional\n-- The number of rows and columns of subplots.\n-- Returns\n-- -------\n-- fig_dim: tuple\n-- Dimensions of figure in inches\nlocal function set_size(width, fraction, subplots)\n  -- Width of figure\n  if width == 'thesis' then\n    width_pt = 426.79135\n  elseif width == 'beamer' then\n    width_pt = 307.28987\n  elseif width == 'beamer_thesis' then\n    width_pt = 426.79135\n  else\n    width_pt = width\n  end\n  if fraction == nil then\n    fraction = 1.0\n  end\n  -- Width of figure relative to subplots\n  if subplots == nil then\n    subplots = [[]]\n  end\n  local fig_width_pt = width_pt * fraction\n  local ncols = 1\n  if #subplots > 0 then\n    ncols = subplots[1]\n  end\n  local nrows = 1\n  if #subplots > 1 then\n    nrows = subplots[2]\n  end\n  local fig_width_in = fig_width_pt \/ 72.27\n  local fig_height_in = nrows * 0.7 * fig_width_in \/ ncols\n  if (width == 'thesis') or (width == 'beamer_thesis') then\n    fig_height_in = nrows * 0.7 * fig_width_in \/ ncols\n  end\n  local fig_dims = { fig_width_in, fig_height_in }\n  return fig_dims\nen","completion":""}
{"prompt":"-- Estimate the equivalent mass of galaxy by - pot_ext*r_gal\/G\n-- Parameters:\n-- -------------\n-- pot_ext: float\n-- the external potential of the center of the particle system\n-- r_gal: float\n-- the distance between the center of the particle system to the galactic center\n-- G: float\n-- gravitational constant\n-- Return:\n-- -------------\n-- M_galaxy: float\n-- the estimated mass of the galaxy\nlocal function estimateGalaxyMass(pot_ext, r_gal, G)\n\treturn - pot_ext*r_gal\/G\nen","completion":""}
{"prompt":"-- Return fibonacci number.\nlocal function fibonacci(num)\n    if num < 2 then return num end\n    return fibonacci(num-1) + fibonacci(num-2)\nen","completion":""}
{"prompt":"-- Parse core list passed through command line\nlocal function parse_cores(core_str)\n   local cores = {}\n   for part in string.gmatch(core_str, \"([^,]+)\") do\n      -- convert any hex values\n      local num = tonumber(part, 16)\n      if num ~= nil then\n         part = num\n      end\n      -- parse range\n      local s, e = string.find(part, \"-\")\n      if s then\n         for i=tonumber(string.sub(part, 1, s-1)), tonumber(string.sub(part, e+1)) do\n            cores[#cores+1] = i\n         end\n      else\n         cores[#cores+1] = part\n      end\n   end\n   return cores\nen","completion":""}
{"prompt":"-- Split a string\nlocal function parse_regions(region_str)\n  local regions = {}\n  if not region_str then return regions end\n  for region in region_str:gmatch(\"([^,]+)\") do\n    table.insert(regions, region)\n  end\n  return regions\nen","completion":""}
{"prompt":"-- Given variables like ``['a=b', 'c=d']`` turns it into ``{'a':\n-- 'b', 'c': 'd'}``\nlocal function parse_vars(args)\n  local vars = {}\n  for _, arg in ipairs(args) do\n    local index = arg:find('=')\n    if index then\n      local key = arg:sub(1, index - 1)\n      local val = arg:sub(index + 1)\n      vars[key] = val\n    else\n      error(\"Invalid --var argument '\" .. arg .. \"'.\")\n    end\n  end\n  return vars\nen","completion":""}
{"prompt":"-- ci\/ca is constant.\nlocal function cica_const_ratio(ambient_co2, const)\n    return const * ambient_co2\nen","completion":""}
{"prompt":"-- Returns the y value of a linear function based which goes from y=pos\n-- on x=0 to y=goal on x=n_steps.\nlocal function lin(pos, goal, x, n_steps)\n    return (goal-pos)\/(n_steps-1)*x + pos\nen","completion":""}
{"prompt":"-- Utility function that returns True if the given board is full and False otherwise\n-- Arg board: board - the board you want to check\nlocal function board_full(board)\n\tlocal count = 0\n\tfor _, val in pairs(board) do\n\t\tif val ~= 0 then\n\t\t\tcount = count + 1\n\t\tend\n\tend\n\treturn count == 9\nen","completion":""}
{"prompt":"-- Retorna o fatorial de n.\nlocal function fatorial(n)\n    if n == 0 then return 1 end\n    return n * fatorial(n-1)\nen","completion":""}
{"prompt":"-- The @dataAttribute2Html5Attribute@ method converts an *key*\n-- attribute that starts with `'data_'` to the HTML5 attribute that starts\n-- with `'data-'`. Otherwise the *key* attribute is answered unchanged.\nlocal function dataAttribute2Html5Attribute(key)\n  local prefix = \"data_\"\n  local startsWith = string.sub(key, 1, string.len(prefix))\n  if startsWith == prefix then\n    return \"data-\" .. string.sub(key, string.len(prefix) + 1)\n  else\n    return key\n  end\nen","completion":""}
{"prompt":"-- Normalize URL by stripping angle brackets.\nlocal function strip_angle_brackets_from_url(url)\n\treturn string.gsub(url, \"<\", \"\"):gsub(\">\", \"\")\nen","completion":""}
{"prompt":"-- [Put pixel at coordinate]\n-- Args:\n-- color  (list): [color of the pixel]\n-- pixels (list): [list of pixels]\n-- w      (int):  [width of the image]\n-- cord   (list): [tuple of x,y]\n-- Returns:\n-- list: [list of pixels]\nlocal function put_pixel(color, pixels, w, cord)\n\tlocal x = cord[1]\n\tlocal y = cord[2]\n\tif x < 0 or y < 0 or x >= w or y >= w then return pixels end\n\tpixels[y * w + x + 1] = color\n\treturn pixels\nen","completion":""}
{"prompt":"-- helper - to check if this is a standard competition\nlocal function is_standard_competition(json_data)\n    local is_standard_competition = false\n    if (not json_data.competition_start_date) then\n        is_standard_competition = true\n    end\n    return is_standard_competition\nen","completion":""}
{"prompt":"-- Defines a callable, that returns the constant, regardless of the input.\nlocal function _get_constant_function(constant)\n\treturn function()\n\t\treturn constant\n\tend\nen","completion":""}
{"prompt":"-- Return offset adjust -1 if offset >= 3, otherwise return 1.\nlocal function decrease_when_higher_than_3(offset)\n  return offset >= 3 and -1 or 1\nen","completion":""}
{"prompt":"-- Returns the factorial of a given positive, non-zero integer\n-- using loops.\nlocal function fact_loop(n)\n    assert(type(n) == 'number' and n >= 0,\n           \"argument must be a non-negative number\")\n    if n == 0 then\n        return 1\n    else\n        return n * fact_loop(n - 1)\n    end\nen","completion":""}
{"prompt":"-- Define an RGB color with three values 0..255.\nlocal function rgb255(r, g, b)\n\treturn {r \/ 255, g \/ 255, b \/ 255}\nen","completion":""}
{"prompt":"-- Given a list of sentences, return the sentences where each \n-- character is converted to lowercase.\nlocal function lower_text(sentences)\n    local lower_sentences = {}\n    for _, sentence in pairs(sentences) do\n        local lower_sentence = \"\"\n        for i = 1, #sentence do\n            local char = string.sub(sentence, i, i)\n            lower_sentence = lower_sentence .. string.lower(char)\n        end\n        table.insert(lower_sentences, lower_sentence)\n    end\n    return lower_sentences\nen","completion":""}
{"prompt":"-- Produce entities within text.\nlocal function html_escape(text)\n\ttext = text:gsub(\"&\", \"&amp;\")\n\ttext = text:gsub(\"\\\"\", \"&quot;\")\n\ttext = text:gsub(\"<\", \"&lt;\")\n\ttext = text:gsub(\">\", \"&gt;\")\n\ttext = text:gsub(\"'\", \"&apos;\")\n\treturn text\nen","completion":""}
{"prompt":"-- Translate a Python value to the equivalent literal representation\n-- for Fortran input.\n-- :param value:\n-- :return:\nlocal function to_fortran(value)\n   if (type(value) == \"string\") then\n      return \"'\" .. value .. \"'\"\n   elseif (type(value) == \"number\") then\n      return tostring(value)\n   elseif (type(value) == \"boolean\") then\n      if (value) then\n         return \".true.\"\n      else\n         return \".false.\"\n      end\n   elseif (type(value) == \"table\") then\n      return to_fortran_array(value)\n   elseif (type(value) == \"userdata\") then\n      return to_fortran_complex(value)\n   else\n      error(\"Don't know how to convert value to Fortran string: \" .. type(value))\n   end\nen","completion":""}
{"prompt":"-- Computes boundary indices for each of the splits in split_probs.\n-- Args:\n-- split_probs: List of (split_name, prob), e.g. [('train', 0.6), ('dev', 0.2),\n-- ('test', 0.2)]\n-- n_items: Number of items we want to split.\n-- Returns:\n-- The item indices of boundaries between different splits. For the above\n-- example and n_items=100, these will be\n-- [('train', 0, 60), ('dev', 60, 80), ('test', 80, 100)].\nlocal function _compute_split_boundaries(split_probs, n_items)\n  -- Compute cumulative sum of probs\n  local cum_probs = {}\n  local cum_prob_sum = 0\n  for _, p in ipairs(split_probs) do\n    cum_prob_sum = cum_prob_sum + p[2]\n    table.insert(cum_probs, cum_prob_sum)\n  end\n  -- Compute indices of boundaries between different splits\n  local split_boundaries = {}\n  local prev_boundary = 0\n  for i = 1, #cum_probs do\n    local boundary = math.floor(cum_probs[i] * n_items)\n    table.insert(split_boundaries, {split_probs[i][1], prev_boundary, boundary})\n    prev_boundary = boundary\n  end\n  return split_boundaries\nen","completion":""}
{"prompt":"-- a helper method for converting strings to their float value\n-- Args:\n-- str: a string containing a number\n-- Returns:\n-- the float value of the string given or None if not a float\nlocal function cast_float(str)\n  if str and str ~= '' then\n    return tonumber(str)\n  end\n  return nil\nen","completion":""}
{"prompt":"-- Channel control (CH) 0-83. 84 channels in total\n-- 850.125 + CH *1MHz. Default 868.125MHz(SX1262),\n-- 410.125 + CH *1MHz. Default 433.125MHz(SX1268)\nlocal function parse_reg_05h_byte(byte_val)\n    local ch = bit32.band(byte_val, 0x7F)\n    local freq = 0\n    if (SX126X_CHIP_VERSION == SX1262_CHIP) then\n        -- Default channel 868.125MHz\n        freq = 868125000 + ch * 1000000\n    elseif (SX126X_CHIP_VERSION == SX1268_CHIP) then\n        -- Default channel 433.125MHz\n        freq = 433125000 + ch * 1000000\n    end\n    return ch, freq\nen","completion":""}
{"prompt":"-- Calculate harmonic series, used for calculating MRR\nlocal function harmonic(n_numbers)\n  local sum = 0\n  for i = 1, n_numbers do sum = sum + 1 \/ i end\n  return sum\nen","completion":""}
{"prompt":"-- This is used in HSL_to_RGB conversions on R, G, and B.\nlocal function __Calc_HSL_to_RGB_Components(var_q, var_p, C)\n\tif C < 0.5 then\n\t\treturn (var_p + (var_q - var_p) * C * 2)\n\telse\n\t\treturn (var_q + (var_p - var_q) * (C - 0.5) * 2)\n\tend\nen","completion":""}
{"prompt":"-- Handle the collapsible function of the navbar\n-- Parameters\n-- ----------\n-- clicks: int\n-- How many times the toggler has been clicked\n-- is_open: bool\n-- State of the collapsible unit\n-- Returns\n-- ----------\n-- is_open: bool\n-- Oppositie of inputed state\nlocal function navbar_toggle(clicks, is_open)\n    if clicks > 0 then\n        return not is_open\n    else\n        return is_open\n    end\nen","completion":""}
{"prompt":"-- input: positive integer 'n' >= 1\n-- returns all divisors of n (inclusive 1 and 'n')\nlocal function getDivisors(n)\n    local divs = {}\n    for i=1,n do\n        if n%i==0 then\n            table.insert(divs, i)\n        end\n    end\n    return divs\nen","completion":""}
{"prompt":"-- Finds the largest dividable integer that is lower than bound.\n-- :param divisor: positive integer.\n-- :param bound: positive integer.\n-- :return: the largest integer N, such that, N is divisible by divisor, N is less\n-- than or equal to bound, and N is greater than 0.\nlocal function max_multiple(divisor, bound)\n\treturn (bound \/\/ divisor) * divisor\nen","completion":""}
{"prompt":"-- Reset value between minimum and maximum\nlocal function clamp(value, minimum, maximum)\n\treturn math.max(math.min(value, maximum), minimum)\nen","completion":""}
{"prompt":"-- function to approximate by polynomial interpolation\nlocal function f(x) return x * x en","completion":""}
{"prompt":"-- Given a list of n-dimensional points, returns a list of length n where each\n-- element is a tuple holding (min, max) for that dimension.\n-- points -- list of n-dimensional points\nlocal function get_bounds(points)\n    local bounds = {}\n    for i = 1, #points[1] do\n        bounds[i] = {math.huge, -math.huge}\n        for j = 1, #points do\n            local point = points[j]\n            if point[i] < bounds[i][1] then\n                bounds[i][1] = point[i]\n            end\n            if point[i] > bounds[i][2] then\n                bounds[i][2] = point[i]\n            end\n        end\n    end\n    return bounds\nen","completion":""}
{"prompt":"-- If string h starts with s, strip it off; return the result\nlocal function strip_start(h, s)\n  if h:sub(1, #s) == s then\n    return h:sub(#s + 1)\n  else\n    return h\n  end\nen","completion":""}
{"prompt":"-- Returns a header break of 39 '#' glyphs.\n-- Examples:\n-- >>> format_header_break()\n-- '#######################################'\nlocal function format_header_break()\n  local width = 39\n  local buf = {}\n  for i = 1, width do buf[i] = '#' end\n  return table.concat(buf, '')\nen","completion":""}
{"prompt":"-- Fibonacci function.\n-- Args:\n-- n (int): The index of the number on the Fibonacci series to return.\n-- Returns:\n-- int: The n number in the Fibonacci series.\nlocal function fibonacci_to(n)\n  local function fibonacci_to_n(a, b, n)\n    if n == 0 then return a end\n    return fibonacci_to_n(b, a+b, n-1)\n  end\n  return fibonacci_to_n(0, 1, n)\nen","completion":""}
{"prompt":"-- Divide operation that deals with a 0 value denominator.\n-- num: numerator.\n-- denom: denominator.\n-- Returns 0.0 if the denominator is 0, otherwise returns a float.\nlocal function div0(num, denom)\n  if denom == 0 then\n    return 0.0\n  end\n  return num \/ denom\nen","completion":""}
{"prompt":"-- Parse a text date like ``\"2004-08-30`` into a triple of numbers.\n-- May fling ValueErrors or TypeErrors around if the input or date is invalid.\n-- It should at least be a string--I mean, come on.\nlocal function _parse_date(text)\n  local year, month, day = text:match(\"^(%d+)-(%d+)-(%d+)\")\n  if not year or not month or not day then\n    error(\"Invalid date: \" .. tostring(text))\n  end\n  return { tonumber(year), tonumber(month), tonumber(day) }\nen","completion":""}
{"prompt":"-- Parse an ini content, returns a dict\nlocal function parse_ini(c)\n    local ini = {}\n    for line in c:gmatch(\"[^\\r\\n]+\") do\n        local key, value = line:match(\"^%s*([^=]+)=(.*)$\")\n        if key and value then\n            ini[key] = value\n        end\n    end\n    return ini\nen","completion":""}
{"prompt":"-- Get the COCO keypoints and their left\/right flip coorespondence map.\nlocal function get_keypoints()\n  local keypoint_names = {\n    'nose',\n    'left_eye',\n    'right_eye',\n    'left_ear',\n    'right_ear',\n    'left_shoulder',\n    'right_shoulder',\n    'left_elbow',\n    'right_elbow',\n    'left_wrist',\n    'right_wrist',\n    'left_hip',\n    'right_hip',\n    'left_knee',\n    'right_knee',\n    'left_ankle',\n    'right_ankle'\n  }\n  local keypoint_flip_map = {\n    {'left_eye', 'right_eye'},\n    {'left_ear', 'right_ear'},\n    {'left_shoulder', 'right_shoulder'},\n    {'left_elbow', 'right_elbow'},\n    {'left_wrist', 'right_wrist'},\n    {'left_hip', 'right_hip'},\n    {'left_knee', 'right_knee'},\n    {'left_ankle', 'right_ankle'}\n  }\n  return keypoint_names, keypoint_flip_map\nen","completion":""}
{"prompt":"-- assumes char is a single character\n-- returns a boolean, True is char is a digit, else False\nlocal function isDigit(char)\n\tif char:match(\"^%d$\") then return true end\n\treturn false\nen","completion":""}
{"prompt":"-- Accepts a list or a numpy.ndarray and returns a list.\nlocal function _convert_to_list(data)\n    if type(data) == 'table' then\n        return data\n    elseif type(data) == 'cdata' then\n        local result = {}\n        for i = 0, #data do\n            result[#result + 1] = tonumber(data[i])\n        end\n        return result\n    end\nen","completion":""}
{"prompt":"-- >>> solve_me_first(2, 3)\n-- 5\nlocal function solve_me_first(a, b)\n  return a + b\nen","completion":""}
{"prompt":"-- parse input a=b c=d into map\nlocal function parse_key_value_pairs(line)\n\tlocal t = {}\n\tfor pair in line:gmatch('([^%s]+)') do\n\t\tlocal k, v = pair:match('([^=]*)=([^%s]*)')\n\t\tif k and v then\n\t\t\tt[k] = v\n\t\tend\n\tend\n\treturn t\nen","completion":""}
{"prompt":"-- Count the number of times each char appears in a given string.\n-- Store chars as dict keys and number of appearencess as values.\nlocal function hist(s)\n    local h = {}\n    for c in s:gmatch(\".\") do\n        h[c] = (h[c] or 0) + 1\n    end\n    return h\nen","completion":""}
{"prompt":"-- Convert a binary value to binary coded decimal.\n-- Arguments:\n-- value - the binary value to convert to BCD. (required, no default)\nlocal function _bin2bcd(value)\n    local bcd = 0\n    local count = 0\n    while value > 0 do\n        local lastDigit = math.fmod(value, 10)\n        local binaryValue = lastDigit * (2 ^ count)\n        bcd = bcd + binaryValue\n        value = (value - lastDigit) \/ 10\n        count = count + 4\n    end\n    return bcd\nen","completion":""}
{"prompt":"-- Process a kmer info string (last column of a Kraken 2 output file), so that\n-- we get a dictionary mapping of tax_ids to total sum of kmer hits.\n-- Returns:\n-- {tax_id_#1: X kmer hits,\n-- tax_id_#2: Y kmer hits,\n-- ...\n-- tax_id_#N: Z kmer hits}\nlocal function process_kmer_string(kmer_info_string, paired_input)\n    local total_hits = {}\n    for tax_id, count in string.gmatch(kmer_info_string, \"%s*(%d+):(%d+)\") do\n        tax_id = tonumber(tax_id)\n        count = tonumber(count)\n        if paired_input then\n            count = count \/ 2\n        end\n        total_hits[tax_id] = (total_hits[tax_id] or 0) + count\n    end\n    return total_hits\nen","completion":""}
{"prompt":"-- Returns x**2 and stores its gradient in g[0]\nlocal function f(x, g)\n   local fx = x[1] ^ 2\n   g[0] = 2 * x[1]\n   return fx\nen","completion":""}
{"prompt":"-- Turns new lines into carriage return + new line.\nlocal function replace_nl_with_carriage(content)\n\treturn content:gsub(\"[\\n]\", \"\\r\\n\")\nen","completion":""}
{"prompt":"-- Return the wavelength associated with an index.\n-- index -- index position of the spectrum list\n-- step -- the step in wavelength per index, in nm\n-- min_wl -- the minimum wavelength of the spectrum, in nm\nlocal function index2wavelength(index, step, min_wl)\n    return index * step + min_wl\nen","completion":""}
{"prompt":"-- Appends tensors in a list to a list after converting tensors to numpy arrays\n-- Args:\n-- list_of_lists (list[lists]): List of lists, each of which holds arrays\n-- list_of_tensors (list[torch.tensorFloat]): List of Pytorch tensors\n-- Returns:\n-- list_of_lists (list[lists]): List of lists, each of which holds arrays\nlocal function append_tensors_to_lists(list_of_lists, list_of_tensors)\n    if list_of_lists == nil then\n        list_of_lists = {}\n    end\n    if list_of_tensors == nil then\n        return list_of_lists\n    end\n    for i, tensor in ipairs(list_of_tensors) do\n        list_of_lists[i] = tensor:totable()\n    end\n    return list_of_lists\nen","completion":""}
{"prompt":"-- >>> parse_app(None)\n-- ''\n-- >>> parse_app({})\n-- ''\n-- >>> parse_app({'name': 'esteem'})\n-- 'esteem'\n-- >>> parse_app({'version': 2})\n-- ''\n-- >>> parse_app({'name': 'esteem', 'version': 2})\n-- 'esteem 2'\n-- >>> parse_app('esteem 1.1.1')\n-- 'esteem 1.1.1'\nlocal function parse_app(app)\n  if type(app) == 'string' then\n    return app\n  elseif type(app) == 'table' then\n    if app.name then\n      if app.version then\n        return app.name .. ' ' .. app.version\n      else\n        return app.name\n      end\n    else\n      return ''\n    end\n  else\n    return ''\n  end\nen","completion":""}
{"prompt":"-- Perfrom tracking on every object in the frame\n-- Parameters\n-- ----------\n-- frame : numpy array\n-- The input image to track the objects within\n-- frame_id : int\n-- The order of the frame in the video\n-- objects : list\n-- list of the current traffic object under tracking\n-- to check where they moved in the frame.\n-- Returns\n-- -------\n-- list\n-- a list of the traffic object classes with updated\n-- postions according to the tracking result.\nlocal function track_objs(frame, frame_id, objects)\n  local results = {}\n  -- Perform tracking on every object\n  for i, obj in ipairs(objects) do\n    -- If the object has not been tracked before,\n    -- then initialize it\n    if (obj.tracker == nil) then\n      obj.tracker = tracker:new(obj.bbox)\n      if (obj.tracker == nil) then\n        obj.tracker = nil\n        print(string.format(\"Failed to initialize tracker for object %s in frame %d\", obj.class, frame_id))\n        table.insert(results, obj)\n        return results\n      end\n    end\n    -- Perform tracking for the object\n    local ok, bbox = obj.tracker:update(frame)\n    if (not ok) then\n      obj.tracker = nil\n      print(string.format(\"Failed to track object %s in frame %d\", obj.class, frame_id))\n      table.insert(results, obj)\n      return results\n    end\n    -- Check if the object has been lost\n    if (bbox.lost) then\n      obj.tracker = nil\n      print(string.format(\"Lost object %s in frame %d\", obj.class, frame_id))\n      table.insert(results, obj)\n      return results\n    end\n    -- Check if the object has been found again\n    if (not bbox.found) then\n      obj.tracker = nil\n      print(string.format(\"Found object %s in frame %d\", obj.class, frame_id))\n      table.insert(results, obj)\n      return results\n    end\n    -- If the object is found again, then update\n    -- the object class and position in the frame\n    obj.bbox = bbox\n    obj.class = class_name_to_id[obj.class]\n    obj.frame_id = frame_id\n    table.insert(results, obj)\n  end\n  return results\nen","completion":""}
{"prompt":"-- Applies a simple low-pass filter.\n-- Parameters:\n-- a, b: Input coordinates and sizes.\n-- alpha:\nlocal function low_filter(a, b, alpha)\n  return alpha * a + (1 - alpha) * b\nen","completion":""}
{"prompt":"-- Return the argument text, unchanged.\n-- (Directive option conversion function.)\n-- Raise ``ValueError`` if no argument is found.\nlocal function unchanged_required(argument)\n  if not argument then\n    raise_error(\"option required\")\n  end\n  return argument\nen","completion":""}
{"prompt":"-- Parse headers from nodes TSV\n-- Parameters\n-- ----------\n-- elements: list\n-- The header record\n-- Returns\n-- -------\n-- dict:\n-- A dictionary of node header names to index\nlocal function parse_header(elements)\n    local out = {}\n    for i, name in ipairs(elements) do\n        out[name] = i - 1\n    end\n    return out\nen","completion":""}
{"prompt":"-- Set the background color for the p5.renderer.\n-- :param args: \n-- :param args:\n-- :param args: \n-- :param args: \n-- :param args: \n-- :returns:\nlocal function mapping(n, start1, stop1, start2, stop2)\n  local x = ((n - start1) \/ (stop1 - start1)) * (stop2 - start2) + start2\n  return x\nen","completion":""}
{"prompt":"-- :math:`f(x) =` x if x is greater than 0, else 0\n-- (See `<https:\/\/en.wikipedia.org\/wiki\/Rectifier_(neural_networks)>`_ .)\nlocal function relu(x)\n  if x > 0 then\n    return x\n  else\n    return 0\n  end\nen","completion":""}
{"prompt":"-- !\n-- @brief Calculate square Euclidean distance between two vectors.\n-- [\n-- dist(a, b) = \\sum_{i=0}^{N}(a_{i} - b_{i})^{2};\n-- ]\n-- @param[in] point1 (array_like): The first vector.\n-- @param[in] point2 (array_like): The second vector.\n-- @return (double) Square Euclidean distance between two vectors.\n-- @see euclidean_distance, manhattan_distance, chebyshev_distance\nlocal function euclidean_distance_square(point1, point2)\n  local squared_distances = 0\n  for i = 1, #point1 do\n    local distance = point1[i] - point2[i]\n    squared_distances = squared_distances + distance * distance\n  end\n  return squared_distances\nen","completion":""}
{"prompt":"-- Merge two confusion matrices.\n-- Parameters\n-- ----------\n-- cm1 : dict\n-- Confusion matrix which has integer keys 0, ..., nb_classes - 1;\n-- an entry cm1[i][j] is the count how often class i was classified as\n-- class j.\n-- cm2 : dict\n-- Another confusion matrix.\n-- Returns\n-- -------\n-- dict\n-- merged confusion matrix\n-- Examples\n-- --------\n-- >>> cm1 = {0: {0: 1, 1: 2}, 1: {0: 3, 1: 4}}\n-- >>> cm2 = {0: {0: 5, 1: 6}, 1: {0: 7, 1: 8}}\n-- >>> merge_cms(cm1, cm2)\n-- {0: {0: 6, 1: 8}, 1: {0: 10, 1: 12}}\nlocal function merge_cms(cm1, cm2)\n   local merged = {}\n   for i, row in pairs(cm1) do\n      merged[i] = {}\n      for j, val in pairs(row) do\n         merged[i][j] = (cm1[i][j] or 0) + (cm2[i][j] or 0)\n      end\n   end\n   return merged\nen","completion":""}
{"prompt":"-- Determine stretch factor to add `overlap_ms` to length of signal.\nlocal function calculate_stretch_factor(array_length_samples, overlap_ms, sr)\n    local overlap_samples = math.ceil(overlap_ms * sr \/ 1000)\n    return math.ceil((overlap_samples + array_length_samples) \/ array_length_samples)\nen","completion":""}
{"prompt":"-- Combination nCk with memo.\nlocal function comb(n, k, combs)\n  combs = combs or {}\n  if k == 0 or k == n then\n    return 1\n  end\n  if k > n\/2 then\n    k = n - k\n  end\n  local c = combs[n] and combs[n][k]\n  if not c then\n    c = comb(n-1, k) + comb(n-1, k-1)\n    combs[n] = combs[n] or {}\n    combs[n][k] = c\n  end\n  return c\nen","completion":""}
{"prompt":"-- Returns a playlist ID given a Spotify playlist URL.\nlocal function get_playlist_id(link)\n\treturn link:match('https?:\/\/.*playlist\/(.-)%?') or link:match('https?:\/\/.*\/(.-)%?')\nen","completion":""}
{"prompt":"-- flatten a list of lists into a single list\nlocal function flatten(lists)\n    local new_list = {}\n    for _, list in ipairs(lists) do\n        for _, v in ipairs(list) do\n            new_list[#new_list+1] = v\n        end\n    end\n    return new_list\nen","completion":""}
{"prompt":"-- given n number of stairs, determine the total number of ways to climb the\n-- stairs if you can take 1, 2, or 3 steps at a time\nlocal function stepPerms(n)\n    local ways = {}\n    ways[0] = 1\n    ways[1] = 1\n    ways[2] = 2\n    ways[3] = 4\n    for i=4,n do\n        ways[i] = ways[i-1] + ways[i-2] + ways[i-3]\n    end\n    return ways[n]\nen","completion":""}
{"prompt":"-- Divide and round up\nlocal function ceiling_division(numerator, denominator)\n  return math.ceil(numerator \/ denominator)\nen","completion":""}
{"prompt":"-- Computes a^b mod n. Complexity O(log(b))\nlocal function modular_exp(a, b, n)\n  local result = 1\n  a = a % n\n  while b > 0 do\n    if b % 2 == 1 then result = (result * a) % n end\n    b = b \/\/ 2\n    a = (a * a) % n\n  end\n  return result\nen","completion":""}
{"prompt":"-- Given n, clamp its value between smallest and largest.\nlocal function clamp(n, smallest, largest)\n\treturn n < smallest and smallest or n > largest and largest or n\nen","completion":""}
{"prompt":"-- Converts the underscore from a status name into a space and adds trait count for it\nlocal function status_readable_name_with_count(value, count)\n  local new_value = value:gsub('^_', ''):gsub('_', ' ')\n  if count then\n    return new_value .. ' [' .. count .. ']'\n  else\n    return new_value\n  end\nen","completion":""}
{"prompt":"-- Returns the percentage increase\/decrease of the new price new_price based on the old price old_price.\nlocal function get_percentage(new_price, old_price)\n\tlocal percentage = (new_price - old_price) \/ old_price * 100\n\treturn percentage\nen","completion":""}
{"prompt":"-- Get the image filename fro a url.\nlocal function get_filename_from_url(url)\n\tlocal file = string.gsub(url, \".*\/\", \"\")\n\treturn file\nen","completion":""}
{"prompt":"-- _compute_qset_filters translates the keys of req_params to the keys of translation_dict.\n-- If the key isn't present in filters_dict, it is discarded.\nlocal function _compute_qset_filters(req_params, translation_dict)\n    local filters = {}\n    for req_key, value in pairs(req_params) do\n        local translated_key = translation_dict[req_key]\n        if translated_key then\n            filters[translated_key] = value\n        end\n    end\n    return filters\nen","completion":""}
{"prompt":"-- order structure so that the structure whit highetst MFE(most negative)\n-- will be placed first and so on to the lowest MFE structure.\nlocal function order_structs(result)\n    local new_list = {}\n    for i, v in ipairs(result) do\n        table.insert(new_list, 1, v)\n    end\n    return new_list\nen","completion":""}
{"prompt":"-- Reverse domain name, for proper sorting.\n-- Input is string, output is list.\n-- www.foo.com -> [com, foo, www]\nlocal function _domreverse(r)\n\tlocal ret = {}\n\tfor w in r:gmatch(\"[^.]+\") do\n\t\ttable.insert(ret, 1, w)\n\tend\n\treturn ret\nen","completion":""}
{"prompt":"-- Return a list of domain name labels, in reverse-DNS order.\nlocal function domain_str_to_labels(domain_name)\n  local labels = {}\n  for domain_label in string.gmatch(domain_name, \"[^.]+\") do\n    table.insert(labels, 1, domain_label)\n  end\n  return labels\nen","completion":""}
{"prompt":"-- Get course content for each branch id.\nlocal function get_course_content(database, branch_ids)\n    local course_content = {}\n    for _, branch_id in ipairs(branch_ids) do\n        local course_content_by_branch_id = get_course_content_by_branch_id(database, branch_id)\n        for course_id, course_content_by_branch_id in pairs(course_content_by_branch_id) do\n            course_content[course_id] = course_content[course_id] or {}\n            for branch_id, section_ids in pairs(course_content_by_branch_id) do\n                course_content[course_id][branch_id] = course_content[course_id][branch_id] or {}\n                for section_id, section_content in pairs(section_ids) do\n                    course_content[course_id][branch_id][section_id] = section_content\n                end\n            end\n        end\n    end\n    return course_content\nen","completion":""}
{"prompt":"-- Returns the sum of num1 and num2.\n-- This one has been done for you. Use it as a gide for\n-- the funstions below.\nlocal function calc_sum(num1, num2)\n    return num1 + num2\nen","completion":""}
{"prompt":"-- equivalent to math.ceil(x \/ y)\n-- :param x:\n-- :param y:\n-- :return:\nlocal function int_ceil(x, y)\n  return math.floor((x + y - 1) \/ y)\nen","completion":""}
{"prompt":"-- Diode capacitance as function of diode current and transit time\n-- Diffusion capacitance is linearly dependent on diode current.\n-- Args:\n-- i_c (float: Diode current.\n-- tt (float): Transit time.\n-- Returns:\n-- (float): Diode capacitance.\nlocal function diode_capacitance_TT_eq(i_c, tt)\n  return tt * math.abs(i_c)\nen","completion":""}
{"prompt":"-- returns the greater difference between a value\n-- and two numbers\n-- :param\n-- min_num (int) : a number to check\n-- val (int) : the number to compare to other params\n-- max_num (int) : a number to check\n-- :return\n-- absolute value of greatest difference between two compared numbers\nlocal function greater_difference(min_num, val, max_num)\n    return math.max(math.abs(min_num - val), math.abs(max_num - val))\nen","completion":""}
{"prompt":"-- Formats a string of two characters into the format of (0X), useful for date formatting.\n-- :param arg: The string\n-- :return: String\nlocal function twochars(arg)\n    local t = \"\"\n    if #arg == 1 then\n        t = string.format(\"0%s\", arg)\n    else\n        t = string.format(\"%s\", arg)\n    end\n    return t\nen","completion":""}
{"prompt":"-- Converts a ratio to an integer if it is smaller than 1.\nlocal function ratio_to_int(percentage, max_val)\n    return percentage < 1 and math.floor(max_val * percentage) or math.floor(percentage)\nen","completion":""}
{"prompt":"-- Computes the flicker percentage of the waveform\n-- Parameters\n-- ----------\n-- v_max : float\n-- The max voltage\n-- v_pp : float\n-- The peak-to-peak voltage\n-- Returns\n-- -------\n-- float\n-- The flicker percentage\nlocal function percent_flicker(v_max, v_pp)\n  if v_max > 0 then\n    return (v_pp \/ v_max) * 100\n  else\n    return 0\n  end\nen","completion":""}
{"prompt":"-- Strips and removes multiple spaces in a string.\n-- :param str string: the string to remove the spaces from\n-- :return: a new string without multiple spaces and stripped\nlocal function remove_multiple_spaces(string)\n    return string:gsub(\" +\", \" \"):gsub(\"^%s*(.-)%s*$\", \"%1\"):gsub(\"^%s*(.-)%s*$\", \"%1\")\nen","completion":""}
{"prompt":"-- Check expression for correctly matched brackets.\nlocal function checkio(expression)\n    local stack = {}\n    \n    for i = 1, #expression do\n        local char = expression:sub(i,i)\n        if char == '(' or char == '{' or char == '[' then\n            stack[#stack+1] = char\n        end\n        \n        if char == ')' then\n            if stack[#stack] == '(' then\n                table.remove(stack)\n            else\n                return false\n            end\n        elseif char == ']' then\n            if stack[#stack] == '[' then\n                table.remove(stack)\n            else\n                return false\n            end\n        elseif char == '}' then\n            if stack[#stack] == '{' then\n                table.remove(stack)\n            else\n                return false\n            end\n        end\n    end\n    \n    if #stack == 0 then\n        return true\n    end\n    \n    return false\nen","completion":""}
{"prompt":"-- Balanced Error Rate [0, 1]\n-- :param int tp: number of true positives\n-- :param int tn: number of true negatives\n-- :param int fp: number of false positives\n-- :param int fn: number of false negatives\n-- :rtype: float\nlocal function ber(tp, tn, fp, fn)\n   return 0.5 * (fp \/ (fp + tn) + fn \/ (tp + fn))\nen","completion":""}
{"prompt":"-- Convert degrees Fahrenheit to Celsius.\nlocal function fahrenheit_to_celsius(deg_F)\n  return (deg_F - 32) * 5 \/ 9\nen","completion":""}
{"prompt":"-- returns an indentity matrix of order m\nlocal function eye(m)\n  local result = {}\n  for i = 1, m do\n    result[i] = {}\n    for j = 1, m do\n      result[i][j] = i == j and 1 or 0\n    end\n  end\n  return result\nen","completion":""}
{"prompt":"-- Calculate average rating\n-- Args:\n-- IDandRatingsTuple: a single tuple of (MovieID, (Rating1, Rating2, Rating3, ...))\n-- Returns:\n-- tuple: a tuple of (MovieID, (number of ratings, averageRating))\nlocal function getCountsAndAverages(IDandRatingsTuple)\n\tlocal movieID = IDandRatingsTuple[1]\n\tlocal ratings = IDandRatingsTuple[2]\n\tlocal numRatings = 0\n\tlocal sum = 0\n\tfor i=1,#ratings do\n\t\tnumRatings = numRatings + 1\n\t\tsum = sum + ratings[i]\n\tend\n\tlocal average = sum \/ numRatings\n\treturn {movieID, {numRatings, average}}\nen","completion":""}
{"prompt":"-- turn 0101 0000 -> 0101 1111 in O(1)\nlocal function right_prop_rightmost_set_bit(x)\n    return x | (x - 1)\nen","completion":""}
{"prompt":"-- Sets the bit at offset k\nlocal function set_bit_k(int_val, k)\n\treturn int_val | (1 << k)\nen","completion":""}
{"prompt":"-- Given two integers n and k, return all possible combinations of k numbers\n-- out of 1 2 3 ... n.\n-- n = 4\n-- k = 2\n-- [\n-- [1,2],\n-- [1,3],\n-- [1,4],\n-- [2,3],\n-- [2,4],\n-- [3,4],\n-- ]\nlocal function combinations(n, k)\n    local ret = {}\n    local function do_choose(n, k, first, t, ret)\n        if k == 0 then\n            table.insert(ret, t)\n        else\n            for i = first, n do\n                local t2 = {}\n                for i, x in ipairs(t) do\n                    table.insert(t2, x)\n                end\n                table.insert(t2, i)\n                do_choose(n, k - 1, i + 1, t2, ret)\n            end\n        end\n    end\n    do_choose(n, k, 1, {}, ret)\n    return ret\nen","completion":""}
{"prompt":"-- Give an Integer 'n'. Check if 'n' is Prime or Not\n-- :param n:\n-- :return: bool - True or False\n-- A no. is prime if it is divisible only by 1 & itself.\n-- 1- is neither Prime nor Composite\n-- - check for n being a even number i.e divisble by 2\n-- - check for n being divisible by 3\n-- - then create a range of i following series, 5,7,11,13,17,19,23,.... till sqrt(n) with step as +6\n-- - check for divisibility of n with each value of i & i+2\nlocal function isPrime(n)\n    if n<=1 then return false end\n    if n==2 or n==3 then return true end\n    if n%2==0 or n%3==0 then return false end\n    local i=5\n    while i<=math.sqrt(n) do\n        if n%i==0 or n%(i+2)==0 then return false end\n        i=i+6\n    end\n    return true\nen","completion":""}
{"prompt":"-- Adds slashes before quotes. Useful for escaping strings in CSV, for\n-- example. Less useful for escaping JavaScript; use the ``escapejs``\n-- filter instead.\nlocal function addslashes(value)\n  return (value:gsub(\"([\\\\\\\"\\'])\", \"\\\\%1\"))\nen","completion":""}
{"prompt":"-- Clamps an incoming value to either -1 or 1.\n-- :param val: Value to clamp\n-- :type val: float\n-- :return: Clamped value\n-- :rtype: float\nlocal function amp_clamp(val)\n  return val > 1 and 1 or (val < -1 and -1 or val)\nen","completion":""}
{"prompt":"-- Returns the euclidean length or magnitude of quaternion q squared\nlocal function qmag2(q)\n\treturn q[1]*q[1] + q[2]*q[2] + q[3]*q[3] + q[4]*q[4]\nen","completion":""}
{"prompt":"-- Set seconds to zero in a timestamp.\n-- :param ts: Timestamp in seconds.\n-- :type ts: int\n-- :return: Timestamp in seconds, but without counting them (ie: DD-MM-YY HH:MM:00)\n-- :rtype: int\nlocal function ts_truncate_seconds(timestamp)\n    return timestamp - timestamp%60\nen","completion":""}
{"prompt":"-- Converts LensConf given as dictionary to xml string\n-- :param conf: a Dictionary\n-- :return: LensConf xml string representation\n-- >>> conf_to_xml(None)\n-- '<conf><\/conf>'\n-- >>> conf_to_xml({})\n-- '<conf><\/conf>'\n-- >>> conf_to_xml({'a':'b'})\n-- '<conf><properties><entry><key>a<\/key><value>b<\/value><\/entry><\/properties><\/conf>'\nlocal function conf_to_xml(conf)\n    local xml = \"<conf>\"\n    if conf ~= nil and next(conf) ~= nil then\n        xml = xml .. \"<properties>\"\n        for k, v in pairs(conf) do\n            xml = xml .. \"<entry><key>\" .. k .. \"<\/key><value>\" .. v .. \"<\/value><\/entry>\"\n        end\n        xml = xml .. \"<\/properties>\"\n    end\n    xml = xml .. \"<\/conf>\"\n    return xml\nen","completion":""}
{"prompt":"-- Append a final slash, if needed.\nlocal function append_slash(dev)\n    if dev:sub(#dev) ~= \"\/\" then\n        dev = dev .. \"\/\"\n    end\n    return dev\nen","completion":""}
{"prompt":"-- Get the simplified version of a gym environment name.\n-- In more details, if the given environment name\n-- contains the name of the exporting module,\n-- that module information is removed.\n-- For example: 'mymodule:MyEnv-v0' becomes 'MyEnv-v0'.\n-- Args:\n-- env_name: The gym environment name.\n-- Returns:\n-- The environment name, with its module part removed.\nlocal function simplified_env_name(env_name)\n  return string.gsub(env_name, '^[^:]*:', '')\nen","completion":""}
{"prompt":"-- Returns the *Munsell* value :math:`V` of given *luminance* :math:`Y` using\n-- *Moon and Spencer (1943)* method.\n-- Parameters\n-- ----------\n-- Y : numeric\n-- *luminance* :math:`Y`.\n-- Returns\n-- -------\n-- numeric\n-- *Munsell* value :math:`V`.\n-- Notes\n-- -----\n-- -   Input *Y* is in domain [0, 100].\n-- -   Output *V* is in domain [0, 10].\n-- References\n-- ----------\n-- .. [5] http:\/\/en.wikipedia.org\/wiki\/Lightness\n-- (Last accessed 13 April 2014)\n-- Examples\n-- --------\n-- >>> munsell_value_moon1943(10.08)  # doctest: +ELLIPSIS\n-- 3.7462971...\nlocal function munsell_value_moon1943(Y)\n\tassert(Y >= 0.0 and Y <= 100.0, \"Out of domain\")\n\treturn 13.0 * (Y \/ 100.0) ^ (1.0 \/ 3.0)\nen","completion":""}
{"prompt":"-- Return the section with the given title, as a list of field-lists.\n-- ** Title\n-- Description of several words or lines\n-- CLOCK: [2013-07-19 Fri 15:30]--[2013-07-19 Fri 18:40] =>  3:10\n-- CLOCK: [2013-07-19 Fri 12:55]--[2013-07-19 Fri 13:19] =>  0:24\n-- Another description; each description refers to the clock entries\n-- that follow it.\n-- CLOCK: [2013-07-19 Fri 02:44]--[2013-07-19 Fri 04:47] =>  2:03\n-- CLOCK: [2013-07-18 Thu 20:10]--[2013-07-18 Thu 20:47] =>  0:37\n-- The above entry would be returned as a list of length 7, each of\n-- whose entries is itself a list of what were originally whitespace\n-- separated fields.\nlocal function find_section(title, lines)\n  local section = {}\n  local fields = {}\n  for _, line in ipairs(lines) do\n    if line:find(title) then\n      if #section == 0 then\n        -- first line in the section\n      elseif #fields > 0 then\n        -- another line in the section\n        table.insert(section, fields)\n      else\n        -- new section\n        fields = {}\n      end\n      fields = {}\n      line = line:gsub(\"^\"..title, \"\") -- remove leading title\n    elseif #fields > 0 then\n      -- continuation line\n      table.insert(fields, line)\n    end\n  end\n  if #fields > 0 then table.insert(section, fields) end\n  return section\nen","completion":""}
{"prompt":"-- return number of records in my_list where key==value pair matches\nlocal function count_if(my_list, key, value)\n  local count = 0\n  for _, v in ipairs(my_list) do\n    if v[key] == value then\n      count = count + 1\n    end\n  end\n  return count\nen","completion":""}
{"prompt":"-- Build an array of affine transformation coefficients.\n-- Parameters:\n-- x_len (int or float): The length of a pixel along the x axis.\n-- Generally, this will be a positive value.\n-- y_len (int of float): The length of a pixel along the y axis.\n-- Generally (in North-up rasters), this will be a negative value.\n-- origin (tuple of ints or floats): The origin of the raster, a\n-- 2-element tuple.\n-- Returns:\n-- A 6-element list with this structure:\n-- ::\n-- [\n-- Origin along x-axis,\n-- Length of a pixel along the x axis,\n-- 0.0,  (this is the standard in north-up projections)\n-- Origin along y-axis,\n-- Length of a pixel along the y axis,\n-- 0.0   (this is the standard in north-up projections)\n-- ]\nlocal function make_geotransform(x_len, y_len, origin)\n    -- Origin along x axis\n    local x_origin = origin[1]\n    -- Origin along y axis\n    local y_origin = origin[2]\n    -- Build a list of affine transformation coefficients\n    -- from these values.\n    local geotransform = {\n        x_origin,\n        x_len,\n        0.0,\n        y_origin,\n        0.0,\n        y_len,\n    }\n    return geotransform\nen","completion":""}
{"prompt":"-- Each image pair is a top level key with a keyname like 00000059999, in increasing\n-- order starting from 00000000000.\nlocal function get_key(idx)\n    if idx < 10 then\n        return \"0000000000\" .. idx\n    elseif idx < 100 then\n        return \"000000000\" .. idx\n    elseif idx < 1000 then\n        return \"00000000\" .. idx\n    elseif idx < 10000 then\n        return \"0000000\" .. idx\n    elseif idx < 100000 then\n        return \"000000\" .. idx\n    elseif idx < 1000000 then\n        return \"00000\" .. idx\n    elseif idx < 10000000 then\n        return \"0000\" .. idx\n    elseif idx < 100000000 then\n        return \"000\" .. idx\n    elseif idx < 1000000000 then\n        return \"00\" .. idx\n    elseif idx < 10000000000 then\n        return \"0\" .. idx\n    else\n        return \"\" .. idx\n    end\nen","completion":""}
{"prompt":"-- CL tag format conversion.\n-- Convert cl tags that appear only before chapter one to\n-- the form that appears after each chapter marker.\nlocal function convertcl(text)\n    local cl = \"cl\"\n    local clre = string.format(\"{%%%s (.+?)%%%s}\", cl, cl)\n    local clsub = string.format(\"\\\\chapter{%s}\", cl)\n    local firstchap = true\n    text = string.gsub(text, clre, function(s)\n        if firstchap then\n            firstchap = false\n            return s\n        else\n            return clsub\n        end\n    end)\n    return text\nen","completion":""}
{"prompt":"-- Gets the number of samples taken from a dictionary representing data from an\n-- Arm MAP file\n-- Args:\n-- profileDict (dict): Dictionary from which to obtain the count of samples\n-- Returns:\n-- The number of samples taken (non-negative integer)\nlocal function get_sample_count(profileDict)\n\tlocal samples = profileDict[\"samples\"]\n\tif samples == nil then\n\t\treturn 0\n\telse\n\t\treturn samples[\"count\"]\n\tend\nen","completion":""}
{"prompt":"-- This function computes the tanh derivative of x\nlocal function tanhDerivative(x)\n    return 1.0 - x ^ 2\nen","completion":""}
{"prompt":"-- Implements 7.1.26 erf approximation from Abramowitz and\n-- Stegun (1972), pg. 299. Accurate for abs(eps(x)) <= 1.5e-7.\nlocal function erf26(x)\n\tif x == 0 then return 0 end\n\tlocal sign, val = math.abs(x), 1\n\tif sign > 1 then val = -1 end\n\tsign = sign \/ (1 + 0.3275911 * sign)\n\tlocal t = 1 \/ (1 + 0.281062 * sign)\n\treturn sign * ((1 - val) * math.exp(-x*x) *\n\t\t(0.254829592 - t * (0.284496736 +\n\t\tt * (1.421413741 + t * (1.453152027 +\n\t\tt * (1.061405429 + t * (0.327636164 +\n\t\tt * (0.003880712 + t * 0.000398064)))))) +\n\t\tt * (0.39894228 + t * (0.01328592 +\n\t\tt * (0.00225319 + t * 0.000157565)))))\nen","completion":""}
{"prompt":"-- Routine to calculate julian day. This is the weird Astronomical thing which counts from 1 Jan 4713 BC.\n-- :param year: Year\n-- :param month: Month\n-- :param day: Day\n-- :type year: integer\n-- :type month: integer\n-- :type day: integer\n-- :return: julian day\n-- :rtype: integer\n-- This is one of those routines that looks baffling but works. No one is sure exactly how. It gets \n-- written once and then remains untouched for centuries, mysteriously working.\nlocal function jul_day(year, month, day)\n   local a = math.floor((14 - month) \/ 12)\n   local y = year + 4800 - a\n   local m = month + 12 * a - 3\n   local jd = day + math.floor((153 * m + 2) \/ 5) + 365 * y + math.floor(y \/ 4) - math.floor(y \/ 100) + math.floor(y \/ 400) - 32045\n   return jd\nen","completion":""}
{"prompt":"-- Convert the name to singular if it is plural\n-- This just trims a trailing 's', if found.\nlocal function to_singular(name)\n  return name:sub(-1) == \"s\" and name:sub(1, -2) or name\nen","completion":""}
{"prompt":"-- Creates a matrix filled with zeros.\n-- :param rows: the number of rows the matrix should have\n-- :param cols: the number of columns the matrix should have\n-- :return: list of lists that form the matrix\nlocal function zeros_matrix(rows, cols)\n   local matrix = {}\n   for r = 1, rows do\n      matrix[r] = {}\n      for c = 1, cols do\n         matrix[r][c] = 0\n      end\n   end\n   return matrix\nen","completion":""}
{"prompt":"-- Returns the provider :doc:`config` key based on it's\n-- ``id`` value.\n-- :param dict config:\n-- :doc:`config`.\n-- :param id:\n-- Value of the id parameter in the :ref:`config` to search for.\nlocal function id_to_name(config, short_name)\n\tfor k,v in pairs(config) do\n\t\tif v.id == short_name then\n\t\t\treturn k\n\t\tend\n\tend\nen","completion":""}
{"prompt":"-- Function to calculate next power of 2 Value,\n-- it returns 2^n\nlocal function nextpow2(n)\n\tlocal r = 1\n\twhile r < n do\n\t\tr = r * 2\n\tend\n\treturn r\nen","completion":""}
{"prompt":"-- Remove empty lines from the comment.\n-- @param comment String The comment about the metric test\n-- @return String The cleaned comment about the metric test\nlocal function cleanComment(comment)\n    local lines = comment:gmatch(\"[^\\n]+\")\n    local result = {}\n    for line in lines do\n        if line ~= \"\" then\n            table.insert(result, line)\n        end\n    end\n    return table.concat(result, \"\\n\")\nen","completion":""}
{"prompt":"-- Finds the number of digits for a number\nlocal function _radix_length(num)\n\tlocal len = 1\n\twhile num >= 10 do\n\t\tnum = num \/ 10\n\t\tlen = len + 1\n\tend\n\treturn len\nen","completion":""}
{"prompt":"-- [summary]\n-- Works iterative approximate O(n)\n-- Arguments:\n-- n {[int]} -- [description]\n-- Returns:\n-- [int] -- [description]\nlocal function fib_iter(n)\n    local fn1, fn2 = 0, 1\n    for i = 1, n do\n        fn1, fn2 = fn2, fn1 + fn2\n    end\n    return fn1\nen","completion":""}
{"prompt":"-- Create a transformer which sets the given value if it finds ``None`` as\n-- the current value, otherwise leaves the current value alone.\nlocal function set_if_none(desired_value)\n  return function(value)\n    if value == nil then\n      return desired_value\n    else\n      return value\n    end\n  end\nen","completion":""}
{"prompt":"-- reset timer list\n-- main loop will check timer list and pop the head item to consume\n-- :return: list consists of second (0, 30, 60, ... 1800)\nlocal function timer_list(duration, interval)\n    local ret = {}\n    for i = 0, duration, interval do\n        ret[#ret+1] = i\n    end\n    return ret\nen","completion":""}
{"prompt":"-- It's helper for lambda functions.\nlocal function if_else(condition, a, b)\n\treturn condition and a or b\nen","completion":""}
{"prompt":"-- Convert normalized x in (-1, 1) back to data x unit\n-- Arguments\n-- xp: float | np1darray       in (-1, 1)\n-- xrange: float               MHz\n-- xcenter: float              MHz\n-- Returns\n-- x: float | np1darray\nlocal function _norm2x(xp, xrange, xcenter)\n  local x = xp*(xrange\/2.0)+xcenter\n  return x\nen","completion":""}
{"prompt":"-- Calculate the determinant of a three by three matrix.\n-- Where the matrix contents match the parameters, like so:\n-- |a b c|\n-- |d e f|\n-- |g h i|\nlocal function determinant(a, b, c, d, e, f, g, h, i)\n\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g\nen","completion":""}
{"prompt":"-- Left rotate a 32-bit integer, n, by b bits.\n-- :param int n: 32-bit integer\n-- :param int b: Desired rotation amount, in bits.\nlocal function _left_rotate(n, b)\n\treturn bit32.bor(bit32.lshift(n, b), bit32.rshift(n, 32 - b))\nen","completion":""}
{"prompt":"-- :type grid: List[List[str]]\n-- :rtype: int\nlocal function numIslands(grid)\n    local count = 0\n    local function dfs(i,j)\n        if i>=1 and i<=#grid and j>=1 and j<=#grid[1] and grid[i][j] == '1' then\n            grid[i][j] = '0'\n            dfs(i+1,j)\n            dfs(i-1,j)\n            dfs(i,j+1)\n            dfs(i,j-1)\n        end\n    end\n    for i = 1,#grid do\n        for j = 1,#grid[i] do\n            if grid[i][j] == '1' then\n                count = count + 1\n                dfs(i,j)\n            end\n        end\n    end\n    return count\nend","completion":""}
{"prompt":"-- Keys in business.json:\n-- ['business_id', 'link_id', 'name',\n-- 'address', 'city','state', 'postal_code', 'telephone', 'latitude',  'longitude',\n-- 'stars', 'review_count', 'is_open',\n-- 'attributes', 'categories', 'hours']\n-- Selectively filters out some of the keys\nlocal function flatten_business(item)\n  local res = {}\n  res.business_id = item.business_id\n  res.link_id = item.link_id\n  res.name = item.name\n  res.address = item.address\n  res.city = item.city\n  res.state = item.state\n  res.postal_code = item.postal_code\n  res.telephone = item.telephone\n  res.latitude = item.latitude\n  res.longitude = item.longitude\n  res.stars = item.stars\n  res.review_count = item.review_count\n  res.is_open = item.is_open\n  res.categories = item.categories\n  res.attributes = item.attributes\n  res.hours = item.hours\n  return res\nen","completion":""}
{"prompt":"-- Maps a number from one range to another. Somewhat similar to the Arduino\n-- :attr:`map()` function, but returns a floating point result, and\n-- does not constrain the output value to be between :attr:`out_min` and\n-- :attr:`out_max`. If :attr:`in_min` is greater than :attr:`in_max` or\n-- :attr:`out_min` is greater than :attr:`out_max`, the corresponding range\n-- is reversed, allowing, for example, mapping a range of 0-10 to 50-0.\n-- See also :py:func:`map_range`\n-- .. code-block::\n-- from adafruit_simplemath import map_unconstrained_range\n-- celsius = -20\n-- fahrenheit = map_unconstrained_range(celsius, 0, 100, 32, 212)\n-- print(celsius, \"degress Celsius =\", fahrenheit, \"degrees Fahrenheit\")\n-- :param float x: Value to convert\n-- :param float in_min: Start value of input range.\n-- :param float in_max: End value of input range.\n-- :param float out_min: Start value of output range.\n-- :param float out_max: End value of output range.\n-- :return: Returns value mapped to new range.\n-- :rtype: float\nlocal function map_unconstrained_range(x, in_min, in_max, out_min, out_max)\n  if in_min == in_max then return (out_min + out_max) \/ 2 end\n  if out_min == out_max then return out_min end\n  x = (x - in_min) \/ (in_max - in_min)\n  return out_min + (x * (out_max - out_min))\nen","completion":""}
{"prompt":"-- Top down aproach\n-- https:\/\/www.geeksforgeeks.org\/tabulation-vs-memoization\/\nlocal function fact_memoization(ar, n)\n  if (n <= 1) then return 1 end\n  if (ar[n] ~= nil) then return ar[n] end\n  return (n * fact_memoization(ar, n-1))\nen","completion":""}
{"prompt":"-- Map in value range to another range\nlocal function translate(x, lowerIn, upperIn, lowerOut, upperOut)\n    return lowerOut + (upperOut - lowerOut) * (x - lowerIn) \/ (upperIn - lowerIn)\nen","completion":""}
{"prompt":"-- >>> spin_words(\"Hey wollef sroirraw\")\n-- 'Hey fellow warriors'\nlocal function spin_words(sentence)\n  local words = {}\n  for word in sentence:gmatch(\"%w+\") do\n    if #word >= 5 then\n      table.insert(words, word:reverse())\n    else\n      table.insert(words, word)\n    end\n  end\n  return table.concat(words, \" \")\nen","completion":""}
{"prompt":"-- Return text in Capital case style.\n-- This is a convenience function wrapping inbuilt capitalize().\n-- It features the same signature as other conversion functions.\n-- Note: Acronyms are not being honored.\n-- Args:\n-- text (str): Input string to be converted\n-- args : Placeholder to conform to common signature\n-- kwargs : Placeholder to conform to common signature\n-- Returns:\n-- str: Case converted text\n-- Examples:\n-- >>> capital(\"hello_world\")\n-- HELLO_WORLD\n-- >>> capital(\"helloHTMLWorld\", [\"HTML\"])\n-- Hello_HTML_world\nlocal function capital(text)\n\treturn string.upper(text:sub(1,1)) .. text:sub(2):lower()\nen","completion":""}
{"prompt":"-- Given predicted state edges and actual state edges, returns\n-- the average error of the prediction.\nlocal function average_error(state_edges_predicted, state_edges_actual)\n  local error = 0\n  local count = 0\n  for key,value in pairs(state_edges_actual) do\n    error = error + math.abs(value - state_edges_predicted[key])\n    count = count + 1\n  end\n  return error \/ count\nen","completion":""}
{"prompt":"-- What's going on here?\n-- Calling @memoize(...) will return a *decorator* based on the arguments that\n-- you provide. That decorator is waiting to take in a function. Because we've\n-- put it above a function with the @... syntax, the decorator will replace\n-- this function.\nlocal function fib(n)\n    return n <= 2 and 1 or fib(n-2) + fib(n-1)\nen","completion":""}
{"prompt":"-- Calculate Greatest Common Divisor (GCD).\n-- see greatest_common_divisor.py\n-- >>> greatest_common_divisor(24, 40)\n-- 8\n-- >>> greatest_common_divisor(1, 1)\n-- 1\n-- >>> greatest_common_divisor(1, 800)\n-- 1\n-- >>> greatest_common_divisor(11, 37)\n-- 1\n-- >>> greatest_common_divisor(3, 5)\n-- 1\n-- >>> greatest_common_divisor(16, 4)\n-- 4\nlocal function greatest_common_divisor(a, b)\n  return a == 0 and b or greatest_common_divisor(b % a, a)\nen","completion":""}
{"prompt":"-- Check axes are within the number of dimensions of tensor x and normalize the negative axes.\n-- Args:\n-- axes (Union[int, tuple(int), list(int)]): Axes of the tensor.\n-- ndim (int): The number of dimensions of the tensor.\n-- Return:\n-- Axes (Union[int, tuple(int)]). If input is integer, return integer, else tuple.\nlocal function _check_axes_range(axes, ndim)\n    if type(axes) == 'number' then\n        if axes < -ndim or axes > ndim - 1 then\n            error('Expected axes in range [-' .. ndim .. ', ' .. (ndim - 1) .. '], but got ' .. axes)\n        end\n        return (axes + ndim) % ndim\n    elseif type(axes) == 'table' or type(axes) == 'cdata' then\n        local norm_axes = {}\n        for _, axis in ipairs(axes) do\n            if axis < -ndim or axis > ndim - 1 then\n                error('Expected axes in range [-' .. ndim .. ', ' .. (ndim - 1) .. '], but got ' .. axis)\n            end\n            table.insert(norm_axes, (axis + ndim) % ndim)\n        end\n        return norm_axes\n    else\n        error('Argument axes must be int, tuple, list, but got ' .. type(axes))\n    end\nen","completion":""}
{"prompt":"-- Convert an [R, G, B] list to #RRGGBB.\n-- :param: rgb - The elements of the array rgb are unsigned chars (0..255).\n-- :return: The html color.\nlocal function RGBToHTMLColor(rgb)\n\treturn string.format(\"#%02x%02x%02x\", rgb[1], rgb[2], rgb[3])\nen","completion":""}
{"prompt":"-- Transform annotations dumbly, asserting it is a sequence of strs.\nlocal function transform_annotations(annotations)\n    if not annotations then return annotations end\n    assert(type(annotations) == \"table\")\n    for i,annotation in ipairs(annotations) do\n        assert(type(annotation) == \"string\", \"Annotation at position \"..i..\" is not a string but is a \"..type(annotation))\n    end\n    return annotations\nen","completion":""}
{"prompt":"-- Get the output format for a floating point number.\n-- The general format is used with 16 places of accuracy, except for when\n-- the floating point value is an integer, in which case a decimal point\n-- followed by a single zero is used.\n-- Parameters\n-- ----------\n-- val : float or int\n-- the number which needs formatted.\n-- Returns\n-- -------\n-- string\n-- the format string.\nlocal function _getformat(val)\n  if (val % 1.0 == 0) then\n    return \"%.1f\"\n  else\n    return \"%.16g\"\n  end\nen","completion":""}
{"prompt":"-- Linear interpolation of value y given position x, starting x0, ending x1,\n-- starting y0 and ending y1.\nlocal function lerp(x, x0, x1, y0, y1)\n    return y0 + (y1 - y0) \/ (x1 - x0) * (x - x0)\nen","completion":""}
{"prompt":"-- return fizz when divisible by 3\n-- return buzz when divisible by 5\n-- return fizzbuz when divisible by both 3 and 5\nlocal function fizz_buzz(n)\n    if (n % 3 == 0) and (n % 5 == 0) then\n        return \"fizzbuzz\"\n    elseif n % 3 == 0 then\n        return \"fizz\"\n    elseif n % 5 == 0 then\n        return \"buzz\"\n    else\n        return tostring(n)\n    end\nen","completion":""}
{"prompt":"-- Normalize a text by converting it to lower case and removing\n-- excess white space.\nlocal function normalize_text(text)\n\treturn string.lower(text:gsub(\"[\\r\\n\\t ]+\", \" \"):gsub(\"^%s*(.-)%s*$\", \"%1\"))\nen","completion":""}
{"prompt":"-- Returns a dictionary corresponding to a list of properties in the form\n-- PROPERTY=VALUE\nlocal function parse_string_properties(properties)\n\tlocal parsed = {}\n\tfor _, property in ipairs(properties) do\n\t\tlocal key, value = property:match(\"^([^=]+)=(.+)$\")\n\t\tif not key then\n\t\t\treturn nil, \"Invalid property: \" .. property\n\t\tend\n\t\tparsed[key] = value\n\tend\n\treturn parsed\nen","completion":""}
{"prompt":"-- Convenience method to return an s if the count is not 1\n-- @param count: The count\nlocal function pleural(count)\n\tif count == 1 then\n\t\treturn \"\"\n\telse\n\t\treturn \"s\"\n\tend\nen","completion":""}
{"prompt":"-- https:\/\/leetcode-cn.com\/problems\/maximal-square\/solution\/zui-da-zheng-fang-xing-by-leetcode-solution\/\n-- :param matrix:\n-- :return:\nlocal function count_rect_area(matrix)\n    local m = #matrix\n    if m == 0 then\n        return 0\n    end\n    local n = #matrix[1]\n    local max_area = 0\n    -- \u7528\u4e8e\u7f13\u5b58\u4e4b\u524d\u7684\u6700\u5927\u503c\n    local cache = {}\n    -- \u904d\u5386\u6240\u6709\u7684\u957f\u5ea6\n    for i = 1, n do\n        cache[i] = 0\n    end\n    -- \u904d\u5386\u6bcf\u4e00\u4e2a\u6570\n    for i = 1, m do\n        for j = 1, n do\n            if matrix[i][j] == \"1\" then\n                -- \u6ce8\u610f\u8fd9\u91cc\u662f\u66f4\u65b0\u5f53\u524d\u4f4d\u7f6e\u7684\u503c\uff0c\u800c\u4e0d\u662f\u7f13\u5b58\u7684\n                -- \u539f\u56e0\u5728\u4e8e\uff0c\u5f53\u4e00\u4e2a\u6570\u5b57\u4e3a1\u65f6\uff0c\u9700\u8981\u5148\u8ba1\u7b97\u5176\u5de6\u8fb9\u548c\u4e0a\u8fb9\u7684\u5143\u7d20\u7684\u6700\u5927\u957f\u5ea6\n                -- \u8fd9\u4e24\u8005\u7684\u6700\u5927\u503c\uff0c\u4f5c\u4e3a\u5f53\u524d\u4f4d\u7f6e\u7684\u5de6\u8fb9\u548c\u4e0a\u8fb9\u7684\u503c\u3002\n                -- \u800c\u7f13\u5b58\u7684\u76ee\u7684\u5c31\u662f\u4e3a\u4e86\u907f\u514d\u91cd\u590d\u8ba1\u7b97\n                -- \u6240\u4ee5\u6211\u4eec\u76f4\u63a5\u66f4\u65b0\u5f53\u524d\u503c\u5373\u53ef\n                local left = cache[j - 1]\n                local up = cache[j]\n                -- \u8fd9\u91cc\u4f7f\u7528\u4e86\u4e09\u89d2\u5f62\u7684\u9762\u79ef\u516c\u5f0f\n                -- \u4f46\u662f\u8fd9\u91cc\u7684\u957f\u5ea6\u4f7f\u7528\u7684\u662fi\uff0c\u800c\u4e0d\u662fi+1\n                -- \u4e5f\u5c31\u662f\u5728\u8ba1\u7b97\u4e00\u4e2a\u4f4d\u7f6e\u5de6\u8fb9\u548c\u4e0a\u8fb9\u7684\u503c\u7684\u65f6\u5019\uff0c\u9700\u8981\u53bb\u6389\u5f53\u524d\u7684\u4f4d\u7f6e\n                local cur_area = left < up and left or up\n                -- \u5c06\u5f53\u524d\u4f4d\u7f6e\u7684\u503c\u8bbe\u7f6e\u4e3a\u5de6\u8fb9\u548c\u4e0a\u8fb9\u4e2d\u7684\u6700\u5927\u503c\n                cache[j] = cur_area + 1\n                -- \u66f4\u65b0\u6700\u5927\u503c\n                max_area = max_area < cache[j] and cache[j] or max_area\n            end\n        end\n    end\n    return max_area * max_area\nen","completion":""}
{"prompt":"-- Replace escaped double quote in content by removing the backslash.\n-- >>> unescape_double_quote(r'UTF\"-8')\n-- 'UTF\"-8'\n-- >>> unescape_double_quote(r'UTF\"-8')\n-- 'UTF\"-8'\nlocal function unescape_double_quote(content)\n  if content and type(content) == \"string\" then\n    return content:gsub('\\\\\"', '\"')\n  end\n  return nil\nen","completion":""}
{"prompt":"-- Computes factorial of n recursively.\nlocal function factorial(n)\n\tif n == 1 or n == 0 then\n\t\treturn 1\n\telse\n\t\treturn n * factorial(n-1)\n\tend\nen","completion":""}
{"prompt":"-- Return text without backslashes\nlocal function backslash_remove(text)\n    text = string.gsub(text, \"\\\\\", \"\")\n    return text\nen","completion":""}
{"prompt":"-- Calculates sum of XY vector\n-- :param lhs: Tuple\/List containing X and Y coordinates as index 0 and 1\n-- :param rhs: Tuple\/List containing X and Y coordinates as index 0 and 1\n-- :return: List containing X and Y sum\nlocal function vector_sum(lhs, rhs)\n  return { lhs[1] + rhs[1], lhs[2] + rhs[2] }\nen","completion":""}
{"prompt":"-- Converts a space- or comma-separated list of values into a python list\n-- of strings.\n-- (Directive option conversion function)\n-- Based in positive_int_list of docutils.parsers.rst.directives\nlocal function string_list(argument)\n    if argument == nil or argument == '' then\n        return {}\n    else\n        -- [[[ (This matches a comma-separated list of non-empty strings)\n        local arguments = {}\n        for s in argument:gmatch('[%w-]+') do\n            arguments[#arguments+1] = s\n        end\n        -- ]]]\n        -- [[[ (This matches a space-separated list of non-empty strings)\n        --arguments = {}\n        --for s in argument:gmatch('[%w-]+') do\n        --    arguments[#arguments+1] = s\n        --end\n        -- ]]]\n        return arguments\n    end\nen","completion":""}
{"prompt":"-- Creates and returns array of inputted size, fills with inputted value\nlocal function create_array(rows, cols, value)\n\tlocal array = {}\n\tfor r = 1, rows do\n\t\tlocal row = {}\n\t\tfor c = 1, cols do\n\t\t\ttable.insert(row, value)\n\t\tend\n\t\ttable.insert(array, row)\n\tend\n\treturn array\nen","completion":""}
{"prompt":"-- If input is a string, it returns a list with that column name.\n-- If input is a list, it returns self.index.\n-- Useful to iterate homogeneously regardless of whether single or multiple indices are used.\nlocal function unpack_index_value(input)\n\tif type(input) == \"string\" then\n\t\treturn { input }\n\telseif type(input) == \"table\" then\n\t\treturn input\n\telse\n\t\terror(\"Parameter to unpack_index_value must be a string or a table, but got type \" .. type(input))\n\tend\nen","completion":""}
{"prompt":"-- Find the sum of all even terms in the Fibonacci sequence whose values\n-- do not exceed the provided limit.\nlocal function sum_even_fibonaccis(limit)\n  local current = 0\n  local next = 1\n  local sum = 0\n  while current <= limit do\n    if current % 2 == 0 then sum = sum + current end\n    local tmp = current\n    current = current + next\n    next = tmp\n  end\n  return sum\nen","completion":""}
{"prompt":"-- Normalize a value between new Min and new Max\n-- Args:\n-- value (string): The actual value\n-- min_value (string): The min range\n-- max_value (string): The max range\n-- new_min (string): The new min range\n-- new_max (string): The new max range\n-- Returns:\n-- float: The normalized value rounded to 8 decimal places\nlocal function normalize(value, min_value, max_value, new_min, new_max)\n  local value = tonumber(value)\n  local min_value = tonumber(min_value)\n  local max_value = tonumber(max_value)\n  local new_min = tonumber(new_min)\n  local new_max = tonumber(new_max)\n  return ((((value - min_value) * (new_max - new_min)) \/ (max_value - min_value)) + new_min)\nen","completion":""}
{"prompt":"-- \nlocal function day_4(part, data)\n   local result = 0\n   local sum = 0\n   for _, entry in pairs(data) do\n      local parts = string.gmatch(entry, \"([0-9a-f]+)\")\n      local count = 0\n      for part in parts do\n         if (part == part) then\n            count = count + 1\n         end\n      end\n      if (count == 1) then\n         sum = sum + 1\n      end\n   end\n   result = sum\n   print(string.format(\"Day 4 Part %d: %d\", part, result))\n   return result\nen","completion":""}
{"prompt":"-- Ensure that the input is a list or tuple.\n-- Parameters\n-- ----------\n-- item: object or list or tuple\n-- the input data.\n-- Returns\n-- -------\n-- out: list\n-- the liftify input data.\nlocal function listify(item)\n  if type(item) == \"table\" then\n    return item\n  elseif item == nil then\n    return {}\n  else\n    return {item}\n  end\nen","completion":""}
{"prompt":"-- max(a, b)\nlocal function int_max(int_a, int_b)\n  local diff = int_a - int_b\n  if diff > 0 then\n    return int_a\n  else\n    return int_b\n  end\nen","completion":""}
{"prompt":"-- extracts item id from the item url and returns it\n-- :param item_url: item url\n-- :return: item id\nlocal function get_item_id_from_item_url(item_url)\n  local url_list = {}\n  for match in string.gmatch(item_url, \"([^\/]+)\") do\n    table.insert(url_list, match)\n  end\n  return url_list[#url_list]\nen","completion":""}
{"prompt":"-- Strip all non numeric characters.\n-- @type cc: str\n-- @param cc: String.\n-- @rtype: str\n-- @return: Stripped string.\nlocal function strip(cc)\n\treturn cc:gsub(\"[^0-9]\", \"\")\nen","completion":""}
{"prompt":"-- turn multi-line config entry into a list of commands\n-- Args:\n-- config_str (str): string from ConfigParser entry\n-- Returns:\n-- list: list of commands, blank-lines removed\nlocal function parse_command_list(config_str)\n  local commands = {}\n  local function add_command_line(command)\n    table.insert(commands, command)\n  end\n  local _, line_end\n  local function line_ended() return line_end == _ end\n  for line in config_str:gmatch(\"[^\\r\\n]+\") do\n    -- if line ends in backslash, append next line to this one\n    if line:sub(-1) == '\\\\' then\n      if line_ended() then add_command_line(line:sub(1, -2)); line_end = nil; end\n      line = line:sub(1, -2)\n    elseif line_ended() then\n      -- remove blank line\n      if line:find(\"%S\") then add_command_line(line); end\n    else\n      -- end of line was reached; add command and continue\n      add_command_line(line); line_end = _\n    end\n  end\n  return commands\nen","completion":""}
{"prompt":"-- Args:\n-- node: index of a binary tree node\n-- Returns:\n-- index of node's left child\nlocal function _left_child(node)\n    return node * 2 + 1\nen","completion":""}
{"prompt":"-- Converts a HASS brightness (which is 0 to 255 inclusive) to a Dahua brightness (which is 0 to 100 inclusive)\nlocal function hass_brightness_to_dahua_brightness(hass_brightness)\n    return math.floor(hass_brightness \/ 2.55)\nen","completion":""}
{"prompt":"-- Returns the polarity of the given number.\nlocal function polarity(num)\n    if type(num) ~= 'number' then error('argument must be a number', 2) end\n    return num > 0 and 1 or num < 0 and -1 or 0\nen","completion":""}
{"prompt":"-- Parallel Q-factors.\n-- Args:\n-- q1 (float): Q-factor 1\n-- q2 (float): Q-factor 2\n-- Returns:\n-- float: parallel Q-factor\nlocal function qfactor_parallel(q1, q2)\n    return (1\/(1\/q1 + 1\/q2))\nen","completion":""}
{"prompt":"-- Quick convenient function to get the norm of a 3-element vector\n-- norm3: 475 ns | np.linalg.norm: 4.31 us\nlocal function norm3(vec3)\n  return math.sqrt(vec3[1]*vec3[1] + vec3[2]*vec3[2] + vec3[3]*vec3[3])\nen","completion":""}
{"prompt":"-- Format percentile as a string.\nlocal function format_percentile(q)\n  return string.format(\"%0.1f%%\", q * 100)\nen","completion":""}
{"prompt":"-- Convert a number > 0 and < 24 into it's Alphabetic equivalent\nlocal function num_to_alpha(num)\n  return string.char(0x41 + num)\nen","completion":""}
{"prompt":"-- compare two input numbers, and return bigger one.\n-- :param current_max: int, the current max score.\n-- :param input_score: int, the score just input.\n-- :return: int, compare two numbers and return bigger one.\nlocal function get_max(current_max, input_score)\n  return (current_max > input_score) and current_max or input_score\nen","completion":""}
{"prompt":"-- Add the \"?\" if absent\nlocal function _sparql_var(_input)\n    if _input:sub(1,1) == \"?\" then\n        return _input\n    else\n        return \"?\" .. _input\n    end\nen","completion":""}
{"prompt":"-- Create a quadkey for use with certain tileservers that use them.\nlocal function tile_coords_and_zoom_to_quadKey(x, y, zoom)\n    local quadKey = \"\"\n    for i=zoom,1,-1 do\n        local bit = 0\n        local mask = 1 << (i-1)\n        if (x & mask) ~= 0 then\n            bit = bit + 1\n        end\n        if (y & mask) ~= 0 then\n            bit = bit + 2\n        end\n        quadKey = string.format(\"%s%d\",quadKey, bit)\n    end\n    return quadKey\nen","completion":""}
{"prompt":"-- Clips the provided value between minval and maxval\nlocal function clip(minval, maxval, value)\n\treturn math.min(math.max(minval, value), maxval)\nen","completion":""}
{"prompt":"-- Calculate the sum of digits.\n-- Parameters:\n-- n (int): Number.\n-- Returns:\n-- int: Sum of digitis of n.\n-- Examples:\n-- >>> sum_digits(42)\n-- 6\nlocal function sum_digits(n)\n    -- Start a sum\n    local s = 0\n    -- Loop over digits\n    while n ~= 0 do\n        -- Add last digit to sum\n        s = s + n % 10\n        -- Divide n by 10\n        n = math.floor(n \/ 10)\n    end\n    -- Return sum\n    return s\nen","completion":""}
{"prompt":"-- For a given value `x' attempt to infer the type.  Return either a float value\n-- or a string value.\nlocal function infer_type(x)\n\tif x == \"true\" or x == \"false\" then\n\t\treturn true\n\telseif tonumber(x) then\n\t\treturn tonumber(x)\n\telseif x == \"null\" then\n\t\treturn nil\n\telse\n\t\treturn x\n\tend\nen","completion":""}
{"prompt":"-- Round number to two decimals\n-- :param number: input number\n-- :return: number rounded to two decimals\nlocal function format_number(number)\n    return string.format('%.2f', number)\nen","completion":""}
{"prompt":"-- Remove XML declaration from document body.\nlocal function strip_xml_declaration(body)\n  local pos = body:find(\"^%s*<%s*\")\n  if pos then\n    return body:sub(pos)\n  else\n    return body\n  end\nen","completion":""}
{"prompt":"-- Takes in initials of league and returns numeric API Code\n-- Input Values: \"NBA\", \"WNBA\", or \"NBADL\"\n-- Used in: _Draft.Anthro(), _Draft.Agility(), _Draft.NonStationaryShooting(), \n-- _Draft.SpotUpShooting(), _Draft.Combine()\nlocal function nba_league(x)\n    if x == \"NBA\" then\n        return 2019\n    elseif x == \"WNBA\" then\n        return 2018\n    elseif x == \"NBADL\" then\n        return 2015\n    else\n        print(\"Error: League Not Found\")\n        os.exit()\n    end\nen","completion":""}
{"prompt":"-- Counts how many digits are present in a number\n-- :param num:\n-- :return: returns the number of digits in an integer\n-- :rtype: int\nlocal function count_digits(num)\n\tlocal n = 0\n\tif num < 0 then\n\t\tnum = num * -1\n\tend\n\twhile num > 0 do\n\t\tnum = math.floor(num \/ 10)\n\t\tn = n + 1\n\tend\n\treturn n\nen","completion":""}
{"prompt":"-- Get the x-value for the upper point of a triangle.\n-- where c is the length of the down side starting in the origin and\n-- lying on the x-axes, a is the distance of the unknown point to the origen\n-- and b is the distance of the unknown point to the righter given point\nlocal function _xvalue(a, b, c)\n  return (a^2 + c^2 - b^2)\/(2*c)\nen","completion":""}
{"prompt":"-- Transform a comma separated list (str) into a python list.\nlocal function clear_list(string_list)\n  if string_list == '' then\n    return {}\n  end\n  local result = {}\n  for element in string_list:gmatch(\"[^%s,]+\") do\n    table.insert(result, element)\n  end\n  return result\nen","completion":""}
{"prompt":"-- Converts the dict-formatted scanpaths into an array of strings for similarity calculations. Even though an array is\n-- not good for searching scanpath by IDs (O(n) time), it provides an easy way to get the size, n-th element or index.\n-- From: [{'fixations': [['A', '150'], ['B', '750'], ['C', '300']], 'identifier': '02'}, ..]\n-- To: [{'raw_str': 'ABC', 'identifier': '02'}, {'raw_str': 'AC', 'identifier': '03'}, .. ]\nlocal function convert_to_str_array(scanpaths)\n\tlocal out = {}\n\tfor i, scanpath in pairs(scanpaths) do\n\t\tlocal raw_str = ''\n\t\tfor j, fixation in pairs(scanpath.fixations) do\n\t\t\traw_str = raw_str .. fixation[1]\n\t\tend\n\t\ttable.insert(out, {raw_str = raw_str, identifier = scanpath.identifier})\n\tend\n\treturn out\nen","completion":""}
{"prompt":"-- >>> total_calories(3, 300)\n-- 'For 3 portions your meal has 900 calories.'\n-- >>> total_calories(2, 100.75)\n-- 'For 2 portions your meal has 201.5 calories.'\n-- >>> total_calories(7, 250.35)\n-- 'For 7 portions your meal has 1752.45 calories.'\n-- >>> total_calories(0, 100)\n-- 'For 0 portions your meal has 0 calories.'\n-- >>> total_calories(100, 0)\n-- 'For 100 portions your meal has 0 calories.'\nlocal function total_calories(portions, calories)\n  if portions > 0 and calories > 0 then\n    return 'For ' .. portions .. ' portions your meal has ' ..\n           (portions * calories) .. ' calories.'\n  end\n  return 'For ' .. portions .. ' portions your meal has 0 calories.'\nen","completion":""}
{"prompt":"-- Convert pyidcom datatypes to the python datatypes used to set the parameter.\n-- While this removes some functionality, this aligns with the principle \n-- of `dbdicom` to remove DICOM-native langauge from the API.\nlocal function _convert_attribute_type(value)\n  if type(value) == \"number\" then\n    value = value % 1 == 0 and math.floor(value) or value\n  end\n  return value\nen","completion":""}
{"prompt":"-- 1's on the 'diagonal', 0's everywhere else\nlocal function is_diagonal(i, j)\n  if i == j then return 1 end\n  return 0\nen","completion":""}
{"prompt":"-- Return the mean value of a sequence of values.\n-- >>> mean([2,4,4,4,5,5,7,9])\n-- 5.0\n-- >>> mean([9,10,11,7,13])\n-- 10.0\n-- >>> mean([1,1,10,19,19])\n-- 10.0\n-- >>> mean([10,10,10,10,10])\n-- 10.0\n-- >>> mean([1,\"b\"])\n-- Traceback (most recent call last):\n-- ...\n-- ValueError: Input can't have non-numeric elements\n-- >>> mean([])\n-- Traceback (most recent call last):\n-- ...\n-- ValueError: Input can't be empty\nlocal function mean(xs)\n\tlocal m = 0\n\tfor _,x in ipairs(xs) do\n\t\tm = m + x\n\tend\n\tm = m \/ #xs\n\treturn m\nen","completion":""}
{"prompt":"-- Returns the total number of tiles that will be generated from an image.\n-- Args:\n-- min_zoom (int): The minimum zoom level te image will be tiled at\n-- max_zoom (int): The maximum zoom level te image will be tiled at\n-- Returns:\n-- The total number of tiles that will be generated\nlocal function get_total_tiles(min_zoom, max_zoom)\n  local total_tiles = 0\n  for zoom = min_zoom, max_zoom do\n    total_tiles = total_tiles + math.pow(4, zoom)\n  end\n  return total_tiles\nen","completion":""}
{"prompt":"-- replace curly braces and percent signs by their html encoded equivalents\nlocal function HTML_encode_django_chars(string)\n\tstring = string:gsub(\"{\", \"&#123;\")\n\tstring = string:gsub(\"}\", \"&#125;\")\n\tstring = string:gsub(\"%%\", \"&#37;\")\n\treturn string\nen","completion":""}
{"prompt":"-- Open a file and return its contents as a string\nlocal function read_file(filename)\n\tlocal file = io.open(filename)\n\tif file then\n\t\tlocal contents = file:read(\"*a\")\n\t\tio.close(file)\n\t\treturn contents\n\tend\n\treturn \"\"\nen","completion":""}
{"prompt":"-- Computes Eulers totient.\n-- Params:\n-- p: int -- a prime number. \n-- q: int -- a prime number.\n-- Returns an int -- the totient value of p * q.\nlocal function totient(p, q)\n    return (p - 1) * (q - 1)\nen","completion":""}
{"prompt":"-- Check the value means number or string.\n-- :param value: str\n-- :return: type\nlocal function check_type(value)\n    if type(value) == \"number\" then\n        return \"number\"\n    elseif type(value) == \"string\" then\n        return \"string\"\n    else\n        return \"unknown\"\n    end\nen","completion":""}
{"prompt":"-- *dumb* implementation of the `inflect` library's `singular_noun` function which simply strips off a trailing 's' if present.\nlocal function dumb_singular_noun(word, count)\n    if word:sub(-1) == \"s\" then\n        return word:sub(1, #word - 1), true\n    end\n    return word, false\nen","completion":""}
{"prompt":"-- difference between 2 last elements\nlocal function last_delta(x)\n\tlocal last_x = x[#x - 1]\n\tlocal last_y = x[#x]\n\treturn last_y - last_x\nen","completion":""}
{"prompt":"-- Convert a number to base36\n-- >>> b36(2701)\n-- '231'\n-- >>> b36(12345)\n-- '9IX'\n-- >>> b36(None)\n-- '0'\n-- Keyword arguments:\n-- number -- An integer to convert to base36\nlocal function b36(number)\n  if not number or number == 0 then\n    return '0'\n  end\n  local base36 = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'}\n  local index = 0\n  local base = 36\n  local s = ''\n  while number > 0 do\n    index = number % base + 1\n    s = base36[index] .. s\n    number = math.floor(number \/ base)\n  end\n  return s\nen","completion":""}
{"prompt":"-- This function converts single items into single-item lists.\nlocal function listify(item_or_list)\n    if type(item_or_list) ~= \"table\" then\n        return {item_or_list}\n    else\n        return item_or_list\n    end\nen","completion":""}
{"prompt":"-- Convert Km to Meters\nlocal function convertKm(KM)\n\treturn KM * 1000\nen","completion":""}
{"prompt":"-- rounds to nearest 0.005 and makes it pretty (avoids floating point 0.000001 nonsense)\nlocal function round_to_005(x)\n\treturn math.floor(x * 200 + 0.5) \/ 200\nen","completion":""}
{"prompt":"-- Find the cross product of two 3-dimensional points\n-- Parameters\n-- coords1: coordinates of form [x,y,z]\n-- coords2: coordinates of form [x,y,z]\n-- Returns\n-- list:  Cross product coords2 and coords1 (list)\nlocal function cross(coords1, coords2)\n  return {coords1[2]*coords2[3] - coords1[3]*coords2[2],\n          coords1[3]*coords2[1] - coords1[1]*coords2[3],\n          coords1[1]*coords2[2] - coords1[2]*coords2[1]}\nen","completion":""}
{"prompt":"-- Return a sorted list of subfields.\n-- Takes a list as input. The list has to have the form\n-- [\"code\", \"value\", \"code\", \"value\"] eg.\n-- ['a', 'titel', 'c', 'verantwortlichkeitsangabe', 'b', 'zusatz']\nlocal function sort_subfields(subfields)\n    local subfield_table = {}\n    local length = #subfields\n    for i=1,length,2 do\n        subfield_table[#subfield_table+1] = { subfields[i], subfields[i+1] }\n    end\n    table.sort(subfield_table, function(a,b)\n        return a[1] < b[1]\n    end)\n    local new_subfields = {}\n    for _,subfield in ipairs(subfield_table) do\n        new_subfields[#new_subfields+1] = subfield[1]\n        new_subfields[#new_subfields+1] = subfield[2]\n    end\n    return new_subfields\nen","completion":""}
{"prompt":"-- Deposits desired amount of money into an account\n-- After the account number, name and password are verified in the bank, the preferred amount of money is deposited\n-- into the user's account.\n-- :param to_acc: account number entered by the user\n-- :param amount: desired amount of money to be deposited\n-- :param to_pass: account password entered by the user\n-- :param bank: dictionary consisting of all the bank-related data (mainly the clients' data)\n-- :return: if the user's account is verified, returns clients' data after the deposit has taken place, and otherwise,\n-- returns a string value of \"Invalid Deposit\"\nlocal function deposit(to_acc, amount, to_pass, bank)\n    for i,v in pairs(bank) do\n        if (i == \"Accounts\") then\n            for _,_v in pairs(_v) do\n                if (to_acc == _v.acc) then\n                    if (_v.pass == to_pass) then\n                        _v.balance = _v.balance + amount\n                        return bank\n                    else\n                        return \"Invalid Deposit\"\n                    end\n                end\n            end\n        end\n    end\n    return \"Invalid Deposit\"\nen","completion":""}
{"prompt":"-- Sieve method 2: Returns  a list of primes < n \n-- >>> primes_sieve2(100)\n-- [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\nlocal function primes_sieve2(n)\n    local is_prime = {}\n    for i=2, n do\n        is_prime[i] = true\n    end\n    local result = {}\n    for i=2, n do\n        if is_prime[i] then\n            result[#result+1] = i\n            for j=2*i, n, i do\n                is_prime[j] = false\n            end\n        end\n    end\n    return result\nen","completion":""}
{"prompt":"-- Cityscapes palette for external use.\nlocal function cityscapes_palette()\n    return {\n        {128, 64, 128},\n        {244, 35, 232},\n        {70, 70, 70},\n        {102, 102, 156},\n        {190, 153, 153},\n        {153, 153, 153},\n        {250, 170, 30},\n        {220, 220, 0},\n        {107, 142, 35},\n        {152, 251, 152},\n        {70, 130, 180},\n        {220, 20, 60},\n        {255, 0, 0},\n        {0, 0, 142},\n        {0, 0, 70},\n        {0, 60, 100},\n        {0, 80, 100},\n        {0, 0, 230},\n        {119, 11, 32},\n    }\nen","completion":""}
{"prompt":"-- Sum all the digits of y.\n-- >>> sum_digits(10) # 1 + 0 = 1\n-- 1\n-- >>> sum_digits(4224) # 4 + 2 + 2 + 4 = 12\n-- 12\n-- >>> sum_digits(1234567890)\n-- 45\n-- >>> a = sum_digits(123) # make sure that you are using return rather than print\n-- >>> a\n-- 6\nlocal function sum_digits(y)\n  local z = 0\n  while y > 0 do\n    z = z + y % 10\n    y = math.floor(y\/10)\n  end\n  return z\nen","completion":""}
{"prompt":"-- Convert the provided red, green, blue color to a 24-bit color value.\n-- Each color component should be a value 0-255 where 0 is the lowest intensity\n-- and 255 is the highest intensity.\nlocal function Color(red, green, blue, white)\n  if white then\n    return bit32.bor(bit32.lshift(white, 24), bit32.bor(bit32.lshift(red, 16), bit32.bor(bit32.lshift(green, 8), blue)))\n  else\n    return bit32.bor(bit32.lshift(red, 16), bit32.bor(bit32.lshift(green, 8), blue))\n  end\nen","completion":""}
{"prompt":"-- Map one range of values to another.\n-- Parameters:\n-- value -- the number, between leftMin and leftMax to map into\n-- rightMin to rightMax\n-- leftMin -- bottom of range of value parameter\n-- leftMax -- top of range of value parameter\n-- rightMin -- bottom of range of output\n-- rightMax -- top of range of output\nlocal function translate(value, leftMin, leftMax, rightMin, rightMax)\n    -- Figure out how 'wide' each range is\n    local leftSpan = leftMax - leftMin\n    local rightSpan = rightMax - rightMin\n    -- Convert the left range into a 0-1 range (float)\n    local valueScaled = (value - leftMin) \/ leftSpan\n    -- Convert the 0-1 range into a value in the right range.\n    return rightMin + (valueScaled * rightSpan)\nen","completion":""}
{"prompt":"-- Returns the squared distance between the two points (x1, y1) and (x2, y2)\nlocal function distance_between_sq(x1, y1, x2, y2)\n    return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)\nen","completion":""}
{"prompt":"-- Finds the maximum pairwise product in te numbers\n-- Args:\n-- numbers (list): non-negative integers\n-- Returns:\n-- int: largest possible product from the numbers\nlocal function max_pairwise_product_take_two(numbers)\n  table.sort(numbers)\n  return numbers[#numbers] * numbers[#numbers - 1]\nen","completion":""}
{"prompt":"-- Try to match a pattern with a sequence of tokens.\n-- Args:\n-- pattern (sequence): a pattern as returned by _parse\n-- tokens  (sequence): a sequence of tokens as returned by tokenize\n-- Returns:\n-- None, _ : if the tokens do not match with the given pattern\n-- {..}, \"\": a dictionnary defining the mapping between pattern\n-- place-holders and token(s). Multiple values are \n-- expressed as nested tuples (LISP-style cons list)\nlocal function _match(pattern, tokens, bound)\n    bound = bound or {}\n    if type(pattern) == \"string\" then\n        local tok = table.remove(tokens, 1)\n        if tok then\n            local n = bound[pattern]\n            if n and type(n) == \"number\" then\n                bound[pattern] = bound[pattern] + 1\n                return _match(pattern, tokens, bound)\n            else\n                bound[pattern] = 1\n                return _match(pattern, tokens, bound)\n            end\n        end\n    elseif type(pattern) == \"table\" then\n        local res = {}\n        for _,pat in ipairs(pattern) do\n            local tok = table.remove(tokens, 1)\n            if tok then\n                res[pat] = _match(pat, tokens, bound)\n                --print(\"Pat: \"..tostring(pat)..\", Tok: \"..tostring(tok))\n            end\n        end\n        return res\n    end\nen","completion":""}
{"prompt":"-- Compute a percentage.\n-- :param part: The part.\n-- :type part: float\n-- :param whole: The whole.\n-- :type whole: float\n-- :return: The computed percentage.\nlocal function percentage(part, whole)\n\treturn part * 100 \/ whole\nen","completion":""}
{"prompt":"-- Function to calculate permuation of 'n' objects, selected 'r' at a time.\nlocal function permutation(n, r)\n\tif (r == 0) then return 1 end\n\treturn n * permutation(n - 1, r - 1)\nen","completion":""}
