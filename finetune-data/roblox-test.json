{"prompt":"-- avg_word - calculates the average word length of a sentence\nlocal function avg_word(sentence)\n    local word_count = 0\n    local total_len = 0\n    for word in sentence:gmatch(\"[^%s]+\") do\n        total_len = total_len + #word\n        word_count = word_count + 1\n    end\n    if word_count == 0 then\n        return 0\n    end\n    return total_len \/ word_count\nen","completion":""}
{"prompt":"-- Find a dictionary identified by a key, in a list of dictionaries\n-- :param wh_data: the dictionary to search\n-- :param key: the key to identify the correct dictionary\n-- :return: the value in the correct dictionary\nlocal function _get_dogma_value(wh_data, key)\n    if wh_data then\n        if wh_data.dogma_attributes then\n            for _, dogma in pairs(wh_data.dogma_attributes) do\n                if dogma.attribute_id == key then\n                    return dogma.value\n                end\n            end\n        end\n        if wh_data.dogma_effects then\n            for _, dogma in pairs(wh_data.dogma_effects) do\n                if dogma.effect_id == key then\n                    return dogma.effect_id\n                end\n            end\n        end\n    end\n    return nil\nen","completion":""}
{"prompt":"-- Returns day-suffix 'st', 'nd', 'rd', 'th' for a day of a month.\n-- For example, the 21st of August -> returns 'st'.\n-- Parameters\n-- ----------\n-- d: :class:`int`\n-- Integer that represents the day of the month.\n-- Ranges from 1-31(max).\nlocal function day_suffix(d)\n  if d % 100 == 11 or d % 100 == 12 or d % 100 == 13 then\n    return 'th'\n  else\n    local d0 = d % 10\n    if d0 == 1 then\n      return 'st'\n    elseif d0 == 2 then\n      return 'nd'\n    elseif d0 == 3 then\n      return 'rd'\n    else\n      return 'th'\n    end\n  end\nen","completion":""}
{"prompt":"-- Non-recursive algorithm of finding factorial of the\n-- input number.\n-- >>> factorial(1)\n-- 1\n-- >>> factorial(6)\n-- 720\n-- >>> factorial(0)\n-- 1\nlocal function factorial(input_number)\n  if input_number < 0 then\n    error(\"The factorial is not defined for negative numbers\")\n  end\n  local res = 1\n  for i = 2, input_number do\n    res = res * i\n  end\n  return res\nen","completion":""}
{"prompt":"-- Take a list of results and convert them to a multi valued dictionary. The\n-- real world use case is to take values from a list of collections and pass\n-- them to a granule search.\n-- [{key1:value1},{key1:value2},...] -> {\"key1\": [value1,value2]} ->\n-- &key1=value1&key1=value2 ( via expand_query_to_parameters() )\nlocal function transform_results(results, keys_of_interest)\n    local output = {}\n    for _,result in pairs(results) do\n        for _,key in pairs(keys_of_interest) do\n            if result[key] then\n                local values = output[key] or {}\n                table.insert(values, result[key])\n                output[key] = values\n            end\n        end\n    end\n    return output\nen","completion":""}
{"prompt":"-- Remove leading and trailing white space and compress multiple\n-- consecutive internal spaces into one space.\n-- Args:\n-- instr (str): String to be cleaned.\n-- Returns:\n-- (str): The cleaned string.\nlocal function compress_whitespace(instr)\n  -- Replace all consecutive internal spaces with a single space\n  -- and then trim leading and trailing white space.\n  instr = string.gsub(instr, \"%s+\", \" \")\n  return string.gsub(instr, \"^%s*(.-)%s*$\", \"%1\")\nen","completion":""}
{"prompt":"-- From a list of intervals extract\n-- a list of sorted gaps in the form of [(g,i)]\n-- where g is the size of the ith gap.\nlocal function _gaps_from(intervals)\n    -- the list of gaps\n    local gaps = {}\n    -- the index of the last gap\n    local i = 1\n    -- loop over the intervals\n    for j=2, #intervals do\n        local prev_i, prev_j = intervals[j-1]\n        local cur_i, cur_j = intervals[j]\n        local gap = cur_i - prev_j - 1\n        if gap > 0 then\n            gaps[i] = gap\n            i = i + 1\n        end\n    end\n    return gaps\nen","completion":""}
{"prompt":"-- Brook 2014 CLUES derived differential subhalo mass function\n-- Keyword arguments:\n-- x -- array of subhalo halo masses\nlocal function brook(x)\n\tx = x\/10^12\n\treturn 1\/(1+1.3*x^(1\/3))\nen","completion":""}
{"prompt":"-- Given a 5-letter guess for a 5-letter word, returns the corresponding hint\nlocal function wordle(guess, word)\n    if word == guess then\n        return 'ggggg'\n    end\n    local hints = ''\n    for i = 1, #guess do\n        if guess:sub(i,i) == word:sub(i,i) then\n            hints = hints .. 'g'\n        elseif guess:sub(i,i) == word:find('.',i,true) then\n            hints = hints .. 'y'\n        else\n            hints = hints .. 'b'\n        end\n    end\n    return hints\nen","completion":""}
{"prompt":"-- Generate a valid filename from a string.\n-- Strips all characters which are not alphanumeric or a period (.), dash (-)\n-- or underscore (_).\n-- Based on https:\/\/stackoverflow.com\/a\/295146\/4798943\nlocal function get_valid_filename(string)\n  return string.gsub(string, \"[^%w%.%-_ ]\", \"\")\nen","completion":""}
{"prompt":"-- Backport of `removesuffix` from PEP-616 (Python 3.9+)\nlocal function removesuffix(self, suffix)\n\tif self:sub(-#suffix) == suffix then\n\t\treturn self:sub(1, -#suffix-1)\n\telse\n\t\treturn self\n\tend\nen","completion":""}
{"prompt":"-- In final designs it was found that some text inputs\n-- would generate crc lengths smaller than 5 (which is the usual one),\n-- so this function ensures we always send 5 bytes through the antenna.\nlocal function ensure_crc(crc)\n\treturn ('%05d'):format(crc)\nen","completion":""}
{"prompt":"-- Convert the given Loxone (0.0-100.0) light level to HASS (0-255).\nlocal function lox_to_hass(lox_val)\n  return (lox_val \/ 100) * 255\nen","completion":""}
{"prompt":"-- if b != 0 return absolute value of (a) % b\n-- else return 1\nlocal function modulus(a, b)\n    if b == 0 then\n        return 1\n    else\n        return math.abs(a) % b\n    end\nen","completion":""}
{"prompt":"-- A simple-minded function to escape strings for use in Gremlin queries.\n-- Replaces qutes with their escaped versions.  Other escaping\n-- may be necessary to avoid problems.\nlocal function escape(s)\n  s = s:gsub(\"\\\\\",\"\\\\\\\\\")\n  s = s:gsub(\"\\\"\",\"\\\\\\\"\")\n  s = s:gsub(\"'\", \"\\\\\\'\")\n  s = s:gsub(\"\\n\",\"\\\\\\\\n\")\n  return s\nen","completion":""}
{"prompt":"-- Get a list of csv links from the download link response text\nlocal function extract_csv_links(text)\n  local urls = {}\n  for line in text:gmatch(\"[^\\r\\n]+\") do\n    if line:find(\"^https?:\/\/\") then\n      urls[#urls+1] = line\n    end\n  end\n  return urls\nen","completion":""}
{"prompt":"-- :param new: float\n-- New value\n-- :param last: float\n-- Last value\n-- :return: float\n-- Increase (or decrease) since last value\nlocal function get_relative_delta(new, last)\n\tif not new or not last or new < 0 or last < 0 then return 0 end\n\tlocal delta = new - last\n\tif delta >= 0 then return delta end\n\treturn delta\nen","completion":""}
{"prompt":"-- Return weight given an entity grammatical role.\n-- +-----------+--------+\n-- | EGrid Tag | Weight |\n-- +===========+========+\n-- | S         | 3      |\n-- +-----------+--------+\n-- | O         | 2      |\n-- +-----------+--------+\n-- | X         | 1      |\n-- +-----------+--------+\n-- | dash      | 0      |\n-- +-----------+--------+\nlocal function weighting_syntactic_role(entity_role)\n  if entity_role == 'S' then\n    return 3\n  elseif entity_role == 'O' then\n    return 2\n  elseif entity_role == 'X' then\n    return 1\n  else\n    return 0\n  end\nen","completion":""}
{"prompt":"-- Calculates the fuel requirement for a given mass.\nlocal function _fuel_requirement(mass)\n  return math.floor(mass \/ 3) - 2\nen","completion":""}
{"prompt":"-- Returns a path with '\/' and remove the trailing slash.\nlocal function _norm_path(path)\n    path = string.gsub(path, \"\\\\\", \"\/\")\n    if string.sub(path, #path) == \"\/\" then\n        path = string.sub(path, 1, #path - 1)\n    end\n    return path\nen","completion":""}
{"prompt":"-- Converts a RGB\/float color into a RGB\/integer.\nlocal function rgbf2rgbi(rgbf)\n\treturn {\n\t\tmath.floor(rgbf[1] * 255),\n\t\tmath.floor(rgbf[2] * 255),\n\t\tmath.floor(rgbf[3] * 255),\n\t}\nen","completion":""}
{"prompt":"-- Convert number into a list of bits.\nlocal function bits(num, width)\n\tif width > 16 then\n\t\terror(\"Invalid width\")\n\telseif num < 0 then\n\t\terror(\"Number is negative\")\n\tend\n\tlocal bits = {}\n\tfor i = width, 1, -1 do\n\t\tbits[i] = math.fmod(num, 2)\n\t\tnum = (num - bits[i]) \/ 2\n\tend\n\treturn bits\nen","completion":""}
{"prompt":"-- Method that calculates and may print (changeable by print argument, False by default)\n-- progress of list creation in XX.XX% format.\nlocal function calculate_progress(done_tracks, number_of_loved_tracks, print_progress)\n    local percentage = done_tracks \/ number_of_loved_tracks * 100\n    local progress = string.format(\"%.2f%%\", percentage)\n    if print_progress then\n        print(progress .. \" - \" .. done_tracks .. \"\/\" .. number_of_loved_tracks)\n    end\n    return progress\nen","completion":""}
{"prompt":"-- ensure that a number n is constrained in a range\nlocal function clamp(n, low, high)\n  return math.min(math.max(n, low), high)\nen","completion":""}
{"prompt":"-- Remove all instances of args that start with prefix. This is used\n-- to remove args that were previously added (and are now being\n-- regenerated due to respawning)\nlocal function _cleanup_remappings(args, prefix)\n   local new_args = {}\n   for _, a in ipairs(args) do\n      if a:sub(1, #prefix) ~= prefix then\n         table.insert(new_args, a)\n      end\n   end\n   return new_args\nen","completion":""}
{"prompt":"-- Calcula a transposta de uma matriz.\nlocal function transposta_matriz(M)\n    local ret = {}\n    for i = 1, #M[1] do\n        local linha = {}\n        for j = 1, #M do\n            linha[#linha + 1] = M[j][i]\n        end\n        ret[#ret + 1] = linha\n    end\n    return ret\nen","completion":""}
{"prompt":"-- Converts an integer to a base36 string.\nlocal function base36encode(number, alphabet)\n  alphabet = alphabet or '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  if (number < 0) then\n    return '-'..base36encode(-number, alphabet)\n  end\n  if (number < #alphabet) then\n    return string.sub(alphabet, number + 1, number + 1)\n  end\n  return base36encode(number \/\/ #alphabet, alphabet)..string.sub(alphabet, number % #alphabet + 1, number % #alphabet + 1)\nen","completion":""}
{"prompt":"-- calculate minutes\n-- :param seconds:\n-- :return:\nlocal function calc_minutes(seconds)\n\treturn math.floor((seconds \/ 60) % 60);\nen","completion":""}
{"prompt":"-- Convert an rgb color from decimal to list representation.\nlocal function decimal_to_rgb_list(color)\n\tlocal r = math.floor(color\/65536)\n\tcolor = color-r*65536\n\tlocal g = math.floor(color\/256)\n\tcolor = color-g*256\n\tlocal b = color\n\treturn {r, g, b}\nen","completion":""}
{"prompt":"-- Create an expression that multiply an expression by an integer\n-- Args:\n-- expr: Expression to constrain\n-- val:  Integer value to multiply expression with\n-- Returns:\n-- New expression\nlocal function _mutl_by_int(expr, val)\n  return expr * val\nen","completion":""}
{"prompt":"-- Used for CB Changing\n-- Search for item in list, exist or not. If it exist return the index\n-- else return 0.\nlocal function searchList(searchFor, theList)\n\tif (searchFor) then\n\t\tlocal index = 0\n\t\tfor _, value in ipairs(theList) do\n\t\t\tif (value == searchFor) then\n\t\t\t\treturn index\n\t\t\tend\n\t\t\tindex = index + 1\n\t\tend\n\t\treturn 0\n\tend\n\treturn 0\nen","completion":""}
{"prompt":"-- Counts the number of set bits in a uint (or a numpy array of uints).\nlocal function _count_set_bits(i)\n    local count = 0\n    while i > 0 do\n        count = count + 1\n        i = i & (i-1)\n    end\n    return count\nen","completion":""}
{"prompt":"-- Gets the bit value.\n-- @Arg val: Input value, int or numpy int array.\n-- @Arg idx: Which bit of the input val.\n-- @Returns: The \"idx\"-th bit of input val.\nlocal function bit_get(val, idx)\n    if idx < 0 then\n        error(\"Invalid idx: \" .. tostring(idx))\n    end\n    if idx == 0 then\n        return val % 2\n    end\n    return bit_get(val \/\/ 2, idx - 1)\nen","completion":""}
{"prompt":"-- Convert an int to binary.\n-- I'm aware that in python I could've just done:\n-- '{0:b}'.format(int_to_convert)\n-- But that's a little less informative :)\n-- Args:\n-- int_to_convert (int):   The int to convert.\n-- Returns:\n-- str\nlocal function convert_int_to_binary(int_to_convert)\n  local result = ''\n  local max_num_bits = 64\n  while int_to_convert > 0 do\n    local remainder = int_to_convert % 2\n    int_to_convert = math.floor(int_to_convert \/ 2)\n    result = tostring(remainder) .. result\n    if int_to_convert == 0 then\n      return result\n    end\n  end\n  return result\nen","completion":""}
{"prompt":"-- Convert unicode to str. If s is str, return itself.\n-- >>> smart_str(u'')\n-- ''\n-- >>> smart_str(u'abc')\n-- 'abc'\n-- >>> smart_str(u'\u4f60\u597d') ==  '\u00e4\u00bd\u00a0\u00e5\u00a5\u00bd'\n-- True\n-- >>> smart_str('abc')\n-- 'abc'\n-- >>> smart_str('\u00e4\u00bd\u00a0\u00e5\u00a5\u00bd') == '\u00e4\u00bd\u00a0\u00e5\u00a5\u00bd'\n-- True\nlocal function smart_str(s, encoding)\n  if type(s) == 'string' then return s end\n  if type(s) == 'table' then return s end\n  if type(s) == 'number' then return tostring(s) end\n  return s:encode(encoding)\nen","completion":""}
{"prompt":"-- {% load trim %}\n-- {{ var | trim }}\nlocal function trim(text)\n  if not text or type(text) ~= 'string' then\n    return ''\n  end\n  return (text:gsub('^%s*(.-)%s*$', '%1'))\nen","completion":""}
{"prompt":"-- given a limit, find the largest even fibonacci number below that limit,\n-- and the fibonacci number before it. Returned as a dict {'largest_even', 'previous'}\nlocal function largest_even_fib(limit)\n    local last = 1\n    local second_to_last = 1\n    local largest = 0\n    local previous = 0\n    while second_to_last < limit do\n        local current = second_to_last + last\n        last = second_to_last\n        second_to_last = current\n        if current % 2 == 0 and current > largest then\n            largest = current\n            previous = last\n        end\n    end\n    return {largest_even = largest, previous = previous}\nen","completion":""}
{"prompt":"-- index to voxel, eg. 0 -> (0,0,0).\nlocal function index_to_voxel(index, Y_size, Z_size)\n    return {\n        index % Y_size,\n        math.floor(index \/ Y_size) % Z_size,\n        math.floor(index \/ (Y_size * Z_size))\n    }\nen","completion":""}
{"prompt":"-- Return v clamped to the given interval\nlocal function clamp(v, v_min, v_max)\n\treturn math.min(math.max(v, v_min), v_max)\nen","completion":""}
{"prompt":"-- Convert a matrix index pair to a vector index that is compatible with the\n-- matrix to vector rearrangement done by the mat2vec function.\nlocal function mat2vec_index(N, i, j)\n\treturn j*N + i\nen","completion":""}
{"prompt":"-- Inverse to unipolar().\n-- Converts an unipolar signal to a bipolar signal.\nlocal function bipolar(signal)\n    return signal * 2 - 1\nen","completion":""}
{"prompt":"-- fib( n ). \n-- This method calculate the nth Fibonacci number.\n-- Parameters:\n-- n(int): the nth Fibonacci number in the Fibonacci sequence\n-- Returns:\n-- f: nth Fibonacci number.\nlocal function fib(n)\n\tif n < 2 then\n\t\treturn 1\n\tend\n\treturn fib(n - 2) + fib(n - 1)\nen","completion":""}
{"prompt":"-- Returns value constrained between min and max arguments.\nlocal function constrain(value, min, max)\n  return math.max(math.min(value, max), min)\nen","completion":""}
{"prompt":"-- Return number of leading whitespace characters.\nlocal function _wlen(s)\n\treturn s:match(\"^%s*\"):len()\nen","completion":""}
{"prompt":"-- Print if positive or negative in polarity level\n-- >>> print_pos_neg(0.8)\n-- 'positive'\n-- >>> print_pos_neg(-0.5)\n-- 'negative'\nlocal function print_pos_neg(num)\n    if num > 0 then\n        return 'positive'\n    elseif num < 0 then\n        return 'negative'\n    else\n        return 'neutral'\n    end\nen","completion":""}
{"prompt":"-- Convert zero-based month number to zero-based month number.\nlocal function wrapMonth(m)\n    m = m - 1\n    if m < 0 then\n        m = m + 12\n    end\n    return m\nen","completion":""}
{"prompt":"-- Returns the next number of the chain by adding the square of each digit\n-- to form a neww number.\n-- For example if number = 12, next_number() will return 1^2 + 2^2 = 5.\n-- Therefore 5 is the next number of the chain.\n-- >>> next_number(44)\n-- 32\n-- >>> next_number(10)\n-- 1\n-- >>> next_number(32)\n-- 13\nlocal function next_number(number)\n    local sum = 0\n    for i = 1, 5 do\n        sum = sum + (number % 10) * (number % 10)\n        number = math.floor(number \/ 10)\n    end\n    return sum\nen","completion":""}
{"prompt":"-- Return the shape directory-api-client expects for updating address.\n-- @param {dict} cleaned_data - All the fields in\n-- `CompanyAddressVerificationForm`\n-- @returns dict\nlocal function serialize_company_address_form(cleaned_data)\n    local serialized_data = {}\n    for key, value in pairs(cleaned_data) do\n        if key == \"address\" then\n            serialized_data[key] = {}\n            for _, address_line in pairs(value) do\n                serialized_data[key][#serialized_data[key] + 1] =\n                    address_line\n            end\n        else\n            serialized_data[key] = value\n        end\n    end\n    return serialized_data\nen","completion":""}
{"prompt":"-- Parse a restructured text option as a comma-separated list of strings.\nlocal function comma_separated_list(x)\n  if x then\n    local lst = {}\n    for val in x:gmatch(\"[^,]+\") do\n      table.insert(lst, val)\n    end\n    return lst\n  else\n    return {}\n  end\nen","completion":""}
{"prompt":"-- Convert from a single ARGB value to a tuple containing RGBA.\n-- Args:\n-- argb: Signed 32 bit integer containing an ARGB value.\n-- Returns:\n-- RGBA tuple.\nlocal function _ArgbToRgbaTuple(argb)\n  local a = (argb >> 24) & 0xFF\n  local r = (argb >> 16) & 0xFF\n  local g = (argb >> 8) & 0xFF\n  local b = argb & 0xFF\n  return { r, g, b, a }\nen","completion":""}
{"prompt":"-- Return a number clamped to between 0 and 255.\nlocal function clamp(number)\n  return math.min(math.max(math.floor(number), 0), 255)\nen","completion":""}
{"prompt":"-- Given a redis key value for a metric, returns only the slug.\n-- Applying this filter to the keys for each metric will have the following\n-- results:\n-- * Converts ``m:foo:s:<yyyy-mm-dd-hh-MM-SS>`` to ``foo``\n-- * Converts ``m:foo:i:<yyyy-mm-dd-hh-MM>`` to ``foo``\n-- * Converts ``m:foo:h:<yyyy-mm-dd-hh>`` to ``foo``\n-- * Converts ``m:foo:<yyyy-mm-dd>`` to ``foo``\n-- * Converts ``m:foo:w:<num>`` to ``foo``\n-- * Converts ``m:foo:m:<yyyy-mm>`` to ``foo``\n-- * Converts ``m:foo:y:<yyyy>`` to ``foo``\nlocal function metric_slug(value)\n    local pattern = '^m:([^:]+)'\n    local metric_slug = value:match(pattern)\n    return metric_slug\nen","completion":""}
{"prompt":"-- Remap value from from_min_value:from_max_value range to to_min_value:to_max_value range\nlocal function remap(value, from_min_value, from_max_value, to_min_value, to_max_value)\n\treturn (value - from_min_value) * (to_max_value - to_min_value) \/ (from_max_value - from_min_value) + to_min_value\nen","completion":""}
{"prompt":"-- Convert RGB color to an Hexadecimal representation\nlocal function rgb_to_hex(r, g, b)\n  if type(r) ~= \"number\" or type(g) ~= \"number\" or type(b) ~= \"number\" then\n    return\n  end\n  local r_hex = r < 16 and \"0\"..string.format(\"%x\", r) or string.format(\"%x\", r)\n  local g_hex = g < 16 and \"0\"..string.format(\"%x\", g) or string.format(\"%x\", g)\n  local b_hex = b < 16 and \"0\"..string.format(\"%x\", b) or string.format(\"%x\", b)\n  return r_hex..g_hex..b_hex\nen","completion":""}
{"prompt":"-- Convert the authorization comma separated string to list\nlocal function _string_tolist(s)\n\ts = string.gsub(s, \" \", \"\")\n\tlocal l = {}\n\tfor w in string.gmatch(s, '([^,]+)') do\n\t\ttable.insert(l, w)\n\tend\n\treturn l\nen","completion":""}
{"prompt":"-- Transposes a lower triangular matrix L.\nlocal function transpose(L)\n  local m, n = #L, #L[1]\n  local Lt = {}\n  for j = 1, n do\n    local Lt_j = {}\n    for i = 1, m do\n      Lt_j[i] = L[i][j]\n    end\n    Lt[#Lt + 1] = Lt_j\n  end\n  return Lt\nen","completion":""}
{"prompt":"-- If num isn't a power of 2, will return the next higher power of two\nlocal function next_p2(num)\n  local value = 1\n  while value < num do\n    value = value << 1\n  end\n  return value\nen","completion":""}
{"prompt":"-- Return a MOF indent pad unicode string from the indent integer variable\n-- that defines number of spaces to indent. Used to format MOF output.\nlocal function _indent_str(indent)\n\treturn (\" \"):rep(indent)\nen","completion":""}
{"prompt":"-- Get the maximum value of the knapsack.\nlocal function knapsack_max_value(max_weight, items)\n  -- Create a DP table.\n  local table = {}\n  local num_items = #items\n  for i = 0, num_items do\n    table[i] = {}\n    for w = 0, max_weight do\n      table[i][w] = 0\n    end\n  end\n  -- Fill the DP table.\n  for i = 1, num_items do\n    for w = 1, max_weight do\n      -- The knapsack can't contain this item.\n      if items[i].weight > w then\n        table[i][w] = table[i - 1][w]\n      -- The knapsack can contain this item.\n      else\n        table[i][w] = max(\n          table[i - 1][w],\n          table[i - 1][w - items[i].weight] + items[i].value\n        )\n      end\n    end\n  end\n  -- Return the maximum value.\n  return table[num_items][max_weight]\nen","completion":""}
{"prompt":"-- The model function\nlocal function n_Squared(x, No)\n\treturn No * x * x\nen","completion":""}
{"prompt":"-- Returns a JSDoc union of the given type strings.\nlocal function fmt_jsdoc_union(type_strings)\n   if #type_strings > 1 then\n      return string.format('(%s)', table.concat(type_strings, '|'))\n   end\n   return type_strings[1]\nen","completion":""}
{"prompt":"-- Describes and gives an example of how floor division and the \"\/\/\" symbols are used in Python.\n-- Examples:\n-- >>> floor_division(15, 6)\n-- Floor division returns the nearest whole number as the quotient, rounding down when there is a remainder.\n-- dividend \/\/ divisor\n-- 15 \/\/ 6\n-- 2\n-- Args:\n-- dividend (int): Supply a dividend\n-- divisor (int): Supply a divisor\n-- Returns:\n-- int: Returns the quotient of the floor division operation\nlocal function floor_division(dividend, divisor)\n    return dividend \/\/ divisor\nen","completion":""}
{"prompt":"-- What comes in:  Two positive integers m and n with m <= n.\n-- What goes out:  Returns the sum:\n-- 1\/m + 1\/(m+1) + 1\/(m+2) + ... + 1\/n.\n-- Side effects:   None.\n-- Examples:\n-- -- sum_unit_fractions_from(6, 9) returns\n-- 1\/6 + 1\/7 + 1\/8 + 1\/9\n-- which is about 0.545635\n-- -- sum_unit_fractions_from(10, 9000)  returns about  6.853\nlocal function sum_unit_fractions_from(m, n)\n   local sum = 0\n   for i = m, n do\n      sum = sum + 1 \/ i\n   end\n   return sum\nen","completion":""}
{"prompt":"-- Finds the total units in a list of Course objects\nlocal function total_units(courses)\n\tlocal total = 0\n\tfor _, course in ipairs(courses) do\n\t\ttotal = total + course.units\n\tend\n\treturn total\nen","completion":""}
{"prompt":"-- function to convert string header to dictionary\nlocal function get_header_dict(value)\n\tlocal res = {}\n\tif value then\n\t\tlocal header_parts = value:gmatch('([%w-]+):%s*([^\\r\\n]+)')\n\t\tif header_parts then\n\t\t\tfor name, value in header_parts do\n\t\t\t\tres[name] = value\n\t\t\tend\n\t\tend\n\tend\n\treturn res\nen","completion":""}
{"prompt":"-- (str) -> str\n-- Return a reversed version of s.\n-- >>> reverse('hello')\n-- 'olleh'\n-- >>> reverse('a')\n-- 'a'\nlocal function reverse(s)\n    local reversed = ''\n    for i = #s, 1, -1 do\n        reversed = reversed .. s:sub(i, i)\n    end\n    return reversed\nen","completion":""}
{"prompt":"-- The recursive definition of the Thue-Morse sequence. The first few terms\n-- of the Thue-Morse sequence are: 0 1 1 0 1 0 0 1 1 0 0 1 0 1 1 0 . . .\nlocal function recursive_thue_morse(n)\n  if n == 0 then\n    return 0\n  elseif n == 1 then\n    return 1\n  else\n    local result = 0\n    if n % 2 == 0 then\n      result = recursive_thue_morse(n\/2)\n    else\n      result = 1 - recursive_thue_morse((n-1)\/2)\n    end\n    return result\n  end\nen","completion":""}
{"prompt":"-- Convert thing to a list.\n-- If thing is a string, then returns a list of thing. Otherwise\n-- returns thing.\n-- :arg thing: string or list of things\n-- :returns: list\nlocal function listify(thing)\n  if thing == nil then\n    return {}\n  elseif type(thing) == \"string\" then\n    return { thing }\n  else\n    return thing\n  end\nen","completion":""}
{"prompt":"-- Add two keys in GF(2^4)\nlocal function addKey(s1, s2)\n    local s3 = {}\n    for i = 1, 4 do\n        s3[i] = s1[i] + s2[i]\n        s3[i] = s3[i] % 2\n    end\n    return s3\nen","completion":""}
{"prompt":"-- Convert dry-snow density into permittivity (epsilon)\n-- Based on Kovacs et al. [1995]\n-- Arguments\n-- ---------\n-- dns : float\n-- density [kg.m^{-3}]\nlocal function dns2eps(dns)\n  if dns <= 0.01 then\n    return 1.0\n  else\n    return 1.0 \/ (1.0\/dns + 0.0772)\n  end\nen","completion":""}
{"prompt":"-- Converts carets to exponent symbol in string\nlocal function fix_carets(expr)\n    expr = string.gsub(expr, \"%^\", \"**\")\n    return expr\nen","completion":""}
{"prompt":"-- Check for any visits that might be scheduled for execution in the\n-- next <dayspan> days, and return a string reporting them to the user.\n-- If nothing has been done lately, returns 0.\nlocal function checkComing(visdict, dayspan)\n\tlocal text = \"\"\n\tlocal daycount = 0\n\tlocal now = os.time()\n\tfor i,v in ipairs(visdict) do\n\t\t-- If a visit is planned to be executed in the next <dayspan> days,\n\t\t-- then report it to the user.\n\t\tif v.day + dayspan >= now then\n\t\t\tif text ~= \"\" then\n\t\t\t\ttext = text .. \"\\n\"\n\t\t\tend\n\t\t\ttext = text .. \"The visit scheduled for \" .. os.date(\"%A, %B %e, %Y\", v.day) .. \" in \" .. v.room .. \" will be executed\"\n\t\tend\n\t\tdaycount = math.max(daycount, v.day + dayspan)\n\tend\n\treturn text, daycount\nen","completion":""}
{"prompt":"-- Returns the larger of the values a and b.\nlocal function max_of(a, b)\n  return a > b and a or b\nen","completion":""}
{"prompt":"-- Add `not` to string.\n-- Returns a new string with `not` in front or\n-- an unchanged string if `not` was already there.\nlocal function not_string(str_)\n    if str_:sub(1, 3) == \"not\" then\n        return str_\n    else\n        return \"not \" .. str_\n    end\nen","completion":""}
{"prompt":"-- Escapes a string to make it HTML-safe\nlocal function escape(s)\n\tif s == nil then return '' end\n\treturn tostring(s):gsub('&', '&amp;'):gsub('<', '&lt;'):gsub('>', '&gt;'):gsub('\"', '&quot;')\nen","completion":""}
{"prompt":"-- Checks if one of the ranges in sequence is 0 and j is out of range\n-- If true, returns inverted j\n-- Else j\nlocal function range_zero_check(j, min, max)\n    if (min == 0 and j < 0) or (max == 0 and j > 0) then\n        return -j\n    else\n        return j\n    end\nen","completion":""}
{"prompt":"-- Reformat the runtime of a film from minutes to hour & minutes.\n-- Parameters\n-- ---------\n-- value: str\n-- The runtime of the film in minutes.\n-- Returns\n-- -------\n-- runtime\n-- The runtime for the film formatted as X hr Y min.\nlocal function format_runtime(value)\n  local hours = math.floor(value \/ 60)\n  local minutes = value % 60\n  return string.format(\"%d hr %d min\", hours, minutes)\nen","completion":""}
{"prompt":"-- From the list of group responses, pick out the unique responses.\n-- Args:\n-- group_responses [list] : A list of of lists. Each sub-list contains each\n-- groups' person's responses.\n-- Returns:\n-- list [str] : A list of lists, with duplicate responses removed from the input.\nlocal function unique_responses(group_responses)\n   local unique_responses = {}\n   for i, responses in ipairs(group_responses) do\n      local unique = {}\n      for j, response in ipairs(responses) do\n         local already_exists = false\n         for k, unique_response in ipairs(unique) do\n            if response == unique_response then\n               already_exists = true\n               break\n            end\n         end\n         if not already_exists then\n            table.insert(unique, response)\n         end\n      end\n      unique_responses[i] = unique\n   end\n   return unique_responses\nen","completion":""}
{"prompt":"-- Recursively reverses a string\n-- @param {string} sequence to reverse\n-- @return {string}\nlocal function reverse(seq)\n  local len = #seq\n  local rseq = ''\n  for i=len,1,-1 do rseq = rseq..seq:sub(i,i) end\n  return rseq\nen","completion":""}
{"prompt":"-- native float\nlocal function pi_native(prec)\n    return \"PI\"\nen","completion":""}
{"prompt":"-- Cast data to a list if it is not already a list.\n-- :param data: The variable to be cast to a list.\n-- :return: The data in a list\nlocal function cast_to_list(data)\n  if type(data) == \"table\" then\n    return data\n  else\n    return {data}\n  end\nen","completion":""}
{"prompt":"-- Return true if n has two eights in a row.\n-- >>> double_eights(8)\n-- False\n-- >>> double_eights(88)\n-- True\n-- >>> double_eights(2882)\n-- True\n-- >>> double_eights(880088)\n-- True\n-- >>> double_eights(12345)\n-- False\n-- >>> double_eights(80808080)\n-- False\nlocal function double_eights(n)\n  return (string.find(tostring(n), \"88\") ~= nil)\nen","completion":""}
{"prompt":"-- :param angle: (float)\n-- :return: (float) the angle in [-pi, pi]\nlocal function normalizeAngle(angle)\n  return math.fmod(angle + math.pi, 2*math.pi) - math.pi\nen","completion":""}
{"prompt":"-- Get the filename component of the URL\n-- >>> filename_from_url('http:\/\/example.com\/somefile.zip')\n-- 'somefile.zip'\n-- >>> filename_from_url('http:\/\/oceandata.sci.gsfc.nasa.gov\/Ancillary\/LUTs\/modis\/utcpole.dat')\n-- 'utcpole.dat'\nlocal function filename_from_url(url)\n  return url:match(\"[^\/]+$\")\nen","completion":""}
{"prompt":"-- Every django model should have `class: Meta` param with app_label. Replace all of them with\nlocal function fix_django_app_label(input_text_data)\n    local text = input_text_data\n    text = text:gsub(\"class: Meta\", \"class Meta\")\n    text = text:gsub(\"class 'Meta'\", \"class Meta\")\n    text = text:gsub(\"class:meta\", \"class Meta\")\n    text = text:gsub(\"class:meta'\", \"class Meta\")\n    text = text:gsub(\"'class: meta\", \"class Meta\")\n    return text\nen","completion":""}
{"prompt":"-- Removes '<url>' tag from a tweet.\n-- INPUT: \n-- tweet: original tweet as a string\n-- OUTPUT: \n-- tweet with <url> tags removed\nlocal function remove_url(tweet)\n    local url = '<url>'\n    return tweet:gsub(url, '')\nen","completion":""}
{"prompt":"-- Transforms points from the interval [a,b] to the interval [-1,1].\n-- Parameters\n-- ----------\n-- x : numpy array\n-- The points to be tranformed.\n-- a : float or numpy array\n-- The lower bound on the interval. Float if one-dimensional, numpy array if multi-dimensional\n-- b : float or numpy array\n-- The upper bound on the interval. Float if one-dimensional, numpy array if multi-dimensional\n-- Returns\n-- -------\n-- transform : numpy array\n-- The transformed points.\nlocal function inv_transform(x, a, b)\n    return (x - a) * 2 \/ (b - a) - 1\nen","completion":""}
{"prompt":"-- Returns the pivoting matrix for M, used in Doolittle's method.\nlocal function pivot_matrix(M)\n  local P = {}\n  for i = 1, #M do\n    P[i] = {}\n    for j = 1, #M do\n      P[i][j] = 0\n    end\n    P[i][i] = 1\n  end\n  return P\nen","completion":""}
{"prompt":"-- [0, 255] -> [-1, 1]\n-- :param x: input image\n-- :return: normalized image\nlocal function normalize_image(x)\n    -- 0 to 255\n    x = (x - 127.5) \/ 127.5\n    -- to [-1, 1]\n    return x\nen","completion":""}
{"prompt":"-- Convert coordinates from central point to top left point\n-- :param x_center: x coordinate of the center\n-- :param y_center: y coordinate of the center\n-- :param radius: the radius of the ball\n-- :return: coordinates of top left point of the surface\nlocal function convert_coord(x_center, y_center, radius)\n  return {x_center - radius, y_center - radius}\nen","completion":""}
{"prompt":"-- Returns the 128-bit carry-less product of 64-bit x and y.\nlocal function gfmul(x, y)\n    return (x * y) % (2^128)\nen","completion":""}
{"prompt":"-- num -> str\n-- Entra un numero y sale si es par o impar\n-- :param num: numero a ser revisado\n-- :return: mensaje dejando saber si es par o no\n-- >>> par_impar(6)\n-- 'Es par'\n-- >>> par_impar(7)\n-- 'Es impar'\n-- >>> par_impar('d')\n-- Traceback (most recent call last):\n-- ..\n-- TypeError: No es valido\nlocal function par_impar(num)\n    if type(num) == 'number' then\n        if num % 2 == 0 then\n            return 'Es par'\n        else\n            return 'Es impar'\n        end\n    else\n        error('No es valido')\n    end\nen","completion":""}
{"prompt":"-- compute the difference between two vectors\nlocal function difference(v1, v2)\n  assert(v1 and v2 and #v1 == #v2, \"invalid vectors\")\n  local v = {}\n  for i = 1, #v1 do\n    v[i] = v1[i] - v2[i]\n  end\n  return v\nen","completion":""}
{"prompt":"-- Returns a value without parsing. Use for values that the aggregation pipeline may interpret as an expression.\n-- See https:\/\/docs.mongodb.com\/manual\/reference\/operator\/aggregation\/literal\/\n-- for more details\n-- :param value: The expression or variable\n-- :return: Aggregation operator\nlocal function LITERAL(value)\n  return {[\"$literal\"] = value}\nen","completion":""}
{"prompt":"-- Simple list comprehension to flatten list.\n-- >>> flatten_list([[1, 2], [3, 4, 5]])\n-- [1, 2, 3, 4, 5]\n-- >>> flatten_list([[1], [[2]]])\n-- [1, [2]]\n-- >>> flatten_list([1, [2]])\n-- Traceback (most recent call last):\n-- ...\n-- TypeError: 'int' object is not iterable\nlocal function flatten_list(list_to_flatten)\n    local flattened_list = {}\n    for _, element in ipairs(list_to_flatten) do\n        if type(element) == \"table\" then\n            for _, inner_element in ipairs(element) do\n                table.insert(flattened_list, inner_element)\n            end\n        else\n            table.insert(flattened_list, element)\n        end\n    end\n    return flattened_list\nen","completion":""}
{"prompt":"-- Naive tokenizer: split the sentence by space into a list of tokens.\nlocal function naive_tokenizer(sentence)\n    local tokens = {}\n    for token in sentence:gmatch(\"%S+\") do table.insert(tokens, token) end\n    return tokens\nen","completion":""}
{"prompt":"-- Returns the string without non ASCII characters\nlocal function strip_non_ascii(string)\n\treturn string:gsub(\"[^%w%p ]\", \"\")\nen","completion":""}
{"prompt":"-- Convert endpoint subcloud db model to dictionary.\nlocal function subcloud_endpoint_status_db_model_to_dict(subcloud_status)\n    local dict = {}\n    if subcloud_status ~= nil then\n        dict = {\n            status = subcloud_status.status\n        }\n    end\n    return dict\nen","completion":""}
{"prompt":"-- Removes spaces before punctuation.\n-- Removes the spaces after blanks and before punctuation (i.e. ___n___ .)\n-- that are created by \" \".join(fib).\n-- Args:\n-- fib_string (str): the concatenated fill-in-the-blank with the unwanted\n-- spaces.\n-- Returns:\n-- (str): the same string without the unwanted spaces.\nlocal function remove_spaces_before_punc(fib_string)\n  return fib_string:gsub(\"%s([%.,;?!%)])\", \"%1\")\nen","completion":""}
{"prompt":"-- This function returns a list of all character sequences in input_string\n-- that are divided by whitespace or parentheses, including the\n-- parentheses themselves.\n-- >>> _lex('alice & (bob | carol)')\n-- ['alice', '&', '(', 'bob', '|', 'carol', ')']\nlocal function _lex(input_string)\n    local char_sequences = {}\n    local pos = 1\n    local len = #input_string\n    while pos <= len do\n        local next_char = string.sub(input_string, pos, pos)\n        if next_char == '(' or next_char == ')' or next_char == '|' or next_char == '&' or next_char == '!' then\n            table.insert(char_sequences, next_char)\n            pos = pos + 1\n        elseif next_char == ' ' then\n            pos = pos + 1\n        elseif pos == len then\n            table.insert(char_sequences, next_char)\n            pos = pos + 1\n        elseif string.find(next_char, '%w') then\n            local char_sequence = next_char\n            pos = pos + 1\n            next_char = string.sub(input_string, pos, pos)\n            while pos <= len and string.find(next_char, '%w') do\n                char_sequence = char_sequence .. next_char\n                pos = pos + 1\n                next_char = string.sub(input_string, pos, pos)\n            end\n            table.insert(char_sequences, char_sequence)\n        else\n            -- this should be a syntax error!\n            pos = pos + 1\n        end\n    end\n    return char_sequences\nen","completion":""}
{"prompt":"-- If input value if not a list\/tuple type, return it as a single value list.\nlocal function alwayslist(value)\n\treturn type(value) == \"table\" and value or { value }\nen","completion":""}
{"prompt":"-- :type s: str\n-- :rtype: int\nlocal function lengthOfLongestSubstring(s)\n  local i, max_length, seen = 1, 0, {}\n  for j = 1, #s do\n    local c = s:sub(j, j)\n    if seen[c] then\n      i = math.max(i, seen[c] + 1)\n    end\n    seen[c] = j\n    max_length = math.max(max_length, j - i + 1)\n  end\n  return max_length\nen","completion":""}
{"prompt":"-- Escape a string to be a single shell entity.\n-- s -- the string or string-convertible to espace.\n-- >>> shell_escape('foo')\n-- 'foo'\n-- >>> shell_escape('foo bar')\n-- \"'foo bar'\"\n-- >>> shell_escape('foo$bar')\n-- \"'foo$bar'\"\n-- >>> shell_escape('foo\"bar')\n-- '\\'foo\"bar\\''\n-- >>> shell_escape('$foobar')\n-- \"'$foobar'\"\n-- >>> shell_escape(\"foo'bar\")\n-- \"'foo'\\\\''bar'\"\nlocal function shell_escape(s)\n\tlocal s = tostring(s)\n\tif s:match(\"[^a-zA-Z0-9_@%+=:,.\/-]\") then\n\t\ts = \"'\" .. s:gsub(\"'\", \"'\\\\''\") .. \"'\"\n\tend\n\treturn s\nen","completion":""}
{"prompt":"-- Converts the contents of list containing strings, lists of strings *(,lists of lists of strings,...)* to a flat\n-- list of strings.\n-- :param orig: the list to flatten\n-- :return: the flattened list\nlocal function _flatten(orig)\n\tlocal flat = {}\n\tlocal function aux(element)\n\t\tif type(element) == 'table' then\n\t\t\tfor _,v in ipairs(element) do\n\t\t\t\taux(v)\n\t\t\tend\n\t\telse\n\t\t\tflat[#flat+1] = element\n\t\tend\n\tend\n\taux(orig)\n\treturn flat\nen","completion":""}
{"prompt":"-- List to tockens\n-- word_dict: dictionary of tokens\n-- token_list: word list\nlocal function tokenize_poem(token_list, word_dict)\n    local new_list = {}\n    local word_id = 1\n    local token = \"\"\n    for i = 1, #token_list do\n        token = token_list[i]\n        if word_dict[token] then\n            word_id = word_dict[token]\n            table.insert(new_list, word_id)\n        else\n            word_id = word_dict[\"<unk>\"]\n            table.insert(new_list, word_id)\n        end\n    end\n    return new_list\nen","completion":""}
{"prompt":"-- I claim no copyright on this function. I copied it from the internet.\nlocal function mul_inv(a, b)\n  local t = 0\n  local newt = 1\n  local r = b\n  local newr = a\n  while newr ~= 0 do\n    local quot = r \/\/ newr\n    local tmp = t - quot * newt\n    t = newt\n    newt = tmp\n    tmp = r - quot * newr\n    r = newr\n    newr = tmp\n  end\n  if t < 0 then t = t + b \/\/ r end\n  return t\nen","completion":""}
{"prompt":"-- Calculate recall from tp and fn\nlocal function calc_recall(tp, fn)\n  if tp > 0 then\n    return tp \/ (tp + fn)\n  else\n    return 0\n  end\nen","completion":""}
{"prompt":"-- replaces all occcurrences even if new ones are formed in the process\nlocal function changeall(piece, old, new)\n  local str = piece\n  local found\n  repeat\n    found = str:find(old, 1, true)\n    if found then\n      str = str:sub(1, found - 1) .. new .. str:sub(found + old:len())\n    end\n  until not found\n  return str\nen","completion":""}
{"prompt":"-- Searches for new_package in the installed tree, returns error message (or empty string)\n-- (checks the root of the tree and walks the installed tree)\nlocal function package_in_installed(new_package, installed)\n  if new_package == nil then return \"package is nil\" end\n  if not installed then return \"installed is nil\" end\n  for _,v in ipairs(installed) do\n    if v.name == new_package then return \"\" end\n  end\n  for _,v in ipairs(installed) do\n    if v.installed then\n      local err = package_in_installed(new_package, v.installed)\n      if err ~= \"\" then return err end\n    end\n  end\n  return \"\"\nen","completion":""}
{"prompt":"-- The tag for splits article tags from string divided by comma to list.\nlocal function split_tags(tags)\n  if not tags then\n    return nil\n  end\n  local tags_list = {}\n  for tag in string.gmatch(tags, \"([^,]+)\") do\n    table.insert(tags_list, tag)\n  end\n  return tags_list\nen","completion":""}
{"prompt":"-- :param tp: int\n-- Number of True Positives\n-- :param n: int\n-- Number of total instances\n-- :return: float\n-- Recall\nlocal function calculate_recall(tp, n)\n   if n ~= 0 then\n      return tp \/ n\n   else\n      return 0\n   end\nen","completion":""}
{"prompt":"-- (str, str) -> int\n-- Return the number of occurrences of nucleotide in the DNA sequence dna.\n-- >>> count_nucleotides('ATCGGC', 'G')\n-- 2\n-- >>> count_nucleotides('ATCTA', 'G')\n-- 0\nlocal function count_nucleotides(dna, nucleotide)\n\tlocal count = 0\n\tfor i in dna:gmatch(nucleotide) do\n\t\tcount = count + 1\n\tend\n\treturn count\nen","completion":""}
{"prompt":"-- Given Celsius, convert to Fahrenheit\nlocal function celsius_to_fahrenheit(celsius)\n\treturn celsius * 9\/5 + 32\nen","completion":""}
{"prompt":"-- Returns amount of knights the player has\nlocal function knight_amount(board_state, player)\n    local count = 0\n    for i = 1, #board_state do\n        for j = 1, #board_state[i] do\n            if board_state[i][j] == player then\n                count = count + 1\n            end\n        end\n    end\n    return count\nen","completion":""}
{"prompt":"-- convert 10 base number to any base number\nlocal function base_convert(n, base)\n  local s, t, i, j\n  s, t, i, j = n, \"\", 1, 0\n  while s > 0 do\n    local k = s % base\n    t = string.char(k + 48) .. t\n    i = i + 1\n    s = (s - k) \/ base\n  end\n  return t\nen","completion":""}
{"prompt":"-- Luminance should be equal to:\n-- cosphi*costheta*sinB - cosA*costheta*sinphi -\n-- sinA*sintheta + cosB*(cosA*sintheta - costheta*sinA*sinphi);\n-- :param cos_a:\n-- :param cos_b:\n-- :param cos_phi:\n-- :param cos_theta:\n-- :param sin_a:\n-- :param sin_b:\n-- :param sin_phi:\n-- :param sin_theta:\n-- :return:\nlocal function calc_luminance(cos_a, cos_b, cos_phi, cos_theta, sin_a, sin_b, sin_phi, sin_theta)\n    return cos_phi*cos_theta*sin_b - cos_a*cos_theta*sin_phi - sin_a*sin_theta + cos_b*(cos_a*sin_theta - cos_theta*sin_a*sin_phi);\nen","completion":""}
{"prompt":"-- Converts from number(integer|float) to number(string)\n-- Args:\n-- number (`int|float`): number (integer|float)\n-- Raise:\n-- Exception\n-- Returns:\n-- ret_str ('str'): number (string)\n-- Example:\n-- >>> dev.api.number_to_string(1)\n-- '1'\n-- >>> dev.api.number_to_string(1.1)\n-- '1.1'\n-- >>> dev.api.number_to_string('1')\n-- '1'\n-- >>> dev.api.number_to_string('1.1')\n-- '1.1'\nlocal function number_to_string(number)\n  if not number then return nil end\n  if type(number) == 'number' then\n    return tostring(number)\n  elseif type(number) == 'string' then\n    local ret_str = number\n    if tonumber(number) then\n      ret_str = tostring(tonumber(number))\n    end\n    return ret_str\n  else\n    exception('number_to_string', 'Unknown type: %s', type(number))\n  end\nen","completion":""}
{"prompt":"-- Power of number in log space\nlocal function powln(n, m)\n\treturn n * m\nen","completion":""}
{"prompt":"-- Create a function that returns a constant\n-- It is useful for learning rate schedule (to avoid code duplication)\n-- :param val: (float)\n-- :return: (function)\nlocal function constfn(val)\n   return function()\n      return val\n   end\nen","completion":""}
{"prompt":"-- Check mailing_list\n-- :param sig_info: content of sig-info.yaml\n-- :param error: error count\n-- :return: error\nlocal function check_mailing_list(sig_info, error)\n  local check_error = error\n  if not sig_info.mailing_list then\n    check_error = check_error + 1\n    print(\"ERROR: missing mailing_list\")\n  end\n  return check_error\nen","completion":""}
{"prompt":"-- Evaluate the polynomial at the value x.\n-- poly is a list of coefficients from lowest to highest.\n-- :param x:     Argument at which to evaluate\n-- :param poly:  The polynomial coefficients, lowest order to highest\n-- :return:      The result of evaluating the polynomial at x\nlocal function evaluate(x, poly)\n  local value = 0\n  for i = 1, #poly do\n    value = value + poly[i] * math.pow(x, i - 1)\n  end\n  return value\nen","completion":""}
{"prompt":"-- Returns the max subarray of the given list of numbers.\n-- Returns 0 if  nums is None or an empty list.\n-- Time Complexity: O(n)\n-- Space Complexity: O(1)\nlocal function max_sub_array(nums)\n    if nums == nil or #nums == 0 then\n        return 0\n    end\n    local max = nums[1]\n    local curr_max = nums[1]\n    for i = 2, #nums do\n        curr_max = math.max(nums[i], curr_max + nums[i])\n        max = math.max(max, curr_max)\n    end\n    return max\nen","completion":""}
{"prompt":"-- This function calculates nCr.\nlocal function combination(n, r)\n    if r == 0 then return 1 end\n    local ncr = 1;\n    for i = 1, r do\n        ncr = ncr * (n - r + i) \/ i\n    end\n    return ncr;\nen","completion":""}
{"prompt":"-- Format as hex upercase\nlocal function h2(inp)\n    return string.upper(string.format(\"%02x\", inp))\nen","completion":""}
{"prompt":"-- Simple equality test.\n-- 0.0 if the labels are identical, 1.0 if they are different.\n-- >>> from nltk.metrics import binary_distance\n-- >>> binary_distance(1,1)\n-- 0.0\n-- >>> binary_distance(1,3)\n-- 1.0\nlocal function binary_distance(label1, label2)\n  return (label1 == label2 and 0) or 1\nen","completion":""}
{"prompt":"-- text(str) -> str\n-- Remove all duplicate whitespaces, \\n and \\t\nlocal function strip_white_space(text)\n    return text:gsub('%s+', ' '):gsub('[\\t\\n]+', ' '):gsub('^%s+', ''):gsub('%s+$', '')\nen","completion":""}
{"prompt":"-- Return a matrix of reflexive closure of the relation.\n-- >>> find_reflexive_relation([[1, 1, 1], [0, 0, 0], [1, 0, 0]])\n-- [[1, 1, 1], [0, 1, 0], [1, 0, 1]]\nlocal function find_reflexive_relation(matrix)\n  for i = 1, #matrix do\n    matrix[i][i] = 1\n  end\n  return matrix\nen","completion":""}
{"prompt":"-- clamp x to be l <= x <= u\n-- >>> clamp(5, 1, 10)\n-- 5\n-- >>> clamp(-1, 1, 10)\n-- 1\n-- >>> clamp(12, 1, 10)\n-- 10\nlocal function clamp(x, l, u)\n    if x < l then return l end\n    if x > u then return u end\n    return x\nen","completion":""}
{"prompt":"-- clips x between min_x and max_x\nlocal function clip(x, min_x, max_x)\n  if x < min_x then return min_x\n  elseif x > max_x then return max_x\n  else return x\n  end\nen","completion":""}
{"prompt":"-- Converts a boolean option to a CMake ON\/OFF switch\nlocal function enable_option(value)\n\treturn value and \"ON\" or \"OFF\"\nen","completion":""}
{"prompt":"-- Strips white space from left and right ends\nlocal function strip_space(str)\n  str = string.gsub(str, \"^%s*(.-)%s*$\", \"%1\")\n  return str\nen","completion":""}
{"prompt":"-- Given two friends, do they have sny hobbies in common?\n-- - a: friend #1, a tuple of (name, age, list-of-hobbies)\n-- - b: same, for friend #2\n-- Returns True if they have any hobbies in common, False is not.\n-- >>> elmo = ('Elmo', 5, ['hugging', 'being nice'])\n-- >>> sauron = ('Sauron', 5000, ['killing hobbits', 'chess'])\n-- >>> gandalf = ('Gandalf', 10000, ['waving wands', 'chess'])\n-- >>> friend_date(elmo, sauron)\n-- False\n-- >>> friend_date(sauron, gandalf)\n-- True\nlocal function friend_date(a, b)\n    -- Your code here\n    local a_hobbies = a[3]\n    local b_hobbies = b[3]\n    for i = 1, #a_hobbies do\n        for j = 1, #b_hobbies do\n            if a_hobbies[i] == b_hobbies[j] then\n                return true\n            end\n        end\n    end\n    return false\nen","completion":""}
{"prompt":"-- Find the mean and sample standard deviation of border\n-- pixels. Subtract the mean intensity from every pixel.\n-- Return the sample standard deviation.\nlocal function initial_subtract(pixels, width, height)\n   local mean, sd = 0, 0\n   local border = 4\n   local m1, m2 = 0, 0\n   local n = 0\n   for i = border, width - border do\n      for j = border, height - border do\n         m1 = m1 + pixels[i * height + j]\n         n = n + 1\n      end\n   end\n   mean = m1 \/ n\n   for i = border, width - border do\n      for j = border, height - border do\n         m2 = m2 + math.pow(pixels[i * height + j] - mean, 2)\n      end\n   end\n   sd = math.sqrt(m2 \/ (n - 1))\n   for i = border, width - border do\n      for j = border, height - border do\n         pixels[i * height + j] = pixels[i * height + j] - mean\n      end\n   end\n   return sd\nen","completion":""}
{"prompt":"-- Truncates a float\n-- INPUT:\n-- - ``x`` -- value to be truncated\n-- - ``precision`` -- number of decimal places to after which the ``x`` is truncated\nlocal function __truncate(x, precision)\n  local y = 10^precision\n  return math.floor(x * y)\/y\nen","completion":""}
{"prompt":"-- c is a number, v is a vector\nlocal function scalar_multiply(c, v)\n  local r = {}\n  for k, v in pairs(v) do\n    r[k] = c * v\n  end\n  return r\nen","completion":""}
{"prompt":"-- Returns the nth hexagonal number, starting with 1.\nlocal function hexagonal(n)\n  return n * (2 * n - 1)\nen","completion":""}
{"prompt":"-- Add one to the message ID\n-- This is useful when we need to xrange() events exclusive of the given ID,\n-- rather than inclusive of the given ID (which is the sensible default).\n-- There is no chance of missing events with this method.\nlocal function redis_stream_id_add_one(message_id)\n  if message_id:find(\"-\") then\n    local stream_name, sequence = message_id:match(\"(%S+)-(%d+)\")\n    if stream_name and sequence then\n      local next_sequence = tonumber(sequence) + 1\n      return string.format(\"%s-%d\", stream_name, next_sequence)\n    end\n  else\n    return message_id .. \"-1\"\n  end\nen","completion":""}
{"prompt":"-- :param lst: list of dictionary\n-- :param key: key value want to flat\n-- :return: string flat with ','\nlocal function spark_points_flat(lst, key)\n    local list = {}\n    for _, v in pairs(lst) do\n        if v[key] then\n            table.insert(list, tostring(v[key]))\n        end\n    end\n    return table.concat(list, \",\")\nen","completion":""}
{"prompt":"-- Get the selected element of an array\nlocal function get_selected(array)\n\tif type(array) == \"table\" then\n\t\tfor i = 1, #array do\n\t\t\tif array[i].selected then\n\t\t\t\treturn array[i]\n\t\t\tend\n\t\tend\n\tend\n\treturn nil\nen","completion":""}
{"prompt":"-- :param cql:\n-- :return:\nlocal function remove_block_comments(cql)\n    return string.gsub(cql, '\/%*.-%*\/', '')\nen","completion":""}
{"prompt":"-- Returns a copy of the string with the first letter lowercased\nlocal function lcFirst(s)\n  return s:sub(1,1):lower()..s:sub(2)\nen","completion":""}
{"prompt":"-- Takes a dict with nested lists and dicts,\n-- and searches all dicts for a key of the field\n-- provided.\nlocal function get_recursively(search_dict, field)\n  local found_list = {}\n  if type(search_dict) == \"table\" then\n    for k, v in pairs(search_dict) do\n      if k == field then\n        table.insert(found_list, v)\n      elseif type(v) == \"table\" then\n        local results = get_recursively(v, field)\n        for _, item in pairs(results) do\n          table.insert(found_list, item)\n        end\n      end\n    end\n  end\n  return found_list\nen","completion":""}
{"prompt":"-- The recursive definition of the Thue-Morse sequence.\n-- The first few terms of the Thue-Morse sequence are:\n-- 0 1 1 0 1 0 0 1 1 0 0 1 0 1 1 0 . . .\nlocal function recursive_thue_morse(n)\n    if n == 0 then\n        return 0\n    elseif n == 1 then\n        return 1\n    elseif (n % 2) == 0 then\n        return recursive_thue_morse(n \/ 2)\n    else\n        return 1 - recursive_thue_morse((n - 1) \/ 2)\n    end\nen","completion":""}
{"prompt":"-- Assume that sides of a polygon with the same latitude should\n-- be rendered as curves following that latitude instead of\n-- straight lines on the final map projection\nlocal function _add_extra_longitude_points(gjson)\n\tlocal coordinates = gjson.coordinates\n\tlocal n_points = #coordinates\n\tfor i = 1, n_points - 1 do\n\t\tif math.abs(coordinates[i][1] - coordinates[i + 1][1]) > 0.00001 then\n\t\t\tcoordinates[#coordinates + 1] = {coordinates[i][1], coordinates[i + 1][2]}\n\t\tend\n\tend\n\treturn gjson\nen","completion":""}
{"prompt":"-- :param t_pr: (float) Reduced temperature of the natural gas, dimensionless\n-- :param p_pr: (float) Reduced pressure of the natural gas, dimensionless\n-- :return: (float) Compressibility factor, dimensionless\nlocal function compressibility_factor(t_pr, p_pr)\n\tlocal alpha = 1000.0\n\tlocal a = 1.0 + 1e-7 * (t_pr - 1000.0) \/ t_pr\n\tlocal b = -0.449 * math.log(p_pr)\n\treturn 1.0 \/ (1.0 + math.exp(alpha * (a - b)))\nen","completion":""}
{"prompt":"-- This function will break up words for us.\nlocal function break_words(stuff)\n\tlocal t = {}\n\tlocal function helper(line)\n\t\tfor w in line:gmatch(\"%S+\") do\n\t\t\ttable.insert(t, w)\n\t\tend\n\tend\n\thelper(stuff)\n\treturn t\nen","completion":""}
{"prompt":"-- Test function to test the handling failures for `fmin`. When run `fmin` with `max_evals=8`,\n-- it has 7 successful trial runs and 1 failed run.\n-- :param x:\n-- :return: 1 when -3 < x < 3, and RuntimeError otherwise\nlocal function fn_succeed_within_range(x)\n  if x > -3 and x < 3 then\n    return 1\n  else\n    error(\"x out of range\")\n  end\nen","completion":""}
{"prompt":"-- Calculates the percentage along a line from **MinValue** to **MaxValue** that value is.\n-- :param MinValue: Minimum Value\n-- :param MaxValue: Maximum Value\n-- :param Value: Input value\n-- :returns: The percentage (from 0.0 to 1.0) betwen the two values where input value is\nlocal function GetRangePct(MinValue, MaxValue, Value)\n\treturn (Value - MinValue) \/ (MaxValue - MinValue)\nen","completion":""}
{"prompt":"-- Hard assign label after prediction of Keras model\n-- Args:\n-- ypred (int): Percentage that the label will be 0 or 1.\n-- thresh (float): Default=0.5 Threshold to assign labels.\n-- Returns:\n-- Label 0 if smaller than threshold and label 1 if larger than threshold.\nlocal function hard_label(ypred, thresh)\n  thresh = thresh or 0.5\n  if ypred > thresh then\n    return 1\n  else\n    return 0\n  end\nen","completion":""}
{"prompt":"-- Calculates the number of time steps supply is\n-- under demand\n-- Parameters\n-- ----------\n-- dict_demand: timeseries dictionary of demand values\n-- dict_supply: timeseries dictionary of supply values\n-- Returns\n-- -------\n-- returns an int of the number of time steps supply is\n-- under demand\nlocal function supply_under_demand(all_dict, demand_driven)\n\tlocal num_of_timesteps = 0\n\tif demand_driven == \"none\" then\n\t\tfor _, value in pairs(all_dict) do\n\t\t\tif value.supply < value.demand then\n\t\t\t\tnum_of_timesteps = num_of_timesteps + 1\n\t\t\tend\n\t\tend\n\telseif demand_driven == \"supply\" then\n\t\tfor _, value in pairs(all_dict) do\n\t\t\tif value.supply < 0 then\n\t\t\t\tnum_of_timesteps = num_of_timesteps + 1\n\t\t\tend\n\t\tend\n\telseif demand_driven == \"demand\" then\n\t\tfor _, value in pairs(all_dict) do\n\t\t\tif value.demand < 0 then\n\t\t\t\tnum_of_timesteps = num_of_timesteps + 1\n\t\t\tend\n\t\tend\n\telse\n\t\tprint(\"Unknown demand driven type\")\n\t\tos.exit()\n\tend\n\treturn num_of_timesteps\nen","completion":""}
{"prompt":"-- Transform annotation dumbly, asserting it is a string.\nlocal function transform_annotation(annotation)\n  assert(type(annotation) == \"string\")\n  return annotation\nen","completion":""}
{"prompt":"-- Function to convert ppm tolerances to Dalton.\n-- Args:\n-- mass (float): Base mass.\n-- prec_tol (int): Tolerance.\n-- Returns:\n-- float: Tolerance in Dalton.\nlocal function ppm_to_dalton(mass, prec_tol)\n    return mass * prec_tol \/ 1000000\nen","completion":""}
{"prompt":"-- Convert PPE\/rep regions to NAs\nlocal function remove_regions(d, regions)\n  d[regions] = NA\n  return d\nen","completion":""}
{"prompt":"-- Calculates g_max\nlocal function calc_g_max(g_cur, g_max)\n    return g_cur > g_max and g_cur or g_max\nen","completion":""}
{"prompt":"-- Round down an integer to a multiple of divider.\nlocal function round_down(rounded, divider)\n    return rounded - (rounded % divider)\nen","completion":""}
{"prompt":"-- UNUSED: return the largest value of a and b\nlocal function maximum(a, b)\n  return (a > b and a or b)\nen","completion":""}
{"prompt":"-- Calculates the sum from 1 to n.\n-- see https:\/\/en.wikipedia.org\/wiki\/1_%2B_2_%2B_3_%2B_4_%2B_%E2%8B%AF\n-- :rtype: int\n-- :param n: the integer to sum up to\n-- :return: sum from 1 to n\nlocal function sum_1_n(n)\n\treturn n * (n + 1) \/ 2\nen","completion":""}
{"prompt":"-- map() function of javascript\nlocal function mapFromTo(x, a, b, c, d)\n    local scale = (d - c) \/ (b - a)\n    return c + (x - a) * scale\nen","completion":""}
{"prompt":"-- Uses dynamic programming technique to return the nth ugly number.\n-- >>> ugly_numbers(100)\n-- 1536\n-- >>> ugly_numbers(1)\n-- 1\n-- >>> ugly_numbers(20)\n-- 36\nlocal function ugly_numbers(n)\n  local t = { 1 }\n  local p2, p3, p5 = 1, 1, 1\n  local i, j, k\n  for i = 2, n do\n    t[i] = math.min(t[p2] * 2, t[p3] * 3, t[p5] * 5)\n    if t[i] == t[p2] * 2 then p2 = p2 + 1 end\n    if t[i] == t[p3] * 3 then p3 = p3 + 1 end\n    if t[i] == t[p5] * 5 then p5 = p5 + 1 end\n  end\n  return t[n]\nen","completion":""}
{"prompt":"-- Extract an excert of a post\nlocal function _jinja2_filter_datetime(data)\n    local ret = data:gsub('(%d{4})(%d{2})(%d{2})%s*(%d{2})(%d{2})(%d{2})', '%3-%2-%1 %4:%5:%6')\n    return ret\nen","completion":""}
{"prompt":"-- Pluralize a count and given its units.\n-- >>> pluralize(1, 'file')\n-- '1 file'\n-- >>> pluralize(2, 'file')\n-- '2 files'\n-- >>> pluralize(0, 'file')\n-- '0 files'\nlocal function pluralize(count, unit)\n  return count == 0 and \"0 \" .. unit .. \"s\" or count .. \" \" .. unit .. (count > 1 and \"s\" or \"\")\nen","completion":""}
{"prompt":"-- Convert one element into a list of that element. No-op on list inputs.\nlocal function listify(x)\n\tif type(x) == \"table\" then\n\t\treturn x\n\telse\n\t\treturn {x}\n\tend\nen","completion":""}
{"prompt":"-- Riemann problem for advection -- this is simply upwinding,\n-- but we return the flux\nlocal function riemann(u, al, ar)\n    if u > 0.0 then\n        return u*al\n    else\n        return u*ar\n    end\nen","completion":""}
{"prompt":"-- converts a tuple of intergers to a version number\nlocal function str_version(version)\n\treturn table.concat(version, '.')\nen","completion":""}
{"prompt":"-- given a frame number and a starting pt offset, compute the expected pt for the frame.\n-- Frame is assumed to be an index (0-based)\nlocal function frame_index_to_pts(frame, start_pt, diff_per_frame)\n    if frame ~= 0 and diff_per_frame ~= 0 then\n        return frame * diff_per_frame + start_pt\n    end\n    return start_pt\nen","completion":""}
{"prompt":"-- split comma-separated string into list of elements,\n-- stripping whitespace.\nlocal function splitcomma(source, sep)\n    sep = sep or \",\"\n    local t = {}\n    for w in source:gmatch('([^' .. sep .. ']+)') do\n        local s = w:match('^%s*(.-)%s*$')\n        if #s > 0 then t[#t+1] = s end\n    end\n    return t\nen","completion":""}
{"prompt":"-- Returns all but the first and last characters of a string.\nlocal function middle(word)\n  return word:sub(2, #word - 1)\nen","completion":""}
{"prompt":"-- Return an array of tuples (ip, port) extracted from ip:port string\n-- :param args_clients:\n-- :return:\nlocal function parse_clients_args(endpoints)\n    local clients = {}\n    if type(endpoints) == \"string\" then\n        clients = {endpoints}\n    elseif type(endpoints) == \"table\" then\n        for _, endpoint in pairs(endpoints) do\n            table.insert(clients, endpoint)\n        end\n    end\n    local clients_endpoints = {}\n    for _, endpoint in pairs(clients) do\n        local _, _, ip, port = string.find(endpoint, \"([0-9a-fA-F.:]+):(%d+)\")\n        if ip and port then\n            table.insert(clients_endpoints, {ip, tonumber(port)})\n        end\n    end\n    return clients_endpoints\nen","completion":""}
{"prompt":"-- Calculates sum of database dumps\n-- :param data: accepts multi-dimensional iterable data type\n-- :return: returns total amount in a FLOAT\nlocal function summing_it(data)\n\tif not data or not data[1] then return 0 end\n\tlocal sum = 0\n\tfor i = 1, #data, 1 do\n\t\tsum = sum + data[i][1]\n\tend\n\treturn sum\nen","completion":""}
{"prompt":"-- subtract two vectors: non-array results\n-- vec_1 & vec_2: XYZ components of the vectors.\n-- returns: list of resulting  vector\nlocal function subtract_vectors(vec_1, vec_2)\n    return {\n        vec_1[1] - vec_2[1],\n        vec_1[2] - vec_2[2],\n        vec_1[3] - vec_2[3]\n    }\nen","completion":""}
{"prompt":"-- Create a function that always returns a specific value.\n-- * v -- The value the returned function always returns\nlocal function const(v)\n  return function() return v end\nen","completion":""}
{"prompt":"-- crslt: dictionary of classification results\nlocal function get_brief_classification(crslt)\n  local brief_crslt = {}\n  for k,v in pairs(crslt) do\n    if type(v) == 'table' then\n      brief_crslt[k] = v[1]\n    else\n      brief_crslt[k] = v\n    end\n  end\n  return brief_crslt\nen","completion":""}
{"prompt":"-- Map Value from one range to another.\nlocal function map_range(x, in_min, in_max, out_min, out_max)\n    return (x - in_min) * (out_max - out_min) \/ (in_max - in_min) + out_min\nen","completion":""}
{"prompt":"-- :param X: a data matrix: a list wrapping a list of strings, with each sublist being a sentence.\n-- :return:\n-- >>> drop_empty_lists([['Catullus'], [], [], ['I.', 'ad', 'Cornelium'], ['Cui', 'dono', 'lepidum', 'novum', 'libellum', 'arida', 'modo', 'pumice', 'expolitum', '?']])\n-- [['Catullus'], ['I.', 'ad', 'Cornelium'], ['Cui', 'dono', 'lepidum', 'novum', 'libellum', 'arida', 'modo', 'pumice', 'expolitum', '?']]\nlocal function drop_empty_lists(X)\n  local X_dropped = {}\n  for _, x in pairs(X) do\n    if #x > 0 then\n      table.insert(X_dropped, x)\n    end\n  end\n  return X_dropped\nen","completion":""}
{"prompt":"-- Get a path part of a sequence number styled path (e.g. 000\/002\/345)\n-- Args:\n-- sequence_number (int): sequence number (a positive integer)\n-- denominator (int): denominator used to extract the relevant part of a path\n-- Returns:\n-- str: part of a path\nlocal function get_path_part_from_sequence_number(sequence_number, denominator)\n  local path_part = math.floor((sequence_number \/ denominator) % 1000)\n  return string.format(\"%03d\", path_part)\nen","completion":""}
{"prompt":"-- Return the largest multiple of y < x\n-- Args:\n-- x (int): the number to round\n-- y (int): the multiplier\n-- Returns:\n-- int: largest multiple of y <= x\nlocal function roundToMultiple(x, y)\n  return math.floor(x\/y+0.5)*y\nen","completion":""}
{"prompt":"-- Get the high frequency point\n-- Parameters\n-- ----------\n-- TR : float\n-- Temporal Resolution\n-- nvols : int\n-- Number of volumes\n-- LP : float\n-- LowPass High Cutoff Frequency\n-- HP : float\n-- HighPass Low Cutoff Frequency\n-- Returns\n-- -------\n-- n2 : float\n-- High Frequency Point\nlocal function get_N2(nvols, TR, LP, HP)\n\treturn math.ceil(math.sqrt(nvols*TR*LP*HP)*2)\nen","completion":""}
{"prompt":"-- Calculate the double factorial of specified number\n-- >>>double_factorial(5)\n-- 15\n-- >>>double_factorial(8)\n-- 384\n-- >>>double_factorial(3)\n-- 3\n-- >>>double_factorial(0)\n-- 1\n-- >>>-1\n-- Traceback (most recent call last):\n-- File \"<string>\", line 11, in <module>\n-- File \"<string>\", line 4, in doublefactorial\n-- ValueError: double_factorial() not defined for negative values\nlocal function double_factorial(input_num)\n\tif input_num < 0 then\n\t\terror(\"double_factorial() not defined for negative values\")\n\telseif input_num == 0 or input_num == 1 then\n\t\treturn 1\n\telse\n\t\treturn input_num*double_factorial(input_num-2)\n\tend\nen","completion":""}
{"prompt":"-- Return the dimension of a Stiefel manifold St(1, p)^n.\n-- in general, dim St(d, p)^m = mdp - .5 * md(d + 1)\n-- hence here, dim St(1, p)^n = np - n = n(p - 1)\nlocal function stiefel_dimension(dim_n, dim_p)\n    return dim_n * (dim_p - 1)\nen","completion":""}
{"prompt":"-- Return a copy of line with each ASCII control character (0-31),\n-- and each double quote, removed.\nlocal function _removeInvalidChars(line)\n\treturn line:gsub(\"[%z\\1-\\31\\\"\\\\]\", \"\")\nen","completion":""}
{"prompt":"-- Returns Celsius temperature as Fahrenheit\nlocal function c_to_f(temp) return (temp * 9\/5) + 32 en","completion":""}
{"prompt":"-- Map one number scale to another\n-- For example, to convert a score of 4 stars out of 5 into a percentage:\n-- >>> rescale((0, 5), (0, 100), 4)\n-- 80.0\n-- Great for mapping different input values into LED pixel brightnesses!\nlocal function rescale(src_scale, dest_scale, x)\n  local src_min = src_scale[1]\n  local src_max = src_scale[2]\n  local dest_min = dest_scale[1]\n  local dest_max = dest_scale[2]\n  local percent = (x - src_min) \/ (src_max - src_min)\n  return percent * (dest_max - dest_min) + dest_min\nen","completion":""}
{"prompt":"-- Intermediate values take on the value associated with the next lower\n-- x-coordinate (also called a step-wise function). The last two points\n-- of a discrete graphical function must have the same y value.\n-- Out-of-range values are the same as the closest endpoint\n-- (i.e, no extrapolation is performed).\nlocal function lookup_discrete(x, xs, ys)\n\tlocal i = 1\n\tfor j, xj in ipairs(xs) do\n\t\tif xj == x then return ys[j] end\n\t\tif xj > x then break end\n\t\ti = j\n\tend\n\treturn ys[i]\nen","completion":""}
{"prompt":"-- formats the ms into seconds and ms\n-- :param ms: the number of ms\n-- :return: a string representing the same amount, but now represented in seconds and ms.\nlocal function formatter(ms)\n  if ms > 1000 then\n    return string.format(\"%.3f\", ms \/ 1000) .. \"s\"\n  else\n    return ms .. \"ms\"\n  end\nen","completion":""}
{"prompt":"-- Updates the format of the WWPN to match the expected PowerVM format.\n-- :param wwpn: The original WWPN.\n-- :return: A WWPN of the format expected by the API.\nlocal function sanitize_wwpn_for_api(wwpn)\n   local sanitized = string.gsub(wwpn, \":\", \"\")\n   return string.upper(sanitized)\nen","completion":""}
{"prompt":"-- Get `n`-th hexagonal number\n-- Args:\n-- n: Index of hexagonal number\n-- Examples:\n-- >>> print(get_hexagonal(10))\n-- 190\nlocal function get_hexagonal(n)\n\treturn n * (2 * n - 1)\nen","completion":""}
{"prompt":"-- Takes a value and it's maximum potential and maps it to 0-255\n-- :param in_v: input value\n-- :param limiter: value's maximum potential\n-- :return: int\nlocal function limit_rgb(in_v, limiter)\n  return math.floor(255 * in_v \/ limiter)\nen","completion":""}
{"prompt":"-- version tuple as string\nlocal function ver_str(version)\n  if type(version) == 'string' then\n    return version\n  else\n    local result = {}\n    for i = 1, #version do\n      result[i] = tostring(version[i])\n    end\n    return table.concat(result, '.')\n  end\nen","completion":""}
{"prompt":"-- Returns width of rangoli.\nlocal function get_width(n)\n  return 4 * n - 3\nen","completion":""}
{"prompt":"-- Write a function which implements the Pascal's triangle:\n-- 1\n-- 1    1\n-- 1    2    1\n-- 1    3    3    1\n-- 1    4    6    4    1\n-- 1    5    10    10    5    1\nlocal function exercise3(n)\n  if n < 1 then error('n is < 1') end\n  local rows = {}\n  for r = 1, n do\n    rows[r] = {}\n    rows[r][1] = 1\n    rows[r][r] = 1\n    for c = 2, r - 1 do\n      rows[r][c] = rows[r - 1][c - 1] + rows[r - 1][c]\n    end\n  end\n  return rows\nen","completion":""}
{"prompt":"-- Return the name of the schema entity after stripping url.\n-- Args:\n-- x (str): URL of the enitity.\n-- Returns:\n-- str: The name of entity.\nlocal function strip_url(x)\n    return x:match(\".*\/(.*)\") or x\nen","completion":""}
{"prompt":"-- add punctuation at the end of each chunk. Mimic2\n-- expects some form of punctuations\nlocal function add_punctuation(text)\n  if (string.len(text) > 0) then\n    if (string.match(text, \".[!.?]$\") == nil) then\n      if (string.match(text, \"[!?]$\") == nil) then\n        text = text .. \".\"\n      else\n        text = text .. \" \"\n      end\n    end\n  end\n  return text\nen","completion":""}
{"prompt":"-- Convert hass brightness (0..100) to MyHomeSERVER format (0..255)\nlocal function hass_to_myhomeserver_brightness(value)\n  return math.floor(value \/ 2.55 + 0.5)\nen","completion":""}
{"prompt":"-- Calculates GCD of two numbers using Euclidean Iterative Algorithm\n-- :param first: First number\n-- :param second: Second number\n-- :return: GCD of the numbers\nlocal function euclidean_gcd(first, second)\n  if first == 0 then\n    return second\n  end\n  return euclidean_gcd(second % first, first)\nen","completion":""}
{"prompt":"-- Get indentation for given level.\nlocal function get_indent(op)\n  local t = {}\n  for i=1,op do t[i] = '  ' end\n  return table.concat(t)\nen","completion":""}
{"prompt":"-- Keeps val in the range of min_val and max_val\nlocal function constrain(val, min_val, max_val)\n  return math.min(math.max(val, min_val), max_val)\nen","completion":""}
{"prompt":"-- Rotate a molecule\n-- :param numpoints:  the number of points in the list\n-- :type numpoints:  int\n-- :param coor:  the input coordinates\n-- :type coor:  [[float, float, float]]\n-- :param lrot:  the left rotation matrix\n-- :type lrot:  [[float, float, float]]\n-- :return:  the rotated coordinates\n-- :rtype:  [[float, float, float]]\nlocal function rotmol(numpoints, coor, lrot)\n\tlocal newcoor = {}\n\tfor k, atom in ipairs(coor) do\n\t\tlocal x = atom[1];\n\t\tlocal y = atom[2];\n\t\tlocal z = atom[3];\n\t\tlocal newx = lrot[1][1] * x + lrot[2][1] * y + lrot[3][1] * z;\n\t\tlocal newy = lrot[1][2] * x + lrot[2][2] * y + lrot[3][2] * z;\n\t\tlocal newz = lrot[1][3] * x + lrot[2][3] * y + lrot[3][3] * z;\n\t\tlocal newatom = {newx, newy, newz};\n\t\ttable.insert(newcoor, newatom)\n\tend\n\treturn newcoor\nen","completion":""}
{"prompt":"-- Linear learning rate schedule.\n-- :param initial_value: (float or str)\n-- :return: (function)\nlocal function linear_schedule(initial_value)\n  return function(t)\n    if initial_value == 'optimal' then\n      return math.sqrt(t)\n    else\n      return initial_value * t\n    end\n  end\nen","completion":""}
{"prompt":"-- Normalizing the training and test dataset\nlocal function get_normalized_data(x, min_val, max_val)\n    local norm = (x - min_val) \/ (max_val - min_val)\n    return norm\nen","completion":""}
{"prompt":"-- Given a unicode address *addr*, return a (byte, on\n-- Python 3) string that is suitable to be passed as an\n-- argument to sendmail.\nlocal function encode_address(addr)\n  -- A very basic encoding.  We do not want to use MIME\n  -- because of the various corner cases that can happen,\n  -- such as when the mail header ends with a non-ASCII\n  -- character and the mail body starts with the same\n  -- character (see RFC 2047).  This encoding is not\n  -- intended to be robust, but rather to work well with\n  -- the smallest subset of addresses that we need to\n  -- support.  For example, we do not escape dots that\n  -- appear in domain names.\n  return string.gsub(addr, '[%z\\1-\\127]', function (c)\n    if string.byte(c) < 128 then\n      return c\n    end\n    return '=?UTF-8?Q?' .. string.gsub(c, '.', function (c)\n      return string.format('%02X', string.byte(c))\n    end) .. '?='\n  end)\nen","completion":""}
{"prompt":"-- Solves naked twins per one type of peers of a box\n-- :param values: grid values\n-- :param box: box\n-- :param box_peers: peers of a single type of a box\n-- :return: grid values with adjusted naked twins\nlocal function naked_twins_on_peers(values, box, box_peers)\n  for _, peer in pairs(box_peers) do\n    if peer.naked_twins then\n      if peer.type == \"row\" then\n        for i = peer.start_x, peer.end_x, 1 do\n          values[box.y][i] = nil\n        end\n      elseif peer.type == \"column\" then\n        for i = peer.start_y, peer.end_y, 1 do\n          values[i][box.x] = nil\n        end\n      elseif peer.type == \"box\" then\n        local box_x = math.floor((box.x - 1) \/ 3) * 3 + 1\n        local box_y = math.floor((box.y - 1) \/ 3) * 3 + 1\n        for i = 1, 3, 1 do\n          for j = 1, 3, 1 do\n            values[box_y + i][box_x + j] = nil\n          end\n        end\n      end\n    end\n  end\n  return values\nen","completion":""}
{"prompt":"-- Takes Numeric Code and returns String API code\n-- Input Values: 1:\"Totals\", 2:\"PerGame\"\n-- Used in:\nlocal function per_mode_mini(x)\n  if x == 1 then return \"Totals\"\n  elseif x == 2 then return \"PerGame\" end\nen","completion":""}
{"prompt":"-- Convert float to nicely formatted string\n-- :param f: float to convert to string\n-- :type f: float\n-- :param var: (optional) tkinter.StringVar to write value to\n-- :type var: None or tkinter.StringVar\n-- :return: string with nicely formatted float, or None\n-- :rtype: str or None\nlocal function float2str(f, var)\n    local str = string.format('%f', f)\n    if str:find(\"%.\") then\n        -- Remove trailing zeros\n        str = str:gsub(\"%.?0*$\", \"\")\n        -- Remove trailing dot\n        str = str:gsub(\"[.]$\", \"\")\n    end\n    if var then\n        var:set(str)\n    end\n    return str\nen","completion":""}
{"prompt":"-- Check 0 \n-- >>> int_to_hex(0)\n-- '0'\n-- Value less than 10\n-- >>> int_to_hex(9)\n-- '9'\n-- Value requiring letter digits\n-- >>> int_to_hex(15)\n-- 'F'\n-- Boundary (Uses 10s place)\n-- >>> int_to_hex(16)\n-- '10'\n-- Boundary (Uses 10s, and 1s places)\n-- >>> int_to_hex(17)\n-- '11'\n-- Multiple 16ths\n-- >>> int_to_hex(129)\n-- '81'\n-- Boundary (Uses 100s, 10s, and 1s places)\n-- >>> int_to_hex(301)\n-- '12D'\nlocal function int_to_hex(number)\n    local temp_str = \"\"\n    if number == 0 then\n        return \"0\"\n    else\n        while number > 0 do\n            local temp = number % 16\n            if temp == 10 then\n                temp_str = \"A\" .. temp_str\n            elseif temp == 11 then\n                temp_str = \"B\" .. temp_str\n            elseif temp == 12 then\n                temp_str = \"C\" .. temp_str\n            elseif temp == 13 then\n                temp_str = \"D\" .. temp_str\n            elseif temp == 14 then\n                temp_str = \"E\" .. temp_str\n            elseif temp == 15 then\n                temp_str = \"F\" .. temp_str\n            else\n                temp_str = tostring(temp) .. temp_str\n            end\n            number = math.floor(number \/ 16)\n        end\n    end\n    return temp_str\nen","completion":""}
{"prompt":"-- Retruns something.\nlocal function vecMul(vec, sca)\n  local new_vec = {}\n  for i,v in ipairs(vec) do\n    new_vec[i] = v * sca\n  end\n  return new_vec\nen","completion":""}
{"prompt":"-- Returns the URL encoded SMILES containing special characters as regular SMILES.\n-- Parameters\n-- ----------\n-- url_encoded_smiles : str\n-- A SMILES containing standard URL encoding symbols, such as %2F.\n-- Returns\n-- -------\n-- str :\n-- The SMILES with special characters as such.\n-- : <- %3A\n-- \\ <- %5C (here backslash)\n-- \/ <- %2F\n-- * <- %2A\n-- Notes\n-- -----\n-- https:\/\/www.degraeve.com\/reference\/urlencoding.php\nlocal function smiles_from_folder_name(url_encoded_smiles)\n  return url_encoded_smiles:gsub('%%3A', ':'):gsub('%%2F', '\/'):gsub('%%5C', '\\\\'):gsub('%%2A', '*')\nen","completion":""}
{"prompt":"-- :param angle:\n-- :param maxleft:\n-- :param maxright:\n-- :return:\n-- >>> checklimits(50, -45, 30)\n-- 30\n-- >>> checklimits(-50, -45, 30)\n-- -45\n-- >>> checklimits(-20, -45, 30)\n-- -20\nlocal function checklimits(angle, maxleft, maxright)\n    if angle > maxleft and angle < maxright then\n        return angle\n    elseif angle > maxleft then\n        return maxright\n    elseif angle < maxright then\n        return maxleft\n    else\n        return angle\n    end\nen","completion":""}
{"prompt":"-- Computes the value of the first specified argument clamped to a range\n-- defined by the second and third specified arguments\n-- :param n: input Value\n-- :param vmin: MiniMum Value\n-- :param vmax: Maximum Value\n-- :returns: The clamped value of n\nlocal function clamp(n, vmin, vmax)\n    return math.min(math.max(n, vmin), vmax)\nen","completion":""}
{"prompt":"-- Display + or - in front of UTC offset number\nlocal function offset_format(utc_offset)\n  if utc_offset >= 0 then\n    return '+' .. utc_offset\n  else\n    return '-' .. -utc_offset\n  end\nen","completion":""}
{"prompt":"-- Replace ``&`` with ``and`` and ``|`` with ``or`` so that bitwise\n-- precedence is changed to boolean precedence.\nlocal function _replace_booleans(source)\n   return source:gsub(\"&\", \" and \"):gsub(\"|\", \" or \")\nen","completion":""}
{"prompt":"-- Turn the serialized key\/value pairs back into a dict.\nlocal function unwrap_args(form_query_argument_list)\n    local new_args = {}\n    for _, kv in pairs(form_query_argument_list) do\n        new_args[kv.key] = kv.value\n    end\n    return new_args\nen","completion":""}
{"prompt":"-- The elements of the \"unknown\" basis.  Just returns an empty list.\n-- Parameters\n-- ----------\n-- dim : int\n-- The dimension of the basis (doesn't really matter).\n-- Returns\n-- -------\n-- list\nlocal function unknown_els(dim)\n  return {}\nen","completion":""}
{"prompt":"-- Given a valid and complete URI, return just the repo name portion. Does no validation as to whether this is a\n-- valid repo or uri.\n-- :param uri:\n-- The valid and complete URI.\n-- :return:\n-- A repo name.\nlocal function repo_name_from_uri(uri)\n    local uri_without_protocol = string.gsub(uri, \"^.*:\/\/\", \"\")\n    return string.match(uri_without_protocol, \".*\")\nen","completion":""}
{"prompt":"-- Returns the argument as a list. If already a list, ``arg`` is returned.\nlocal function make_list(arg)\n  return type(arg) == 'table' and arg or { arg }\nen","completion":""}
{"prompt":"-- Compute the volume given the *celldms*. Only for ibrav=4 for now, else \n-- returns 0.\nlocal function compute_volume(celldms, ibrav)\n\tif ibrav == 4 then\n\t\tlocal alpha = celldms[1];\n\t\tlocal beta  = celldms[2];\n\t\tlocal gamma = celldms[3];\n\t\tlocal volume = (beta * gamma * alpha) \/ (6 * math.sqrt(3));\n\t\treturn volume;\n\telse\n\t\treturn 0.0;\n\tend\nen","completion":""}
{"prompt":"-- finds letters in text between strl and strr\n-- returns list of tuples (string, pos of strl, and pos of strr)\nlocal function letters_between(text, strl, strr)\n  local r = {}\n  local last_end = 0\n  while true do\n    local start, end_ = text:find(strl, last_end)\n    if not start then break end\n    local end_ = text:find(strr, start + #strl)\n    if not end_ then break end\n    last_end = end_ + 1\n    r[#r + 1] = text:sub(start, end_)\n  end\n  return r\nen","completion":""}
{"prompt":"-- Convert an object `s` to float if possible.\n-- Function to be passed into :func:`map` or a list comprehension. If\n-- the argument can be interpreted as a float it is converted,\n-- otherwise the original object is passed back.\nlocal function conv_float(s)\n    local f = tonumber(s)\n    if f then return f else return s end\nen","completion":""}
{"prompt":"-- Provides SQLite SQL to convert a column to a ``DATETIME`` in UTC. The\n-- argument ``x`` is the SQL expression to be converted (such as a column\n-- name).\n-- Output like:\n-- .. code-block:: none\n-- 2015-11-14 18:52:47.000\n-- 2015-11-14 18:52:47.247\n-- Internally, we don't use ``DATETIME()``; using ``STRFTIME()`` allows\n-- millsecond precision.\nlocal function iso_string_to_sql_utcdatetime_sqlite(x)\n  return \"STRFTIME('%Y-%m-%d %H:%M:%f', \" .. x .. \")\"\nen","completion":""}
{"prompt":"-- :param model_file_name: string\nlocal function get_worker_num_from_model_file_name(model_file_name)\n    local worker_num = string.match(model_file_name, \"[0-9]+\")\n    if worker_num == nil then\n        worker_num = 1\n    end\n    return tonumber(worker_num)\nen","completion":""}
{"prompt":"-- Return the corresponding red cube path matched to a blue cube path.\nlocal function red_cube_path(blue_path)\n\treturn blue_path:gsub(\"blue\", \"red\")\nen","completion":""}
{"prompt":"-- Turn an int string into a number, but leave a non-int string alone.\nlocal function atoi(text)\n  if text:match('^%d+$') then\n    return tonumber(text)\n  else\n    return text\n  end\nen","completion":""}
{"prompt":"-- Formats the string *string*  to ensures the line lengths are not\n-- larger than *length*. The optional argument *indent* specifies the\n-- number of spaces to insert at the beginning of all lines except the\n-- first. The line breaks are inserted at spaces.\n-- An example is given below::\n-- >>> import egglib\n-- >>> string = \"Lekrrjf djdhs eeir djs ehehf bnreh eurvz rhffdvfu dksgta.\"\n-- >>> print egglib.tools.wrap(string, 20, 4)\n-- Lekrrjf djdhs eeir\n-- djs ehehf bnreh\n-- eurvz rhffdvfu\n-- dksgta.\nlocal function wrap(string, length, indent)\n  indent = indent or 0\n  if indent < 0 then indent = 0 end\n  local result = {}\n  local line = {}\n  local count = 0\n  local length = length - indent\n  local string_length = #string\n  for i = 1, string_length do\n    local c = string:sub(i, i)\n    if c == \" \" then\n      if count > length then\n        table.insert(result, table.concat(line, \"\"))\n        line = {}\n        count = 0\n      end\n    elseif c == \"\\n\" then\n      table.insert(result, table.concat(line, \"\"))\n      table.insert(result, \"\\n\")\n      line = {}\n      count = 0\n    else\n      table.insert(line, c)\n      count = count + 1\n    end\n  end\n  table.insert(result, table.concat(line, \"\"))\n  return table.concat(result, \"\")\nen","completion":""}
{"prompt":"-- BubbleTree assumes hg19 UCSC style chromosome inputs.\nlocal function _to_ucsc_style(chrom)\n  return 'chr' .. string.gsub(chrom, 'chr', '')\nen","completion":""}
{"prompt":"-- Ensure that an point is hashable by a python dict.\nlocal function _hashable(x)\n    local t = type(x)\n    if t == 'number' then return x end\n    if t == 'boolean' then return x end\n    if t == 'string' then return x end\n    if t == 'table' then return x end\n    if t == 'userdata' then return x end\n    return false\nen","completion":""}
{"prompt":"-- Take a string of 14 or less digits\n-- and turn it into 14 digits for the\n-- sake of comparing entity dates.\nlocal function date_to_canonical(datestring)\n  if datestring and string.len(datestring) <= 14 then\n    return datestring .. string.rep(\"0\", 14 - string.len(datestring))\n  end\n  return datestring\nen","completion":""}
{"prompt":"-- Return the 1st count prime integers.\nlocal function get_primes(count)\n  local primes = {}\n  local i = 2\n  while #primes < count do\n    local is_prime = true\n    for j = 2, math.sqrt(i) do\n      if i % j == 0 then\n        is_prime = false\n        break\n      end\n    end\n    if is_prime then\n      table.insert(primes, i)\n    end\n    i = i + 1\n  end\n  return primes\nen","completion":""}
{"prompt":"-- Group all the records by the given field name. Returns dictionary that for each value of the field contains lists\n-- of corresponding `mdict`-s. **Important**: This operation loads whole dataset into memory, so for big data fields\n-- it is better to use lazy evaluation.\n-- :param datasteam: input datastream\n-- :param field_name: field name to use\n-- :return: dictionary of the form `{ 'value-1' : [ ... ], ...}`\nlocal function dict_group_by(datasteam, field_name)\n   local res = {}\n   for _, v in ipairs(datasteam) do\n      local group_name = v[field_name]\n      if not res[group_name] then\n         res[group_name] = {}\n      end\n      table.insert(res[group_name], v)\n   end\n   return res\nen","completion":""}
{"prompt":"-- The default value generator for\n-- `pandas._testing.makeCustomDataframe`.\n-- Parameter names and descriptions are based on those found in\n-- `pandas._testing.py`.\n-- https:\/\/github.com\/pandas-dev\/pandas\/blob\/b687cd4d9e520666a956a60849568a98dd00c672\/pandas\/_testing.py#L1956\n-- Args:\n-- nrows (int): Number of rows.\n-- ncols (int): Number of columns.\n-- Returns:\n-- str: \"RxCy\" based on the given position.\nlocal function make_dataframe_value(nrows, ncols)\n  local n = 10\n  return string.format(\"R%dC%d\", nrows or n, ncols or n)\nen","completion":""}
{"prompt":"-- Get a column from a dataset\n-- Parameters:\n-- data: Could be a list of list or a list of dict, etc\n-- Given a = [{\"k1\":1, \"k2\":5},{\"k1\":3, \"k2\":5},{\"k1\":2, \"k2\":5}]\n-- get_column(a, \"k1\") will get the values of k1\n-- Returns:\n-- list: of values that belong to the column\nlocal function get_column(data, index)\n    local ret = {}\n    for _, row in ipairs(data) do\n        local v = row[index]\n        if v then table.insert(ret, v) end\n    end\n    return ret\nen","completion":""}
{"prompt":"-- Write a program to find x to power y using recursion\n-- :param base:\n-- :param exp:\n-- :return:\nlocal function power(base, exp)\n  if exp == 0 then\n    return 1\n  end\n  return base * power(base, exp - 1)\nen","completion":""}
{"prompt":"-- Return all digits of N that are not DIGIT, for DIGIT less than 10.\n-- >>> remove2(231, 3) \n-- 21\n-- >>> remove2(240132, 2)\n-- 4013\nlocal function remove2(n, digit)\n  local str = n .. \"\"\n  local result = \"\"\n  for c in str:gmatch(\".\") do\n    if tonumber(c) ~= digit then\n      result = result .. c\n    end\n  end\n  return tonumber(result)\nen","completion":""}
{"prompt":"-- Find the quadrant a pair of coordinates are located in\n-- :type xcoord: integer\n-- :param xcoord: The x coordinate to find the quadrant for\n-- :type ycoord: integer\n-- :param ycoord: The y coordinate to find the quadrant for\nlocal function quadrant(xcoord, ycoord)\n    if (xcoord >= 0 and ycoord >= 0) then\n        return 1\n    elseif (xcoord < 0 and ycoord >= 0) then\n        return 2\n    elseif (xcoord < 0 and ycoord < 0) then\n        return 3\n    elseif (xcoord >= 0 and ycoord < 0) then\n        return 4\n    end\nen","completion":""}
{"prompt":"-- Convert decimal number to binary number by iteration.\n-- Time complexity: O(d\/2).\n-- Space complexity: O(d\/2).\nlocal function decimal_to_base2(dec)\n\tlocal bin = \"\"\n\twhile dec > 0 do\n\t\tbin = (dec % 2) .. bin\n\t\tdec = math.floor(dec \/ 2)\n\tend\n\treturn bin\nen","completion":""}
{"prompt":"-- Finds the number of paths between two points with manhattan distance\n-- n + m. The implementation is recursive and fairly elegant.\nlocal function recursive(n, m)\n    if n == 0 or m == 0 then return 1 end\n    return recursive(n - 1, m) + recursive(n, m - 1)\nen","completion":""}
{"prompt":"-- Convert unifi brightness 1..6 to hass format 0..255.\nlocal function unifi_brightness_to_hass(value)\n  if value < 1 then\n    return 0\n  elseif value > 6 then\n    return 255\n  else\n    return math.floor(value * 255 \/ 6)\n  end\nen","completion":""}
{"prompt":"-- Return the first (leftmost) column of a matrix.\n-- Returns a tuple (immutable).\nlocal function left_column(matrix)\n    local n = #matrix\n    if n == 0 then\n        return {}\n    end\n    local column = {}\n    for i = 1, n do\n        column[i] = matrix[i][1]\n    end\n    return column\nen","completion":""}
{"prompt":"-- Compute number of nodes for the number of workers.\n-- Args:\n-- nworker (int):  The number of workers.\n-- taskproc (int):  The number of processes per task.\n-- nodeprocs (int):  The number of processes per node.\n-- Returns:\n-- (int):  The number of required nodes.\nlocal function compute_nodes(nworker, taskproc, nodeprocs)\n   return math.ceil(nworker * taskproc \/ nodeprocs)\nen","completion":""}
{"prompt":"-- hitung jumlah bit angka 1\n-- >>> get_set_bits(25)\n-- 3\n-- >>> get_set_bits(52132)\n-- 8\n-- >>> get_set_bits(-2)\n-- Traceback (most recent call last):\n-- ...\n-- ValueError: Angka tidak boleh negatif\nlocal function get_set_bits(number)\n    if number < 0 then\n        error(\"Angka tidak boleh negatif\")\n    end\n    local c = 0\n    while number ~= 0 do\n        c = c + number % 2\n        number = math.floor(number \/ 2)\n    end\n    return c\nen","completion":""}
{"prompt":"-- Computes the number of ways of traveling from source to destination.\n-- Args:\n-- m: The total vertical distance.\n-- n: The total horizontal distance.\n-- Returns:\n-- The number of ways ways you can travel to the goal on a grid\n-- with dimensions (m x n).\nlocal function grid_traveler_rec(m, n)\n    if m == 1 and n == 1 then\n        return 1\n    end\n    if m == 0 or n == 0 then\n        return 0\n    end\n    return grid_traveler_rec(m - 1, n) + grid_traveler_rec(m, n - 1)\nen","completion":""}
{"prompt":"-- Parsing command line input minPts into order minPts.\n-- @param minPts: str\nlocal function parseMinpts(minPts, emPair)\n  if emPair then\n    minPts = string.match(minPts, \"^(.+)%s*%-%s*%d+$\")\n  end\n  if minPts then\n    minPts = tonumber(minPts)\n    if minPts == nil then\n      print(\"minPts argument must be a number. Given: \" .. minPts)\n      os.exit()\n    end\n  else\n    print(\"minPts argument missing.\")\n    os.exit()\n  end\n  return minPts\nen","completion":""}
{"prompt":"-- Escape single and double-quotes for JavaScript\nlocal function escape_quotes(text)\n\ttext = text:gsub('[%z\\1-\\127\\194-\\244][\\128-\\191]*', function(c)\n\t\treturn c:byte() < 128 and c:byte() > 31 and c or string.format(\"\\\\u%04x\", c:byte())\n\tend)\n\ttext = text:gsub('\"', '\\\\\"')\n\ttext = text:gsub(\"'\", \"\\\\'\")\n\treturn text\nen","completion":""}
{"prompt":"-- This method takes a string representing a file name and replaces forward slashes with \":\"\n-- This approach is consistent with how other clients deal with attempts to upload files with forward slashes\n-- in the name.\nlocal function replace_forward_slash(file_name)\n    return string.gsub(file_name, \"\/\", \":\")\nen","completion":""}
{"prompt":"-- Converts text to binary string.\n-- >>> text = 'Hello'\n-- >>> binary_text = text2binary(text)\n-- >>> print(binary_text)\n-- '10010001100101110110011011001101111'\nlocal function text2binary(string)\n  local binary_string = ''\n  for c in string:gmatch('.') do\n    local value = string.byte(c)\n    local binary = ''\n    while value > 0 do\n      binary = value % 2 .. binary\n      value = math.floor(value \/ 2)\n    end\n    binary = string.rep('0', 8 - #binary) .. binary\n    binary_string = binary_string .. binary\n  end\n  return binary_string\nen","completion":""}
{"prompt":"-- Returns the number of times 7 appears as a digit of n.\n-- >>> num_sevens(3)\n-- 0\n-- >>> num_sevens(7)\n-- 1\n-- >>> num_sevens(7777777)\n-- 7\n-- >>> num_sevens(2637)\n-- 1\n-- >>> num_sevens(76370)\n-- 2\n-- >>> num_sevens(12345)\n-- 0\n-- >>> from construct_check import check\n-- >>> # ban all assignment statements\n-- >>> check(HW_SOURCE_FILE, 'num_sevens',\n-- ...       ['Assign', 'AugAssign'])\n-- True\nlocal function num_sevens(n)\n    local cnt = 0\n    for digit in tostring(n):gmatch('%d') do\n        if digit == '7' then\n            cnt = cnt + 1\n        end\n    end\n    return cnt\nen","completion":""}
{"prompt":"-- recursive implementation of Josephus problem\n-- num - the number of people standing in the circle\n-- k - the position of the person who is to be killed\n-- return the safe position who will survive the execution\nlocal function josephus(num, k)\n    if num == 1 then return 1 end\n    local r = josephus(num - 1, k)\n    local c = (k == 1) and 1 or k\n    return (c + r - 1) % num + 1\nen","completion":""}
{"prompt":"-- Compute the nth Fibonacci number.\nlocal function simple_fibonacci(n)\n    if n < 2 then\n        return 1\n    else\n        return simple_fibonacci(n-1) + simple_fibonacci(n-2)\n    end\nen","completion":""}
{"prompt":"-- Return `msg` indented by `indentation` number of spaces\nlocal function _GetIndentedString(indentation, msg)\n    indentation = indentation or 0\n    local indent = string.rep(\" \", indentation)\n    return indent .. msg:gsub(\"\\n\", \"\\n\" .. indent)\nen","completion":""}
{"prompt":"-- Parse a variable list of key=value args into a dictionary suitable for kwarg usage\nlocal function parse_interface_params(list)\n  local result = {}\n  if list then\n    for _, arg in ipairs(list) do\n      local split = string.find(arg, \"=\")\n      if split ~= nil then\n        local key = string.sub(arg, 1, split-1)\n        local val = string.sub(arg, split+1)\n        result[key] = val\n      end\n    end\n  end\n  return result\nen","completion":""}
{"prompt":"-- Return shape as tuple of int or Symbol.\n-- This utility function ensures the shape tuple\n-- using a single integer type (to its best effort).\n-- Args:\n-- shape: tuple(int|long|np.int*|Symbol|SymbolExpr...)\nlocal function canonical_shape(shape)\n  assert(type(shape) == \"table\", \"Invalid argument type\")\n  local c_shape = {}\n  for i = 1, #shape do\n    local v = shape[i]\n    local tp = type(v)\n    if tp == \"number\" or tp == \"cdata\" then\n      c_shape[i] = math.floor(v)\n    elseif tp == \"table\" then\n      c_shape[i] = canonical_shape(v)\n    elseif tp == \"nil\" or tp == \"boolean\" then\n      c_shape[i] = 1\n    else\n      error(\"Invalid argument value\")\n    end\n  end\n  return c_shape\nen","completion":""}
{"prompt":"-- Convert XYZ to xy\n-- Args:\n-- XYZ ([float, float, float]: X, Y, Z input values\n-- Returns:\n-- .[float, float]\nlocal function XYZ_to_xy(XYZ)\n\tlocal x = XYZ[1]\n\tlocal y = XYZ[2]\n\tlocal z = XYZ[3]\n\treturn { x \/ (x + y + z), y \/ (x + y + z) }\nen","completion":""}
{"prompt":"-- Parameters\n-- ----------\n-- n input\n-- Returns n!\n-- -------\nlocal function fact(n)\n    return n == 0 and 1 or n * fact(n-1)\nen","completion":""}
{"prompt":"-- Takes the credentials str and converts it to a dict\n-- Parameters\n-- ----------\n-- creds_str : str\n-- credentials string with the below format where the user has inserted their values:\n-- 'host=my_hostname dbname=my_dbname user=my_user password=my_password port=1234'\n-- Returns\n-- -------\n-- dict\n-- credentials in dict form\nlocal function _create_creds_dict(creds_str)\n    local creds = {}\n    for str in creds_str:gmatch(\"[^%s]+\") do\n        local name, value = str:match(\"([^=]+)=(.*)\")\n        creds[name] = value\n    end\n    return creds\nen","completion":""}
{"prompt":"-- Backward compatibility - field was int and now str.\n-- Property: HealthCheck.Interval\n-- Property: HealthCheck.Timeout\nlocal function validate_int_to_str(x)\n\tif x == nil then\n\t\treturn nil\n\telseif type(x) == \"number\" then\n\t\treturn tostring(x)\n\telse\n\t\treturn x\n\tend\nen","completion":""}
{"prompt":"-- Serialize a sequence of Bokeh objects into JSON\n-- Args:\n-- objs (seq[obj]) : a sequence of Bokeh object to dump\n-- docid (str) : an ID for a Bokeh Document to dump relative to\n-- changed_only (bool, optional) : whether to dump only attributes\n-- that have had their values changed at some point (default: True)\n-- Returns:\n-- list[json]\nlocal function dump(objs, docid, changed_only)\n    if not objs then return nil end\n    changed_only = true\n    local jsons = {}\n    for i, obj in ipairs(objs) do\n        if not obj._id then obj._id = uuid() end\n        if obj._id:startswith(docid) then\n            local json = _dump(obj, changed_only)\n            if json then\n                jsons[#jsons+1] = json\n            end\n        else\n            error(string.format(\"unexpected docid '%s' for object at index %d\", obj._id, i))\n        end\n    end\n    return jsons\nen","completion":""}
{"prompt":"-- Forms the 3 dimentional vector cross product of sequences a and b\n-- a is crossed onto b\n-- cartesian coordinates\n-- returns a 3 tuple\nlocal function CrossProduct3D(a, b)\n    return {a[2] * b[3] - a[3] * b[2],\n            a[3] * b[1] - a[1] * b[3],\n            a[1] * b[2] - a[2] * b[1]}\nen","completion":""}
{"prompt":"-- Remove separators, if there are any, to go from e.g. 123-456-7890 to 1234567890.\nlocal function remove_separators(nhs_number)\n  if nhs_number then\n    return nhs_number:gsub('[^%d]', '')\n  end\nen","completion":""}
{"prompt":"-- remove data before t_start and after t_end\n-- Arguments:\n-- data {list} -- the list to remove some data from\n-- t_start {int} -- the time value to remove all data before\n-- t_end {int} -- the time value to remove all data after\nlocal function afterAndBeforeArray(data, t_start, t_end)\n  local filtered = {}\n  for k,v in ipairs(data) do\n    if v[1] >= t_start and v[1] <= t_end then\n      table.insert(filtered, v)\n    end\n  end\n  return filtered\nen","completion":""}
{"prompt":"-- Compute size of a padding field.\n-- >>> paddingSize(31, 4)\n-- 1\n-- >>> paddingSize(32, 4)\n-- 0\n-- >>> paddingSize(33, 4)\n-- 3\n-- Note: (value + paddingSize(value, align)) == alignValue(value, align)\nlocal function paddingSize(value, align)\n\tif value % align == 0 then\n\t\treturn 0\n\telse\n\t\treturn align - (value % align)\n\tend\nen","completion":""}
{"prompt":"-- !\n-- @brief Calculates Heaviside function that represents step function.\n-- @details If input value is greater than 0 then returns 1, otherwise returns 0.\n-- @param[in] value (double): Argument of Heaviside function.\n-- @return (double) Value of Heaviside function.\nlocal function heaviside(value)\n  if value > 0 then\n    return 1\n  else\n    return 0\n  end\nen","completion":""}
{"prompt":"-- Convert ip4 address from integer into string representation.\n-- Parameters\n-- ----------\n-- ip_int : int\n-- 4-byte ip4 integer representation\n-- Returns\n-- -------\n-- string\n-- ip4 string representation\nlocal function int_ip_to_string(ip_int)\n  local octet_1, octet_2, octet_3, octet_4 = ip_int % 256, math.floor(ip_int \/ 256) % 256, math.floor(ip_int \/ 65536) % 256, math.floor(ip_int \/ 16777216) % 256\n  return string.format(\"%d.%d.%d.%d\", octet_1, octet_2, octet_3, octet_4)\nen","completion":""}
{"prompt":"-- right pad the given string with spaces to the given length\nlocal function right_pad(str, width)\n    local pad_len = width - #str\n    if pad_len <= 0 then\n        return str\n    end\n    return str .. string.rep(\" \", pad_len)\nen","completion":""}
{"prompt":"-- Returns the nth octagonal number.\nlocal function octagonalNum(n)\n  return n*(3*n-2)\nen","completion":""}
{"prompt":"-- Determine depth of scope at a character index.\n-- Return 0 if not inside any scope.\n-- Note that braces found inside comments or literals are not ignored and will be counted.\n-- Note that a scope does not have to be properly balanced for this to return its depth.\n-- For example, in the string 'a { b { c', the index of 'c' would have a depth of 2.\nlocal function depth(index, text)\n\tlocal depth = 0\n\tlocal literal = false\n\tfor i = 1, index do\n\t\tlocal character = text:sub(i, i)\n\t\tif character == '{' then\n\t\t\tdepth = depth + 1\n\t\telseif character == '}' then\n\t\t\tdepth = depth - 1\n\t\telseif character == '\"' then\n\t\t\tif i > 1 and text:sub(i - 1, i - 1) ~= '\\\\' then\n\t\t\t\tliteral = not literal\n\t\t\tend\n\t\telseif character == \"'\" then\n\t\t\tif i > 1 and text:sub(i - 1, i - 1) ~= '\\\\' then\n\t\t\t\tliteral = not literal\n\t\t\tend\n\t\telseif character == '\/' then\n\t\t\tif i > 1 and text:sub(i - 1, i - 1) == '\/' then\n\t\t\t\tliteral = true\n\t\t\telseif i > 1 and text:sub(i - 1, i - 1) == '*' then\n\t\t\t\tliteral = not literal\n\t\t\tend\n\t\tend\n\tend\n\treturn depth\nen","completion":""}
{"prompt":"-- Reverse normalization\n-- Args:\n-- data (np.array): Normalized data\n-- data_max (float): max value before normalization\n-- data_min (float): min value before normalization\n-- Returns:\n-- [np.array]: Reverse-Normalized data\nlocal function descale(data, data_max, data_min)\n    return data * (data_max - data_min) + data_min\nen","completion":""}
{"prompt":"-- Jinja2 map filter to wrap list items in a string on both sides.\n-- E.g.: ['a', 'b', 'c'] -> ['\"a\"', '\"b\"', '\"c\"']\nlocal function wrap(value, wrapper)\n  local wrapper = wrapper or '\"'\n  return wrapper .. tostring(value) .. wrapper\nen","completion":""}
{"prompt":"-- >>> get_dir_without_last_slash('abc\/src01_hrc01.yuv')\n-- 'abc'\n-- >>> get_dir_without_last_slash('src01_hrc01.yuv')\n-- ''\n-- >>> get_dir_without_last_slash('abc\/xyz\/src01_hrc01.yuv')\n-- 'abc\/xyz'\n-- >>> get_dir_without_last_slash('abc\/xyz\/')\n-- 'abc\/xyz'\nlocal function get_dir_without_last_slash(path)\n  local last_slash = path:find('\/[^\/]*$')\n  if last_slash ~= nil then\n    return path:sub(1, last_slash - 1)\n  else\n    return ''\n  end\nen","completion":""}
{"prompt":"-- Converts digital number array to radiance\nlocal function dn2rad(data, gain, bias)\n  return (data * gain) + bias\nen","completion":""}
{"prompt":"-- Return the partition of the nodes at the given level\n-- A dendrogram is a tree and each level is a partition of the graph nodes.\n-- Level 0 is the first partition, which contains the smallest communities,\n-- and the best is len(dendrogram) - 1.\n-- The higher the level is, the bigger are the communities\n-- Parameters\n-- ----------\n-- dendrogram : list of dict\n-- a list of partitions, ie dictionaries where keys of the i+1 are the\n-- values of the i.\n-- level : int\n-- the level which belongs to [0..len(dendrogram)-1]\n-- Returns\n-- -------\n-- partition : dictionary\n-- A dictionary where keys are the nodes and the values are the set it\n-- belongs to\n-- Raises\n-- ------\n-- KeyError\n-- If the dendrogram is not well formed or the level is too high\n-- See Also\n-- --------\n-- best_partition : which directly combines partition_at_level and\n-- generate_dendrogram : to obtain the partition of highest modularity\n-- Examples\n-- --------\n-- >>> G=nx.erdos_renyi_graph(100, 0.01)\n-- >>> dendrogram = generate_dendrogram(G)\n-- >>> for level in range(len(dendrogram) - 1) :\n-- >>>     print(\"partition at level\", level, \"is\", partition_at_level(dendrogram, level))  # NOQA\nlocal function partition_at_level(dendrogram, level)\n    if level >= 0 and level <= #dendrogram then\n        local partition = {}\n        local c = dendrogram[level + 1]\n        for k, v in pairs(c) do\n            partition[k] = v\n        end\n        return partition\n    end\n    error(\"level out of bound\")\nen","completion":""}
{"prompt":"-- Method to sanitize data input\n-- :params: user_data\n-- Check if it is alphanumeric\n-- :response: True, False\nlocal function sanitize_input(input_data)\n\t-- Sanitize data input\n\tif not input_data or not input_data.input_data then\n\t\treturn false, \"Invalid input\"\n\tend\n\tlocal input_data_table = input_data.input_data\n\tif type(input_data_table) ~= \"table\" then\n\t\treturn false, \"Invalid input\"\n\tend\n\tlocal input_data_type = input_data.input_data_type\n\tif not input_data_type or type(input_data_type) ~= \"string\" then\n\t\treturn false, \"Invalid input\"\n\tend\n\tif input_data_type ~= \"alphanumeric\" then\n\t\treturn false, \"Invalid input\"\n\tend\n\tfor i, v in pairs(input_data_table) do\n\t\tif type(v) ~= \"string\" then\n\t\t\treturn false, \"Invalid input\"\n\t\tend\n\tend\n\treturn true, nil\nen","completion":""}
{"prompt":"-- Clean an input string (to prevent SQL injection).\n-- Parameters\n-- ----------\n-- input_string : str\n-- Returns\n-- -------\n-- str\nlocal function scrub(input_string)\n    local scrubbed = input_string\n    scrubbed = scrubbed:gsub(\"%W\", \"\")\n    return scrubbed\nen","completion":""}
{"prompt":"-- splits args based on '=' delim\n-- :return:\nlocal function my_split(p)\n\tlocal arg = {}\n\tfor i,v in ipairs(arg) do\n\t\targ[i] = v:match(p)\n\tend\n\treturn arg\nen","completion":""}
{"prompt":"-- 4-parameter logistic model\n-- y = D + (A - D) \/ (1 + ((x \/ C)**B))\n-- A is min\n-- B is Hill coef\n-- C is inflection\n-- D is max\nlocal function logistic4(x, A, B, C, D)\n\tlocal c = (x \/ C)\n\treturn D + ((A - D) \/ (1 + (c^B)))\nen","completion":""}
{"prompt":"-- Funcion que retorna el conjugado de un numero imaginario\n-- (list 1D) -> list 1D\nlocal function conjugado(num)\n\treturn {num[1], -num[2]}\nen","completion":""}
{"prompt":"-- This function calculates the square of the argument value\nlocal function square(root)\n  return root * root\nen","completion":""}
{"prompt":"-- Args: q, eta: scalar\n-- alpha, s_hat: 1d numpy array\n-- Return: 1d numpy array\nlocal function update_alpha_hat(alpha, q, eta, s_hat)\n  return alpha - eta * q * s_hat\nen","completion":""}
{"prompt":"-- convert https:\/\/blog.scrapinghub.com\/page\/6\/ into blog.scrapinghub.com\/page\/6\/\n-- :param url:\n-- :return:\nlocal function get_urn(url)\n  return string.gsub(url, \"^https?:\/\/\", \"\")\nen","completion":""}
{"prompt":"-- dB to linear values (for np.array or single number)\nlocal function z2lin(array)\n\tif type(array) == \"table\" then\n\t\treturn array.new(array:size()):apply(function(i,v)\n\t\t\treturn z2lin(array[i])\n\t\tend)\n\telse\n\t\treturn 10^(array\/10)\n\tend\nen","completion":""}
{"prompt":"-- Returns a sorted edge.\n-- During the construction of a line graph for undirected graphs, the data\n-- structure can be a multigraph even though the line graph will never have\n-- multiple edges between its nodes.  For this reason, we must make sure not\n-- to add any edge more than once.  This requires that we build up a list of\n-- edges to add and then remove all duplicates.  And so, we must normalize\n-- the representation of the edges.\nlocal function _sorted_edge(u, v)\n  if u > v then\n    return {v, u}\n  else\n    return {u, v}\n  end\nen","completion":""}
{"prompt":"-- Helper to quote a value if it's a string.\nlocal function _quote_if_str(val)\n  if type(val) == \"string\" then return \"'\" .. val .. \"'\" end\n  return val\nen","completion":""}
{"prompt":"-- This function calcualted the adjusted R-squared value from the ordinary\n-- R-squared value reported from sklearn\nlocal function adjusted_r2(ord_r2, sample_size, n_of_feat)\n    return 1 - (1 - ord_r2) * (sample_size - 1) \/ (sample_size - n_of_feat - 1)\nen","completion":""}
{"prompt":"-- Escape HTML special characters ``&<>`` and quotes ``'\"``.\nlocal function html_escape(s)\n    s = string.gsub(s, \"&\", \"&amp;\")\n    s = string.gsub(s, \"<\", \"&lt;\")\n    s = string.gsub(s, \">\", \"&gt;\")\n    s = string.gsub(s, \"\\\"\", \"&quot;\")\n    s = string.gsub(s, \"'\", \"&#039;\")\n    return s\nen","completion":""}
{"prompt":"-- Helper func that strips single and double quotes from inside strings\nlocal function _unquote(s)\n  return s:gsub('\"', \"\"):gsub(\"'\", \"\")\nen","completion":""}
{"prompt":"-- Function counts num of vowels in string.\nlocal function getcount(inputstr)\n    local count = 0\n    for i = 1, #inputstr do\n        if (inputstr:sub(i, i) == \"a\" or inputstr:sub(i, i) == \"e\" or inputstr:sub(i, i) == \"i\" or inputstr:sub(i, i) == \"o\" or inputstr:sub(i, i) == \"u\") then\n            count = count + 1\n        end\n    end\n    return count\nen","completion":""}
{"prompt":"-- Parse asyncpg record response into JSON format\nlocal function jsonify(records)\n    local json = {}\n    for _, record in ipairs(records) do\n        local json_record = {}\n        for k, v in pairs(record) do\n            json_record[k] = v\n        end\n        table.insert(json, json_record)\n    end\n    return json\nen","completion":""}
{"prompt":"-- Return the number of the variable of cell i, j and digit d,\n-- which is an integer in the range of 1 to 729 (including).\nlocal function v(i, j, d)\n    return (i - 1) * 9 * 9 + (j - 1) * 9 + d\nen","completion":""}
{"prompt":"-- Calculate quarter (1 indexed) from month (1 indexed).\n-- >>> [quarter_from_month(month) for month in range(1, 13)]\n-- [1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4]\nlocal function quarter_from_month(month)\n    assert(type(month) == \"number\", \"month must be a number\")\n    if month < 1 or month > 12 then\n        error(\"month must be a number between 1 and 12 (inclusive)\")\n    end\n    return math.ceil(month \/ 3)\nen","completion":""}
{"prompt":"-- Parametric rectified linear unit function...\n-- Args:\n-- z (np.array)\n-- Returns:\n-- f(z) = z if z > 0 else alpha * z (np.array)\nlocal function PReLU(z, alpha)\n\tlocal f = z\n\tif z < 0 then\n\t\tf = alpha * z\n\tend\n\treturn f\nen","completion":""}
{"prompt":"-- Parse a string to extract a simple list of string values.\n-- Assumes comma separated values optionally within []\nlocal function parse_list(value)\n    if string.match(value, '^%[.-%]$') then\n        value = string.sub(value, 2, -2)\n    end\n    local result = {}\n    for word in string.gmatch(value, '([^, ]+)') do\n        table.insert(result, word)\n    end\n    return result\nen","completion":""}
{"prompt":"-- normalise alpha in range (0, 1)\n-- :param float alpha:\n-- :return float:\n-- >>> norm_aplha(0.5)\n-- 0.5\n-- >>> norm_aplha(255)\n-- 1.0\n-- >>> norm_aplha(-1)\n-- 0\nlocal function norm_aplha(alpha)\n  return math.max(0.0, math.min(1.0, alpha))\nen","completion":""}
{"prompt":"-- Convert a list of dictionaries into a dictionary of dictionaries.\n-- key_subfieldname must exist in each Record's subfields and have a value,\n-- which will be used as the key for the new dictionary. If a key is duplicated,\n-- the earlier value will be overwritten.\nlocal function dicts_to_dict(dictionaries, key_subfieldname)\n  local result = {}\n  for _, d in ipairs(dictionaries) do\n    result[d[key_subfieldname]] = d\n  end\n  return result\nen","completion":""}
{"prompt":"-- Remove boldface formatting from text.\nlocal function plain(text)\n    return text:gsub('%%(%b())', '%%%1')\nen","completion":""}
{"prompt":"-- Returns 1 if x is positive, 0 if x is 0, and -1 otherwise\nlocal function sign(x)\n  if x > 0 then\n    return 1\n  elseif x < 0 then\n    return -1\n  end\n  return 0\nen","completion":""}
{"prompt":"-- Sort the letters of a word\nlocal function wsorted(ws)\n    -- Get the characters from the word, sorted in order\n    local sorted_cs = {}\n    for c in string.gmatch(ws, \".\") do\n        table.insert(sorted_cs, c)\n    end\n    table.sort(sorted_cs)\n    -- Construct the word from the sorted characters\n    local sorted_ws = \"\"\n    for _, c in ipairs(sorted_cs) do\n        sorted_ws = sorted_ws .. c\n    end\n    return sorted_ws\nen","completion":""}
{"prompt":"-- _compute_qset_filters translates the keys of req_params to the keys of translation_dict.\n-- If the key isn't present in filters_dict, it is discarded.\nlocal function _compute_qset_filters(req_params, translation_dict)\n  local filters = {}\n  for k, v in pairs(req_params) do\n    local filter_key = translation_dict[k]\n    if filter_key then\n      filters[filter_key] = v\n    end\n  end\n  return filters\nen","completion":""}
{"prompt":"-- The sum of numbers from 1 to number\n-- :param number: Input parameter\n-- :return: sum of numbers\nlocal function sum_to_n(number)\n    -- Create a variable to hold the sum\n    local sum = 0\n    -- Iterate over all numbers\n    for i = 1, number do\n        -- Add the numbers together\n        sum = sum + i\n    end\n    -- Return the sum\n    return sum\nen","completion":""}
{"prompt":"-- combine a list of lists into a single list\nlocal function combineLists(lsts)\n  local result = {}\n  for i, lst in ipairs(lsts) do\n    for j, v in ipairs(lst) do\n      table.insert(result, v)\n    end\n  end\n  return result\nen","completion":""}
{"prompt":"-- converts a given string to spongebob case (alternating caps)\n-- Args:\n-- string: the string to convert\n-- Returns:\n-- new string in sarcastic case\nlocal function to_spongebob_case(string)\n    local s = \"\"\n    for i=1,string.len(string) do\n        if (i % 2 == 0) then\n            s = s .. string.upper(string.sub(string,i,i))\n        else\n            s = s .. string.lower(string.sub(string,i,i))\n        end\n    end\n    return s\nen","completion":""}
{"prompt":"-- Returns an appropriate width for a wxChoice widget based upon the list \n-- of values it contains:\nlocal function choice_width(values)\n   local width = 1\n   for _, val in ipairs(values) do\n      width = math.max(width, string.len(tostring(val)))\n   end\n   width = width * 6\n   return width\nen","completion":""}
{"prompt":"-- >>> fuel_required(12)\n-- 2\n-- >>> fuel_required(14)\n-- 2\n-- >>> fuel_required(1969)\n-- 654\n-- >>> fuel_required(100756)\n-- 33583\nlocal function fuel_required(mass)\n    return math.floor(mass \/ 3) - 2\nen","completion":""}
{"prompt":"-- Parses a volume specification string SOURCE:TARGET:MODE into\n-- its components, or raises click.BadOptionUsage if not according\n-- to format.\nlocal function parse_volume_string(volume_string)\n  local source, target, mode = volume_string:match('^([^:]+):([^:]+):(.+)$')\n  if source and target and mode then\n    return { source, target, mode }\n  else\n    raise('BadOptionUsage', \"Bad volume string '\".. volume_string ..\"': \" ..\n                             \"must be SOURCE:TARGET:MODE\")\n  end\nen","completion":""}
{"prompt":"-- Number to Excel-style column name, e.g., 1 = A, 26 = Z, 27 = AA, 703 = AAA.\nlocal function excel_column_name(n)\n  n = n - 1\n  local s = \"\"\n  while n >= 0 do\n    local d = (n % 26) + 1\n    n = math.floor((n - d) \/ 26)\n    s = string.char(d + 64) .. s\n  end\n  return s\nen","completion":""}
{"prompt":"-- Convert 12-hour clock format to 24-hour clock format.\n-- :param hour: the current hour.\n-- :param period: the current time period. `AM` or `PM`.\n-- Other values raise an `Exception`.\nlocal function twelve_to_24_clock(hour, period)\n  if period == 'AM' then\n    if hour == 12 then\n      return 0\n    else\n      return hour\n    end\n  elseif period == 'PM' then\n    if hour == 12 then\n      return 12\n    else\n      return hour + 12\n    end\n  else\n    raise('Unsupported period')\n  end\nen","completion":""}
{"prompt":"-- Return the index of the first non-numeric character in s, -1 if all\n-- characters are numeric.\nlocal function get_first_nonnumeric(s)\n  for i=1,string.len(s) do\n    local c = string.byte(s, i)\n    if not (c >= 48 and c <= 57) then\n      return i - 1\n    end\n  end\n  return -1\nen","completion":""}
{"prompt":"-- Convert Fahrenheit to Celsius.\nlocal function convert_f_to_c(temperature_f)\n    return (temperature_f - 32) * (5\/9)\nen","completion":""}
{"prompt":"-- Remove quote from string\nlocal function strip_quotes(quoted_string)\n    return quoted_string:gsub(\"^['\\\"]\", \"\"):gsub(\"['\\\"]$\", \"\")\nen","completion":""}
{"prompt":"-- Returns x if positive, 0 otherwise.\nlocal function relu_activation(x)\n    if x < 0 then return 0\n    else return x end\nen","completion":""}
{"prompt":"-- Mean (mass-weighted) metallicity as a function of redshift\n-- From Madau & Fragos 2017, courtesy of Mike Zevin\n-- Parameters\n-- ----------\n-- z : `float or numpy.array`\n-- redshift\n-- Returns\n-- -------\n-- Z : `float or numpy.array`\n-- mean metallicity\nlocal function mean_metal_z(z)\n    local x = 1. + z\n    local alpha = 0.3044\n    local beta = 0.4336\n    local gamma = 0.0286\n    local delta = 0.126\n    local Z = alpha\/x + beta + gamma*x + delta*x^2\n    return Z\nen","completion":""}
{"prompt":"-- generate a nested dictionary of the input files organized by sample and barcode\n-- in the format: dict[sample][barcodeGroup][dataType]=fileName\nlocal function inFileDict(inFileList)\n    local dict = {}\n    for _,inFile in ipairs(inFileList) do\n        local sample,barcodeGroup,dataType = inFile:match(\"(.-)_([^_%.]+)_([^_%.]+)\")\n        sample = sample or \"unknown\"\n        barcodeGroup = barcodeGroup or \"unknown\"\n        dataType = dataType or \"unknown\"\n        if not dict[sample] then dict[sample] = {} end\n        if not dict[sample][barcodeGroup] then dict[sample][barcodeGroup] = {} end\n        dict[sample][barcodeGroup][dataType] = inFile\n    end\n    return dict\nen","completion":""}
{"prompt":"-- Implementation of the djb2 hash, a simple hash function with a\n-- configurable table size.\n-- ** Do NOT use for cryptography! **\nlocal function djb2_hash(text, size)\n    size = size or 32768\n    local h = 5381\n    local l = #text\n    for i = 1, l do\n        h = ((h * 33) + string.byte(text, i)) % size\n    end\n    return h\nen","completion":""}
{"prompt":"-- Get CSS classes for player.\n-- For each page, there is a reference player (p2, associated to the\n-- secret in the URL).  Information for that player should be styled\n-- with 'self_player'.  All other players get 'other_player'.\n-- If cp is defined, it indicates which p1 should get the\n-- 'current_player' class extra.\nlocal function player_css_class(p1, p2, cp)\n   local cl = {}\n   if p2 == p1 then\n      table.insert(cl, 'self_player')\n   else\n      table.insert(cl, 'other_player')\n   end\n   if cp and cp == p1 then\n      table.insert(cl, 'current_player')\n   end\n   return table.concat(cl, ' ')\nen","completion":""}
{"prompt":"-- Shifts the number by 12, if it is less than 0.\n-- Parameters\n-- ----------\n-- number : int\n-- Returns\n-- -------\n-- int\nlocal function _shift_twelve(number)\n\tif number < 0 then\n\t\tnumber = number + 12\n\tend\n\treturn number\nen","completion":""}
{"prompt":"-- Compute sea level pressure (hPa) from barometric pressure (hPa) and altitude (m).\nlocal function compute_sea_level_pressure(barometric_pressure, altitude)\n    return barometric_pressure * math.exp(-altitude \/ 44.363)\nen","completion":""}
{"prompt":"-- assumes x an int >= 0\n-- Returns Fibonacci of x\nlocal function fib(x)\n  if x < 2 then return 1 end\n  return fib(x - 1) + fib(x - 2)\nen","completion":""}
{"prompt":"-- Kronecker delta function\nlocal function delta(a, b)\n    return a == b and 1 or 0\nen","completion":""}
{"prompt":"-- stantard f1 for binary classification\n-- recall:\n-- precision:\nlocal function f1(recall, precision)\n    return 2*recall*precision\/(recall+precision)\nen","completion":""}
{"prompt":"-- Return first 5 digits of fips code to get county. Accepts 12 digit FIPS.\n-- :param fips: 12 digits fips code, must be string.\n-- :return: int - 5 digit fips code\nlocal function fips2county(fips)\n\treturn string.sub(fips, 1, 5)\nen","completion":""}
{"prompt":"-- Calculate the detection rate.\n-- :param tn: Number of true negatives.\n-- :param fp: Number of false positives.\n-- :return: The detection rate.\nlocal function false_positive_rate(tn, fp)\n  if (tn + fp) == 0 then\n    return 0\n  end\n  return fp \/ (fp + tn)\nen","completion":""}
{"prompt":"-- Returns a list, regardless of the value is str or list\nlocal function _list_from_list_or_value(value)\n    if type(value) == \"table\" then\n        return value\n    elseif value then\n        return {value}\n    else\n        return {}\n    end\nen","completion":""}
{"prompt":"-- convert a Decimal number to Roman numeral recursively\n-- Args:\n-- num: The decimal number.\n-- s: The roman numerial string.\n-- decs: Current list of decimal denomination.\n-- romans: Current list of roman denomination.\n-- Returns:\n-- Roman numeral equivalent of num, as string.\nlocal function _dec_to_roman(num, s, decs, romans)\n    if num == 0 then\n        return s\n    end\n    local new = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n    for i,v in ipairs(decs) do\n        new[i] = math.floor(num \/ v)\n        num = num - new[i] * v\n    end\n    for i,v in ipairs(romans) do\n        s = s .. string.rep(v, new[i])\n    end\n    return _dec_to_roman(num, s, decs, romans)\nen","completion":""}
{"prompt":"-- Reverses ZigZag encoding\nlocal function zigZagToNumber(z)\n  return (z % 2) == 0 and z \/ 2 or (-z - 1) \/ 2\nen","completion":""}
{"prompt":"-- Convert the given HASS light level (0-255) to Vantage (0.0-100.0).\nlocal function to_vantage_level(level)\n  return (level \/ 255) * 100\nen","completion":""}
{"prompt":"-- Return (red, green, blue) for the color given as #rrggbb.\nlocal function hex_to_rgb(value)\n  if value == nil then return {1, 1, 1} end\n  local r = tonumber(value:sub(2,3), 16) \/ 255\n  local g = tonumber(value:sub(4,5), 16) \/ 255\n  local b = tonumber(value:sub(6,7), 16) \/ 255\n  return {r, g, b}\nen","completion":""}
{"prompt":"-- Args:\n-- argv (list): List of arguments\n-- Returns:\n-- int: A return code\n-- Does stuff.\nlocal function main(argv)\n    return 0\nen","completion":""}
{"prompt":"-- Returns a list of the relevant attributes present\n-- among the variables.\nlocal function attributes_present(variables, attr_map)\n  local attr_present = {}\n  for k, v in pairs(variables) do\n    local attr = attr_map[k]\n    if attr then\n      if not attr_present[attr] then\n        attr_present[attr] = true\n      end\n    end\n  end\n  return attr_present\nen","completion":""}
{"prompt":"-- Change a C code line to a comment by adding the prefix \"\/\/ \"\n-- If the last character of the line is a backslash, certain\n-- characters are appended. This silences some compiler warnings.\nlocal function line_as_comment(line)\n\tif line == \"\" then return line end\n\tlocal l = line\n\tlocal len = #l\n\tif l:sub(len) == \"\\\\\" then\n\t\t-- This is a line that would normally end with a backslash,\n\t\t-- but the last character is a backslash.\n\t\t-- Append one of the characters that silences a certain compiler\n\t\t-- warning.\n\t\tif l:match('^\/\/%s*error') then\n\t\t\tl = \"\/\/ error\"\n\t\telseif l:match('^\/\/%s*warning') then\n\t\t\tl = \"\/\/ warning\"\n\t\telseif l:match('^\/\/%s*unknown') then\n\t\t\tl = \"\/\/ unknown\"\n\t\tend\n\tend\n\tl = \"\/\/ \" .. l\n\treturn l\nen","completion":""}
{"prompt":"-- Return the base name of a key name.\n-- a.b.c.1 -> a.b.c\n-- a.b.c -> a.b\nlocal function _basename(key)\n\treturn key:match(\"^(.*)%..-$\") or key\nen","completion":""}
{"prompt":"-- formats number of files in olympus format\n-- :param num_files:\n-- :return: list of file numbers\nlocal function get_file_list(num_files)\n\tlocal file_list = {}\n\tfor i=1,num_files do\n\t\tfile_list[i] = string.format(\"%04d\",i)\n\tend\n\treturn file_list\nen","completion":""}
{"prompt":"-- Computes difference between two vectors\nlocal function vector_diff(a, b)\n    local result = {}\n    for i, v in ipairs(a) do\n        result[i] = v - b[i]\n    end\n    return result\nen","completion":""}
{"prompt":"-- Given an opening xml tag, return the matching close tag\n-- eg. '<YAMAHA_AV cmd=\"PUT\"> becomes <\/YAMAHA_AV>\nlocal function _open_to_close_tag(tag)\n\tif tag == \"<YAMAHA_AV cmd=\\\"PUT\\\">\" then\n\t\treturn \"<\/YAMAHA_AV>\"\n\telseif tag == \"<YAMAHA_AV cmd=\\\"GET\\\">\" then\n\t\treturn \"<\/YAMAHA_AV>\"\n\telseif tag == \"<YAMAHA_AV cmd=\\\"GET_STATUS\\\">\" then\n\t\treturn \"<\/YAMAHA_AV>\"\n\telseif tag == \"<YAMAHA_AV cmd=\\\"GET_CONFIG\\\">\" then\n\t\treturn \"<\/YAMAHA_AV>\"\n\telseif tag == \"<YAMAHA_AV cmd=\\\"GET_MENU\\\">\" then\n\t\treturn \"<\/YAMAHA_AV>\"\n\telse\n\t\treturn \"<\/YAMAHA_AV>\"\n\tend\nen","completion":""}
{"prompt":"-- Max number of nodes in the lowest layer of a tree of given height.\nlocal function layer(height)\n\treturn 1<<(height-1)\nen","completion":""}
{"prompt":"-- Utility function that requires a given input to be an integer greater zero.\n-- In case the given input is not an integer or zero or negative, the user is requested to provide a valid input.\n-- :param raw_input: the initial user input\n-- :type raw_input: str\n-- :return: a number greater zero the user inserted\n-- :rtype: int\nlocal function input_require_int(raw_input)\n  local input_number = tonumber(raw_input)\n  if (type(input_number) ~= \"number\" or input_number < 0) then\n    return input_require_int(\"Enter an integer greater zero: \")\n  end\n  return math.floor(input_number)\nen","completion":""}
{"prompt":"-- Sums up edge weights. This results in edge weights that are\n-- dominated by dominant figures.\nlocal function sum_edge_weight(acc, w1, w2)\n\treturn acc + w1 + w2\nen","completion":""}
{"prompt":"-- This function takes a list of arrays and returns them (or a section of them),\n-- either untouched, or transposed, according to the parameter.\n-- Parameters\n-- ----------\n-- args : sequence of arrays\n-- The input arrays.\n-- transpose : bool\n-- If True, return transposed versions.\n-- section : slice object\n-- Section of output data to return.\n-- Returns\n-- -------\n-- list of arrays\n-- The input arrays, or their transposed versions.\nlocal function _transpose_if_needed()\n  -- FIXME: Implement\n  return {}\nen","completion":""}
{"prompt":"-- Convert a numerical index to a char.\nlocal function index_to_letter(idx)\n\treturn string.char(idx + 97)\nen","completion":""}
{"prompt":"-- Returns the leading whitespace of 's'.\nlocal function get_leading_ws(s)\n  return string.match(s, '^[ \\t]*')\nen","completion":""}
{"prompt":"-- n: an int\n-- a: the power of each digits\n-- output: sum of each digits of n with power of a\nlocal function sumOfDigPow(n, a)\n  local sum = 0\n  while n > 0 do\n    local d = n % 10\n    n = n \/\/ 10\n    local p = d^a\n    if p > 9 then\n      if not sumOfDigPow(p, a-1) then\n        return\n      end\n    else\n      sum = sum + p\n    end\n  end\n  return sum\nen","completion":""}
{"prompt":"-- Ensure that the target t has the given suffix.\nlocal function __ensure_suffix(t, suffix)\n  if not string.find(t, suffix) then\n    t = t .. suffix\n  end\n  return t\nen","completion":""}
{"prompt":"-- Convert single-channeled colors or (R, G, B) tuples to #RRGGBB.\n-- If the color has only one channel (grayscale, typically), it is converted\n-- to a (R, G, B) tuple first.\n-- Parameters\n-- ----------\n-- color : int or list\n-- Grayscale value or list of red, green, blue pixel values\n-- Returns\n-- -------\n-- str\n-- HTML-version of color\nlocal function GetHTMLColor(color)\n\tif type(color) == \"table\" then\n\t\treturn string.format(\"#%02x%02x%02x\", color[1], color[2], color[3])\n\telseif type(color) == \"number\" then\n\t\treturn string.format(\"#%02x%02x%02x\", color, color, color)\n\tend\nen","completion":""}
{"prompt":"-- Return the aparc+aseg.mgz file\nlocal function get_aparc_aseg(files)\n\tfor _, file in ipairs(files) do\n\t\tif file:find(\"aparc%+aseg%.mgz\") then\n\t\t\treturn file\n\t\tend\n\tend\n\treturn nil\nen","completion":""}
{"prompt":"-- remove extra whitespaces from text\nlocal function remove_whitespace(text)\n  if text == nil then\n    return nil\n  end\n  return (text:gsub(\"%s+\", \" \")):gsub(\"^%s*(.-)%s*$\", \"%1\")\nen","completion":""}
{"prompt":"-- Create list of chunk slices [(s_i, e_i), ...]\n-- Parameters\n-- ----------\n-- ds_len : int\n-- Length of dataset axis to chunk\n-- chunk_size : int\n-- Size of chunks\n-- Returns\n-- -------\n-- chunks : list\n-- List of chunk start and end positions\n-- [(s_i, e_i), (s_i+1, e_i+1), ...]\nlocal function get_chunk_ranges(ds_dim, chunk_size)\n  local chunks = {}\n  local chunk_start = 0\n  while chunk_start < ds_dim do\n    local chunk_end = math.min(chunk_start + chunk_size, ds_dim)\n    chunks[#chunks + 1] = {chunk_start, chunk_end}\n    chunk_start = chunk_end\n  end\n  return chunks\nen","completion":""}
{"prompt":"-- Merge metadata from two different sources.\n-- :param list base_metadata: A (possibly undefined) set of metadata.\n-- :param list more_metadata: Metadata to add (also possibly undefined).\nlocal function _merge_metadata(base_metadata, more_metadata)\n    -- If we don't have a base, return the other set (or an empty table)\n    if not base_metadata then\n        return more_metadata or {}\n    end\n    -- If we don't have the other, return the base\n    if not more_metadata then\n        return base_metadata\n    end\n    -- Otherwise, we have to merge them\n    local ret_metadata = {}\n    -- Add the base data first, to overwrite any overwrites\n    for k,v in pairs(base_metadata) do\n        ret_metadata[k] = v\n    end\n    -- Now we add the more_metadata over the top\n    for k,v in pairs(more_metadata) do\n        ret_metadata[k] = v\n    end\n    return ret_metadata\nen","completion":""}
{"prompt":"-- split corpus into a list of sentences.\nlocal function corpus2sentences(corpus)\n  local lines = {}\n  for line in corpus:gmatch('[^\\r\\n]+') do\n    if #line > 0 then\n      table.insert(lines, line)\n    end\n  end\n  return lines\nen","completion":""}
{"prompt":"-- unique identifier lookup function\n-- Args:\n-- otype: str, int\n-- Returns: if is int then return string; otherwise, if the type is string return int\nlocal function uniqueIdentifierTypes_e(otype)\n\tif otype == nil then\n\t\treturn 0\n\telse\n\t\totype = string.lower(tostring(otype))\n\t\tif otype == \"int\" then\n\t\t\treturn 1\n\t\telseif otype == \"str\" then\n\t\t\treturn 2\n\t\tend\n\tend\n\treturn 0\nen","completion":""}
{"prompt":"-- Defines a flat prior between -6 and 6 in all dimensions.\nlocal function prior_transform(x)\n  return -6 + 12 * x\nen","completion":""}
{"prompt":"-- Takes in two dictionaries. For every item name for a key in the first,\n-- if it is in mappings, update it.\n-- Returns: dict from key to new cat_id\nlocal function filter_against_known_mappings(transaction_keys_no_cat, mappings)\n\tlocal new_cat_id_dict = {}\n\tfor key, value in pairs(transaction_keys_no_cat) do\n\t\tif mappings[value] ~= nil then\n\t\t\tnew_cat_id_dict[key] = mappings[value]\n\t\tend\n\tend\n\treturn new_cat_id_dict\nen","completion":""}
{"prompt":"-- Dot product between two points\n-- Args:\n-- p1 ([float, float]): x and y coordinates\n-- p2 ([float, float]): x and y coordinates\n-- Returns:\n-- float\nlocal function dot(p1, p2, debug)\n\tif (debug) then\n\t\tprint('dot: '..p1[1]..', '..p1[2]..' and '..p2[1]..', '..p2[2])\n\tend\n\treturn (p1[1] * p2[1]) + (p1[2] * p2[2])\nen","completion":""}
{"prompt":"-- Compute the first n prime numbers.\n-- Parameters\n-- ----------\n-- n : int\n-- Number of prime numbers to compute.\n-- Returns\n-- -------\n-- primes : list of int\n-- The first n prime numbers.\n-- Examples\n-- --------\n-- >>> first_n_primes(4)\n-- [1, 2, 3, 5]\n-- >>> first_n_primes(10)\n-- [1, 2, 3, 5, 7, 11, 13, 17, 19, 23]\nlocal function first_n_primes(n)\n    local is_prime = function (n)\n        for i = 2, math.sqrt(n) do\n            if n % i == 0 then\n                return false\n            end\n        end\n        return true\n    end\n    local primes = {}\n    local i = 1\n    while #primes < n do\n        local n = i\n        local is_prime = is_prime(n)\n        if is_prime then\n            table.insert(primes, n)\n        end\n        i = i + 1\n    end\n    return primes\nen","completion":""}
{"prompt":"-- Descobre largura do kernel (width)\n-- Args:\n-- kernel: kernel que se deseja-se descobrir largura\n-- Returns:\n-- largura do kernel\nlocal function find_kernel_width(kernel)\n    return #kernel[1]\nen","completion":""}
{"prompt":"-- Given a position (x,y) returns the position to the right of the original position, defined as (x+1,y)\nlocal function get_position_right(original_position)\n\tlocal x = original_position[1] + 1\n\tlocal y = original_position[2]\n\treturn {x,y}\nen","completion":""}
{"prompt":"-- Clamp the value x to be within x0, x1 (inclusive).\nlocal function clamp(x, x0, x1)\n  return math.max(x0, math.min(x1, x))\nen","completion":""}
{"prompt":"-- Returns the winner of the game, if there is one.\nlocal function winner(board)\n    local won = false\n    for row = 1, 3 do\n        if board[row][1] ~= \"\" and board[row][1] == board[row][2] and board[row][2] == board[row][3] then\n            return board[row][1]\n        end\n    end\n    for col = 1, 3 do\n        if board[1][col] ~= \"\" and board[1][col] == board[2][col] and board[2][col] == board[3][col] then\n            return board[1][col]\n        end\n    end\n    if board[1][1] ~= \"\" and board[1][1] == board[2][2] and board[2][2] == board[3][3] then\n        return board[1][1]\n    end\n    if board[1][3] ~= \"\" and board[1][3] == board[2][2] and board[2][2] == board[3][1] then\n        return board[1][3]\n    end\n    return \"\"\nen","completion":""}
{"prompt":"-- map a value between a given min and max\nlocal function map_value(value, left_min, left_max, right_min, right_max)\n  return right_min + (right_max - right_min) * (value - left_min) \/ (left_max - left_min)\nen","completion":""}
{"prompt":"-- Returns the number of times 7 appears as a digit of n.\n-- >>> num_sevens(3)\n-- 0\n-- >>> num_sevens(7)\n-- 1\n-- >>> num_sevens(7777777)\n-- 7\n-- >>> num_sevens(2637)\n-- 1\n-- >>> num_sevens(76370)\n-- 2\n-- >>> num_sevens(12345)\n-- 0\n-- >>> from construct_check import check\n-- >>> check(HW_SOURCE_FILE, 'num_sevens',\n-- ...       ['Assign', 'AugAssign'])\n-- True\nlocal function num_sevens(n)\n    local counter = 0\n    while n > 0 do\n        if n % 10 == 7 then\n            counter = counter + 1\n        end\n        n = n \/\/ 10\n    end\n    return counter\nen","completion":""}
{"prompt":"-- Apply limits to an input value.\n-- Parameters\n-- ----------\n-- input_value : float\n-- Input value.\n-- low_limit : float\n-- Low limit. If value falls below this limit it will be set to this value.\n-- high_limit : float\n-- High limit. If value falls above this limit it will be set to this value.\n-- Returns\n-- -------\n-- float\n-- Returns input value unless it falls above or below the entered limits.\nlocal function limit_vals(input_value, low_limit, high_limit)\n  if input_value < low_limit then\n    input_value = low_limit\n  elseif input_value > high_limit then\n    input_value = high_limit\n  end\n  return input_value\nen","completion":""}
{"prompt":"-- Lerp - Linearly interpolates between 'a'\n-- when 'scalar' is 0 and 'b' when 'scalar' is 1.\n-- a = number or Vector\n-- b = number or Vector\n-- scaler = number between 0 and 1\nlocal function lerp(a, b, scalar)\n    if type(a) == \"number\" then\n        return (b-a) * scalar + a\n    end\n    if type(a) == \"table\" then\n        local c = {}\n        for i = 1, #a do\n            c[i] = (b[i]-a[i]) * scalar + a[i]\n        end\n        return c\n    end\nen","completion":""}
{"prompt":"-- Rounds off the decimal of a value if it is an integer float.\nlocal function round_if_int(val)\n    if type(val) == \"number\" then\n        if val % 1 == 0 then\n            return val\n        end\n    end\n    return val\nen","completion":""}
{"prompt":"-- Convert CV2 Image to ByteIO Stream\n-- Parameters::\n-- (CV2 Image): img -- OpenCV Image\n-- (String) : format -- image format (Default JPEG)\n-- Returns:\n-- ByteIO Steam\nlocal function match_singles(boxes, matches, singles)\n\tif boxes == nil then\n\t\tboxes = {}\n\tend\n\tif matches == nil then\n\t\tmatches = {}\n\tend\n\tif singles == nil then\n\t\tsingles = {}\n\tend\n\tfor k, v in ipairs(singles) do\n\t\ttable.insert(boxes, v)\n\t\ttable.insert(matches, {v[1]})\n\tend\n\treturn boxes, matches\nen","completion":""}
{"prompt":"-- Return a list with arg as its member or arg if arg is already a list.\n-- Returns an empty list if arg is None\nlocal function make_list(arg)\n  return type(arg) == \"table\" and arg or {arg}\nen","completion":""}
{"prompt":"-- Return 10^n: 10^n > num; 10^(n-1) <= num.\nlocal function nifty_power_of_ten(num)\n\tlocal e = 1\n\twhile num >= 10^e do\n\t\te = e + 1\n\tend\n\treturn 10^e\nen","completion":""}
{"prompt":"-- Returns the number of UTF-8 encoded bytes in the specified string.\n-- https:\/\/docs.mongodb.com\/manual\/reference\/operator\/aggregation\/strLenBytes\/\n-- for more details\n-- :param expression: The string or expression of the string\n-- :return: Aggregation operator\nlocal function STR_LEN_BYTES(expression)\n  return { [\"$strLenBytes\"] = expression }\nen","completion":""}
{"prompt":"-- Output a list of stage names if multiple stages are being used, or a single stage name if only one.\nlocal function process_stage_names(context, processed_stage_name)\n    if processed_stage_name == nil then\n        return \"default\"\n    elseif type(processed_stage_name) == \"table\" then\n        -- Handle multiple stages if needed.\n        local stage_names = {}\n        for _, stage in pairs(processed_stage_name) do\n            table.insert(stage_names, process_stage_names(context, stage))\n        end\n        return stage_names\n    elseif type(processed_stage_name) == \"function\" then\n        -- Handle a function that will generate the stage name if needed.\n        return processed_stage_name(context)\n    else\n        -- Handle a string if it is set.\n        return processed_stage_name\n    end\nen","completion":""}
{"prompt":"-- >>> listpack(1)\n-- [1]\n-- >>> listpack((1, 2))\n-- [1, 2]\n-- >>> listpack([1, 2])\n-- [1, 2]\nlocal function listpack(x)\n    if x == nil then\n        return {}\n    elseif type(x) == \"table\" then\n        return x\n    else\n        return {x}\n    end\nen","completion":""}
{"prompt":"-- Calculate the GC skew of a nucleotide sequence.\n-- s = (G - C) \/ (G + C)\nlocal function gc_skew(dna)\n  local g = dna:gsub(\"C\", \"\"):len()\n  local c = dna:gsub(\"G\", \"\"):len()\n  return (g - c) \/ (g + c)\nen","completion":""}
{"prompt":"-- Short hand for splitting a cleaned source and returning the domaen\n-- ie. en.wikipedia.org\nlocal function get_domain(link)\n  local host = link:gsub('^https?:\/\/', ''):gsub('^\/\/', ''):match('^([^\/]+)')\n  return host\nen","completion":""}
{"prompt":"-- Huber loss function, refer to wiki https:\/\/en.wikipedia.org\/wiki\/Huber_loss\nlocal function huber_loss(r, delta)\n    return math.abs(r) < delta and 0.5 * r^2 or delta * (math.abs(r) - 0.5 * delta)\nen","completion":""}
{"prompt":"-- Create initial JSON for PDAL pipeline\nlocal function _json_base()\n    local json = {}\n    json.pipeline = {}\n    return json\nen","completion":""}
{"prompt":"-- Removes a trailing slash from a non-root path.\n-- Arguments:\n-- path: The path of a request.\n-- Returns:\n-- The route to use to serve the request.\nlocal function _clean_path(path)\n  if path == \"\/\" or path == \"\" then\n    return path\n  end\n  local len = string.len(path)\n  if string.sub(path, len, len) == \"\/\" then\n    return string.sub(path, 1, len - 1)\n  end\n  return path\nen","completion":""}
{"prompt":"-- Obtain the Monte methods of a class.\n-- The class must have already been harvested.\n-- NOT_RPYTHON\nlocal function harvestMethods(cls)\n   if not cls then\n      return {}\n   end\n   local d = rawget(cls, \"__dict__\")\n   if not d then\n      return {}\n   end\n   local m = {}\n   local meta = rawget(cls, \"__metatable__\")\n   if meta then\n      local meta_m = rawget(meta, \"__dict__\")\n      if meta_m then\n         for k, v in pairs(meta_m) do\n            if type(v) == \"function\" then\n               m[k] = v\n            end\n         end\n      end\n   end\n   for k, v in pairs(d) do\n      if type(v) == \"function\" then\n         m[k] = v\n      end\n   end\n   return m\nen","completion":""}
{"prompt":"-- Returns the recording button text given the recording flag\nlocal function get_recording_button_text(recording_flag)\n  if recording_flag then\n    return 'Stop Recording'\n  else\n    return 'Start Recording'\n  end\nen","completion":""}
{"prompt":"-- drops first n items from each row and returns new tabular data\n-- >>> drop_columns([[1, 2, 3],\n-- [21, 22, 23],\n-- [31, 32, 33]],\n-- 1)\n-- [[2, 3], [22, 23], [32, 33]]\nlocal function drop_columns(tabular, n)\n  for i, row in ipairs(tabular) do\n    for j = 1, n do\n      table.remove(row, 1)\n    end\n  end\n  return tabular\nen","completion":""}
{"prompt":"-- Same as \"mocker\", but kept only for backward compatibility.\nlocal function mock(mocker)\n    return mocker\nen","completion":""}
{"prompt":"-- Get labels from json file\n-- :param lj: labels JSON\n-- :type lj: JSON\n-- :returns: list of label names\n-- :rtype: list\nlocal function get_current_labels(lj)\n    local labels = {}\n    for i,v in ipairs(lj) do\n        table.insert(labels, v.name)\n    end\n    return labels\nen","completion":""}
{"prompt":"-- Get a valid scale from an image and a metadata path or scale.\n-- Parameters\n-- ----------\n-- image : np.ndarray\n-- The input image.\n-- md_path_or_scale : float or image filename\n-- The path to the file containing the metadata, or the scale.\n-- Returns\n-- -------\n-- scale : float\nlocal function _get_scale(image, md_path_or_scale)\n   -- try to parse md_path_or_scale as a number\n   local scale = tonumber(md_path_or_scale)\n   if scale then\n      -- this is the scale case\n      return scale\n   end\n   -- this is the metadata file case\n   if not md_path_or_scale then\n      md_path_or_scale = ''\n   end\n   -- we need to compute the scale from the image and the metadata\n   local md = _read_json_file(md_path_or_scale)\n   if not md then\n      return nil, 'Could not read metadata.'\n   end\n   local image_width = image:shape(1)\n   if not image_width then\n      return nil, 'Could not read image width.'\n   end\n   local image_height = image:shape(2)\n   if not image_height then\n      return nil, 'Could not read image height.'\n   end\n   local scale_x = md.width\/image_width\n   local scale_y = md.height\/image_height\n   local scale = math.min(scale_x, scale_y)\n   return scale\nen","completion":""}
{"prompt":"-- Computing the nth of Fib series\n-- Implemetation focusing on 1 time running of fib.\nlocal function fib(n)\n\tif n == 0 then return 0\n\telseif n == 1 then return 1\n\telse return fib(n-1) + fib(n-2) end\nen","completion":""}
{"prompt":"-- Convert degrees Celsius to degrees Fahrenheit\nlocal function to_fahrenheit(celsius)\n\treturn celsius * 9 \/ 5 + 32\nen","completion":""}
{"prompt":"-- Removes all messages containing sub-strings listed in cullStrings. cullStrings can be either a string or a\n-- list of strings. If as list of strings, each string must be a sub-string in a message for the message to\n-- be culled.\nlocal function checkCulling(errs, cullStrings)\n    if type(cullStrings) == \"string\" then\n        cullStrings = {cullStrings}\n    end\n    local culled = {}\n    for i, err in ipairs(errs) do\n        local msg = err.message or err.msg\n        if msg then\n            for _, cullStr in ipairs(cullStrings) do\n                if msg:find(cullStr) then\n                    culled[i] = true\n                    break\n                end\n            end\n        end\n    end\n    local newErrs = {}\n    for i, err in ipairs(errs) do\n        if not culled[i] then\n            table.insert(newErrs, err)\n        end\n    end\n    return newErrs\nen","completion":""}
{"prompt":"-- Returns the 0-based index of given row name.\n-- Parameters\n-- ----------\n-- row : int or unicode\n-- Row name.\n-- Returns\n-- -------\n-- int\n-- 0-based row index.\n-- Examples\n-- --------\n-- >>> row_to_index('1')\n-- 0\nlocal function row_to_index(row)\n    return (tonumber(row) or row_name_to_index[row]) - 1\nen","completion":""}
{"prompt":"-- Calculate the combination :math:`C_{n}^{m}`,\n-- .. math::\n-- C_{n}^{m} = \\frac{n!}{m!(n-m)!}.\n-- Parameters\n-- ----------\n-- n : int\n-- Number n.\n-- m : int\n-- Number m.\n-- Returns\n-- -------\n-- res : int\n-- The calculated result.\n-- Examples\n-- --------\n-- >>> combination(6, 2)\n-- 15\nlocal function combination(n, m)\n    if n < m then\n        return 0\n    end\n    if m == 0 then\n        return 1\n    end\n    local res = 1\n    for i = 1, m do\n        res = res * (n - i + 1) \/ i\n    end\n    return math.floor(res + 0.5)\nen","completion":""}
{"prompt":"-- Real Attenuation\n-- :param float original_extract: Original degrees Plato\n-- :param float real_extract: Real degrees Plato of finished beer\n-- :return: The percent of real attenuation\n-- :rtype: float\nlocal function real_attenuation(original_extract, real_extract)\n    return (original_extract - real_extract) \/ original_extract\nen","completion":""}
{"prompt":"-- Maj(x, y, z) = (x AND y) XOR (x AND z) XOR (y AND Z)\nlocal function majority(x, y, z)\n\treturn (x & y) ~ (x & z) ~ (y & z)\nen","completion":""}
{"prompt":"-- fast exponentiation x^k % MOD\nlocal function powmod(x, k, MOD)\n    local ans = 1\n    while k > 0 do\n        if k % 2 == 1 then\n            ans = (ans * x) % MOD\n        end\n        x = (x * x) % MOD\n        k = k \/\/ 2\n    end\n    return ans\nen","completion":""}
{"prompt":"-- Returns the nth fibonacci number\n-- Time complexity: O(2^n)\n-- Parameters\n-- ----------\n-- n : int\n-- the nth fibonacci position\n-- Returns\n-- -------\n-- int\n-- the nth fibonacci number\n-- -------\n-- >>> recursive_fibonacci(0)\n-- 0\n-- >>> recursive_fibonacci(1)\n-- 1\n-- >>> recursive_fibonacci(3)\n-- 2\nlocal function recursive_fibonacci(n)\n    if n <= 1 then return n end\n    return recursive_fibonacci(n - 1) + recursive_fibonacci(n - 2)\nen","completion":""}
{"prompt":"-- Converts a grayscale pixel to a black or white pixel.\n-- Done by using T=150 as the value to decide between B & W\n-- pixel > 150 = White || pixel < 150 = Black\n-- Parameters\n-- ----------\n-- pixel(color) : The pixel as color(R,G,B)\n-- Returns\n-- -------\n-- tuple : (R, G, B)\nlocal function pixelTobitpixel(pixel)\n  return (pixel[1] > 150) and {255, 255, 255} or {0, 0, 0}\nen","completion":""}
{"prompt":"-- Results is a list of tuples: (match_list1, 'filename1.py', longest_line_in_match)\nlocal function determine_longest_matched_line(results)\n  local longest_line = 0\n  for _, result in pairs(results) do\n    if result[1] and result[2] and result[3] then\n      if result[3] > longest_line then\n        longest_line = result[3]\n      end\n    end\n  end\n  return longest_line\nen","completion":""}
{"prompt":"-- Find factors of num, in increasing order.\n-- >>> find_factors(10)\n-- [1, 2, 5, 10]\n-- >>> find_factors(11)\n-- [1, 11]\n-- >>> find_factors(111)\n-- [1, 3, 37, 111]\n-- >>> find_factors(321421)\n-- [1, 293, 1097, 321421]\nlocal function find_factors(num)\n  local factors = {}\n  for i = 1, num do\n    if num % i == 0 then\n      table.insert(factors, i)\n    end\n  end\n  table.sort(factors)\n  return factors\nen","completion":""}
{"prompt":"-- Calculate the fibonacci number at position n recursively\n-- :param n: position number\n-- :return: position n of Fibonacci series\nlocal function get_fibonacci_recursive(n)\n  if n < 1 then\n    return 0\n  elseif n == 1 then\n    return 1\n  end\n  return get_fibonacci_recursive(n-1) + get_fibonacci_recursive(n-2)\nen","completion":""}
{"prompt":"-- Cross product of two vectors\nlocal function cross(p1, p2)\n  return {\n    p1[2] * p2[3] - p1[3] * p2[2],\n    p1[3] * p2[1] - p1[1] * p2[3],\n    p1[1] * p2[2] - p1[2] * p2[1]\n  }\nen","completion":""}
{"prompt":"-- Returns the 1 dimensional array index for the given x\/y coordinate and\n-- map width.\nlocal function coord_to_1d_index(x, y, width)\n\treturn x + y * width\nen","completion":""}
{"prompt":"-- Scales a vector by factor f.\n-- v (3-tuple): 3d vector\n-- f (float): scale factor\n-- return (3-tuple): 3d vector\nlocal function vect3_scale(v, f)\n  return { v[1] * f, v[2] * f, v[3] * f }\nen","completion":""}
{"prompt":"-- Return a list of nonempty proper prefixes of \n-- the given word (sorted in increasing length).\nlocal function proper_prefixes(word)\n    local words = {}\n    for i = 1, #word - 1 do\n        words[#words+1] = word:sub(1, i)\n    end\n    return words\nen","completion":""}
{"prompt":"-- Return the factorial of the given number.\nlocal function fact(n)\n  if n == 0 or n == 1 then return 1 end\n  return n * fact(n-1)\nen","completion":""}
{"prompt":"-- asks for the users date of birth and checks if it is a master or not.\n-- If not convert the input to digits and return the sum of the digits.\nlocal function day(dayin)\n  local dayin = dayin or os.date(\"%d\")\n  local dayin_as_number = tonumber(dayin)\n  if dayin_as_number == nil then\n    -- this is a master\n    local digits = {}\n    for index, digit in ipairs(dayin) do\n      digits[index] = string.byte(digit)\n    end\n    local sum = 0\n    for index, digit in ipairs(digits) do\n      sum = sum + digit\n    end\n    return sum\n  else\n    -- this is a slave\n    return dayin_as_number\n  end\nen","completion":""}
{"prompt":"-- Return the prefix of s that is whitespace.\nlocal function _indent_of(s)\n    return s:match('^([ \\t]*)')\nen","completion":""}
{"prompt":"-- BIG-O Notation = O(n)\nlocal function sum_numbers_loop(n)\n\tlocal sum = 0\n\tfor i = 1,n do\n\t\tsum = sum + i\n\tend\n\treturn sum\nen","completion":""}
{"prompt":"-- :param v: The vector we want to scale\n-- :param num: Scale amount\n-- :return: vector scaled by num\nlocal function scale(v, num)\n    local nv = {}\n    for i = 1, #v do\n        nv[i] = v[i] * num\n    end\n    return nv\nen","completion":""}
{"prompt":"-- Given two integers a and b,\n-- which can be positive or negative,\n-- find the sum of all the numbers\n-- between including them too and return it.\n-- If the two numbers are equal return a or b.\n-- :param a:\n-- :param b:\n-- :return:\nlocal function get_sum(a, b)\n    if a == b then\n        return a\n    end\n    if a > b then\n        a, b = b, a\n    end\n    return a + get_sum(a + 1, b)\nen","completion":""}
{"prompt":"-- Helper to convert integers (representing cents) into decimal currency\n-- string. WARNING: DO NOT TRY TO DO THIS BY DIVISION, FLOATING POINT\n-- ERRORS ARE NO FUN IN FINANCIAL SYSTEMS.\n-- @param integer The amount in cents\n-- @return string The amount in currency with full stop decimal separator\nlocal function int_to_decimal_str(integer)\n    return string.format(\"%.2f\", integer \/ 100)\nen","completion":""}
{"prompt":"-- Generic formatter\nlocal function frmt(tmpl, version, data)\n    data = data or {}\n    data.version = version\n    return string.gsub(tmpl, \"{(.-)}\", data)\nen","completion":""}
{"prompt":"-- Gets the English plural ending for an ordinal number.\nlocal function plural(num)\n\treturn num == 1 and \"\" or \"s\"\nen","completion":""}
{"prompt":"-- calcule la distance de Manhattan entre le tuple \n-- p1 et le tuple p2\nlocal function distManhattan(p1, p2)\n    local sum = 0\n    for i=1, #p1 do\n        sum = sum + math.abs(p1[i] - p2[i])\n    end\n    return sum\nen","completion":""}
{"prompt":"-- fib(number) -> number\n-- fib takes a number as an Argurment and returns the fibonacci value of that number\n-- >>> fib(8) -> 21\n-- >>> fib(6) -> 8\n-- >>> fib(0) -> 1\nlocal function fib(n)\n    return n <= 2 and 1 or fib(n - 1) + fib(n - 2)\nen","completion":""}
{"prompt":"-- Evaluate a cubic hermite curve at interpolation parameter u in [0,1].\n-- Endpoints are m0 and m1, with derivatives t0 and t1.  These are assumed to be Numpy arrays.\n-- Alternatively, if `domain` != None, then this will use domain=(a,b)\n-- as the interpolation domain\nlocal function hermite(m0, m1, t0, t1, u, domain)\n  local t = u\n  if domain then\n    local a,b = domain[1], domain[2]\n    t = (b-a) * u + a\n  end\n  local u2 = u * u\n  local u3 = u2 * u\n  return m0*(2*u3 - 3*u2 + 1) + m1*(-2*u3 + 3*u2) + t0*(u3 - 2*u2 + u) + t1*(u3 - u2)\nen","completion":""}
{"prompt":"-- Update probability using Bayes' rule.\nlocal function update_probability(prior, prob_true, prob_false)\n   return (prior * prob_true) \/ (prior * prob_true + (1-prior) * prob_false)\nen","completion":""}
{"prompt":"-- Finds the Manhattan distance of a point from the goal point\nlocal function Manhattan_dist(curr_point, goal)\n\tlocal dist = math.abs(goal[1]-curr_point[1]) + math.abs(goal[2]-curr_point[2])\n\treturn dist\nen","completion":""}
{"prompt":"-- Converts a (r,g,b) tuple into #ffffff HTML color code for GUI\nlocal function RGBToHTMLColor(rgb_tuple)\n  return string.format(\"#%02x%02x%02x\", rgb_tuple[1], rgb_tuple[2], rgb_tuple[3])\nen","completion":""}
{"prompt":"-- Merges two sorted lists.\n-- >>> merge([1, 3, 5], [2, 4, 6])\n-- [1, 2, 3, 4, 5, 6]\n-- >>> merge([], [2, 4, 6])\n-- [2, 4, 6]\n-- >>> merge([1, 2, 3], [])\n-- [1, 2, 3]\n-- >>> merge([5, 7], [2, 4, 6])\n-- [2, 4, 5, 6, 7]\nlocal function merge(lst1, lst2)\n  local merged_list = {}\n  local i, j = 1, 1\n  while i <= #lst1 and j <= #lst2 do\n    if lst1[i] < lst2[j] then\n      merged_list[i + j - 1] = lst1[i]\n      i = i + 1\n    else\n      merged_list[i + j - 1] = lst2[j]\n      j = j + 1\n    end\n  end\n  while i <= #lst1 do\n    merged_list[i + j - 1] = lst1[i]\n    i = i + 1\n  end\n  while j <= #lst2 do\n    merged_list[i + j - 1] = lst2[j]\n    j = j + 1\n  end\n  return merged_list\nen","completion":""}
{"prompt":"-- cleans text string by removing (date), - company\nlocal function clean(text)\n\tif text == nil then\n\t\treturn nil\n\tend\n\ttext = string.gsub(text, \"%(%d+%-%d+%-%d+%)\", \"\")\n\ttext = string.gsub(text, \"%-%-.*\", \"\")\n\treturn text\nen","completion":""}
{"prompt":"-- precondition: n >= 0\nlocal function fib(n)\n  if n == 0 then\n    return 1\n  elseif n == 1 then\n    return 1\n  end\n  return fib(n - 1) + fib(n - 2)\nen","completion":""}
{"prompt":"-- format word according to n\nlocal function _count(n, word)\n\t-- one, two, few, many, other\n\tif n == 1 then\n\t\treturn string.format(\"%s %s\", n, word)\n\telseif n >= 2 and n <= 4 then\n\t\treturn string.format(\"%s %ss\", n, word)\n\telse\n\t\treturn string.format(\"%s %ss\", n, word)\n\tend\nen","completion":""}
{"prompt":"-- converts time in seconds to HH:MM:SS\n-- Args:\n-- duration_in_sec (float): duration in seconds\n-- Returns:\n-- (str): the time in the format: HH:MM:SS\nlocal function convert_sec_to_time(duration_in_sec)\n  local hours = math.floor(duration_in_sec \/ 3600)\n  local mins = math.floor(duration_in_sec \/ 60 - (hours * 60))\n  local secs = math.floor(duration_in_sec - (hours * 3600) - (mins * 60))\n  if hours < 10 then hours = \"0\" .. hours end\n  if mins < 10 then mins = \"0\" .. mins end\n  if secs < 10 then secs = \"0\" .. secs end\n  local time_str = hours .. \":\" .. mins .. \":\" .. secs\n  return time_str\nen","completion":""}
{"prompt":"-- >>> lcase(\"Cat\")\n-- 'cat'\nlocal function lcase(i)\n    return i:lower()\nen","completion":""}
{"prompt":"-- Helper function to extract features\n-- from dictionary. If it doesn't find\n-- it, raise a value error with a more\n-- informative error message.\nlocal function get_features(geojson)\n\tif not geojson then return nil end\n\tlocal features = geojson.features\n\tif not features then return nil end\n\treturn features\nen","completion":""}
{"prompt":"-- Return appropriate `lagrange` parameter.\nlocal function get_lagrange(atom, lagrange)\n\t-- If `lagrange` is a number, then return the number.\n\tif lagrange == nil then\n\t\treturn 1\n\tend\n\tif type(lagrange) == \"number\" then\n\t\treturn lagrange\n\tend\n\t-- If `lagrange` is a string, then return the value of the\n\t-- attribute.\n\tif type(lagrange) == \"string\" then\n\t\tlocal value = atom:get_attribute(lagrange)\n\t\tif value then\n\t\t\treturn tonumber(value)\n\t\tend\n\t\t-- If no value is found for the attribute, then return\n\t\t-- `1`.\n\t\treturn 1\n\tend\n\t-- If `lagrange` is a function, then return the value of the\n\t-- function for `atom`.\n\tif type(lagrange) == \"function\" then\n\t\treturn lagrange(atom)\n\tend\n\t-- If `lagrange` is an instance of `Class`, then return the\n\t-- value of the attribute.\n\tif lagrange.get_attribute then\n\t\tlocal value = lagrange:get_attribute(atom)\n\t\tif value then\n\t\t\treturn tonumber(value)\n\t\tend\n\tend\n\t-- If no value is found for the attribute, then return `1`.\n\treturn 1\nen","completion":""}
{"prompt":"-- Convert the temperature from Celcius to Farenheit scale.\n-- :param float temp: The temperature in degrees Celcius.\n-- :returns: The temperature in degrees Farenheit.\n-- :rtype: float\nlocal function convert_celcius_to_farenheit(temp)\n    return temp * 9 \/ 5 + 32\nen","completion":""}
{"prompt":"-- :type x: int\n-- :rtype: int\nlocal function reverse(x)\n    local sign = 1\n    if x < 0 then\n        sign = -1\n    end\n    x = sign * x\n    local reverse = 0\n    while x ~= 0 do\n        local mod = x % 10\n        reverse = reverse * 10 + mod\n        x = (x - mod) \/ 10\n    end\n    return sign * reverse\nen","completion":""}
{"prompt":"-- Return the n_th Fibonnaci number $F_n$.  The Fibonacci sequence\n-- starts 0, 1, 1, 2, 3, 5, 8, ..., and is defined as\n-- $F_n = F_{n-1} + F_{n-2}.$\n-- >>> fibonacci(0)\n-- 0\n-- >>> fibonacci(5)\n-- 5\n-- >>> fibonacci(10)\n-- 55\nlocal function fibonacci(n)\n  if n == 0 then\n    return 0\n  elseif n == 1 then\n    return 1\n  else\n    return fibonacci(n-1) + fibonacci(n-2)\n  end\nen","completion":""}
{"prompt":"-- Ensures that object is a list.\nlocal function ensure_list(x)\n  if x == nil then\n    return {}\n  elseif type(x) ~= 'table' then\n    return {x}\n  elseif getmetatable(x) ~= list_mt then\n    return {x}\n  else\n    return x\n  end\nen","completion":""}
{"prompt":"-- Returns True if number is narcissistic\nlocal function narcissistic(number)\n    local temp = tostring(number)\n    local result = 0\n    local len = string.len(temp)\n    for i = 1, len, 1 do\n        result = result + tonumber(string.sub(temp, i, i)) ^ len\n    end\n    return number == result\nen","completion":""}
{"prompt":"-- Return the number of days in any month and year\nlocal function days_per_month(month, year)\n    local days = 31\n    if month == 2 then\n        days = 28\n        if year % 4 == 0 then\n            days = 29\n        end\n    elseif month == 4 or month == 6 or month == 9 or month == 11 then\n        days = 30\n    end\n    return days\nen","completion":""}
{"prompt":"-- Decode a RGB565 uint16 into a RGB888 tuple.\nlocal function decode_rgb565(val)\n    return {\n        (val >> 11) * 255 \/ 31,\n        ((val >> 5) & 0x3F) * 255 \/ 63,\n        (val & 0x1F) * 255 \/ 31,\n    }\nen","completion":""}
{"prompt":"-- Remove all duplicate monomials in the feedback functions FF.\nlocal function sort_function(FF)\n\tlocal function _sort(FF, ord, ord_inv)\n\t\t-- check for any duplicate monomials\n\t\tfor i, m in ipairs(FF) do\n\t\t\tif m.vars then\n\t\t\t\tlocal pos = ord_inv[m.vars]\n\t\t\t\tif pos and i ~= pos then\n\t\t\t\t\t-- insert into sorted position\n\t\t\t\t\ttable.insert(FF, pos, m)\n\t\t\t\t\ttable.remove(FF, i)\n\t\t\t\t\treturn _sort(FF, ord, ord_inv)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\treturn FF\n\tend\n\t-- Create a sorted monomial ordering.\n\tlocal ord = {}\n\tlocal ord_inv = {}\n\tfor i = 1, #FF do\n\t\tlocal m = FF[i]\n\t\tif m.vars then\n\t\t\tlocal vars = m.vars\n\t\t\tif not ord_inv[vars] then\n\t\t\t\tord[#ord + 1] = vars\n\t\t\t\tord_inv[vars] = i\n\t\t\tend\n\t\tend\n\tend\n\t-- Sort the monomials.\n\ttable.sort(ord, function(a, b)\n\t\treturn #a > #b\n\tend)\n\treturn _sort(FF, ord, ord_inv)\nen","completion":""}
{"prompt":"-- Gently asks the user to Try Again\nlocal function _tryAgain()\n    print(\"Error, please try again.\")\n    os.exit()\nen","completion":""}
{"prompt":"-- ``div(a,b)`` is like ``a \/\/ b`` if ``b`` devides ``a``, otherwise\n-- an `ValueError` is raised.\n-- >>> div(10,2)\n-- 5\n-- >>> div(10,3)\n-- Traceback (most recent call last):\n-- ...\n-- ValueError: 3 does not divide 10\nlocal function div(a, b)\n  if a % b == 0 then\n    return a \/\/ b\n  else\n    error(\"invalid value\")\n  end\nen","completion":""}
{"prompt":"-- Account for invalid encoding. SIGH.\nlocal function clean_b_headerline(text)\n  local newtext = text:gsub('([^\\n\\r\\t])\\n','%1\\r\\n')\n  return newtext\nen","completion":""}
{"prompt":"-- Replace NONE by an empty string\n-- :param s: original string which may be NONE\n-- :return: a stripped string, empty if NONE\nlocal function replace_none(s)\n\treturn (s or \"\"):gsub(\"^%s*(.-)%s*$\", \"%1\")\nen","completion":""}
{"prompt":"-- Python stupidly named some OPCODES with a + which prevents using opcode name\n-- directly as an attribute, e.g. SLICE+3. So we turn that into SLICE_3 so we\n-- can then use opcode_23.SLICE_3.  Later Python's fix this.\nlocal function fix_opcode_names(opmap)\n    local fixmap = {}\n    for k, v in pairs(opmap) do\n        local vname = k\n        if k:match('+') then\n            vname = k:gsub('+', '_')\n        end\n        fixmap[vname] = v\n    end\n    return fixmap\nen","completion":""}
{"prompt":"-- Convert labels from {0, 1} to {-1, 1}\nlocal function _convert_labels_for_svm(y)\n  return y * 2 - 1\nen","completion":""}
{"prompt":"-- Given a tuple of r, g, b, return the hex value\nlocal function rgb2hex(pix)\n\treturn string.format(\"#%02x%02x%02x\", pix[1], pix[2], pix[3])\nen","completion":""}
{"prompt":"-- Escape a string for use in Gerrit commands.\n-- :arg str string: The string to escape.\n-- :returns: The string with necessary escapes and surrounding double quotes\n-- so that it can be passed to any of the Gerrit commands that require\n-- double-quoted strings.\nlocal function escape_string(string)\n  string = string:gsub(\"\\\\\", \"\\\\\\\\\")\n  string = string:gsub(\"\\\"\", \"\\\\\\\"\")\n  return \"\\\"\" .. string .. \"\\\"\"\nen","completion":""}
{"prompt":"-- Format ISNI id by inserting space after every 4 chars.\nlocal function format_isni(st)\n  if st and #st > 4 then\n    local out = ''\n    for i = 1, #st do\n      out = out .. st:sub(i, i)\n      if i % 4 == 0 then\n        out = out .. ' '\n      end\n    end\n    return out:gsub('%s*$', '')\n  else\n    return st\n  end\nen","completion":""}
{"prompt":"-- Multiply components by scalar\nlocal function scalar_multiply(scalar, vect)\n    local result = {}\n    for k, v in pairs(vect) do\n        result[k] = v * scalar\n    end\n    return result\nen","completion":""}
{"prompt":"-- Return the fiscal quarter.\n-- Note: the reporting period being passed should already be in \"federal fiscal format\",\n-- where period 1 = Oct. and period 12 = Sept.\nlocal function get_fiscal_quarter(fiscal_reporting_period)\n    if fiscal_reporting_period >= 3 then\n        return math.ceil(fiscal_reporting_period \/ 3)\n    else\n        return 1\n    end\nen","completion":""}
{"prompt":"-- Takes com.some.thing.Class and returns Class.\nlocal function get_class_identifier(qualified_name)\n  return qualified_name:match(\"([^%.]*)$\")\nen","completion":""}
{"prompt":"-- Function used for **plurality**, **two rounds**, **instant runoff**, **condorcet** and **borda** voting methods.\n-- *Prototype*:\n-- * **ranked** (*dict*) : keys are the electors, values are lists of candidates sorted by preferences\n-- * **turns** (*int*) : current turn (decreasing value)\n-- * **return** (*int*) : winning candidate\n-- *Notes*:\n-- * **N_rounds()** is recursive, the final return type differs from the others, while there are remaining turns\n-- *Algorithm*:\n-- ```\n-- if turns = 0 then\n-- return the winner\n-- else\n-- results <- sorted dictionary\n-- \/\/ keys are the candidates and values are the number of voters for\n-- \/\/ whom this candidate is the favourite\n-- if the first candidate as more than half of the votes then\n-- return the winner\n-- else\n-- ranked <- dictionary\n-- \/\/ keys are the electors, values are lists of candidates\n-- \/\/ sorted by preferences, last candidate is removed\n-- return N_rounds(ranked, turns - 1)\n-- ```\nlocal function N_rounds(ranked, turns)\n\t-- we are in the last round\n\tif turns == 0 then\n\t\tlocal candidates = {}\n\t\tfor k, v in pairs(ranked) do\n\t\t\ttable.insert(candidates, v[1])\n\t\tend\n\t\treturn majority(candidates)\n\tend\n\t-- we are not in the last round\n\t-- let's check if the first candidate has more than half of the votes\n\tlocal first = ranked[next(ranked)]\n\tif #first > (#ranked \/ 2) then\n\t\treturn first[1]\n\tend\n\t-- else, we'll remove the last element of each value\n\tfor k, v in pairs(ranked) do\n\t\ttable.remove(v, #v)\n\tend\n\t-- and we'll call the function again\n\treturn N_rounds(ranked, turns - 1)\nen","completion":""}
{"prompt":"-- Capitalizes first character of the String\nlocal function capitalize(str)\n\treturn str:sub(1,1):upper()..str:sub(2):lower()\nen","completion":""}
{"prompt":"-- Try to get an attribute from an object.\n-- Example: {% if block|getattr:\"editable,True\" %}\n-- Beware that the default is always a string, if you want this\n-- to return False, pass an empty second argument:\n-- {% if block|getattr:\"editable,\" %}\n-- Source: http:\/\/djangosnippets.org\/snippets\/38\/\nlocal function getattr(obj, args)\n  if not obj then return \"\" end\n  local arg = args:split(\",\")\n  local att = arg[1]\n  local default = arg[2]\n  if not att then return \"\" end\n  local val = obj._meta:get_attribute(obj, att)\n  if val == nil and default ~= nil then\n    val = default\n  end\n  return val\nen","completion":""}
{"prompt":"-- Function that can be passed to use_algorithm_on_dictionary. Returns a results tuple containing a null-translation\n-- (0, 0, 0) and mse values (0, 0, 0) ((x,y,z), (mse_x, mse_y, mse_z))\nlocal function rate(reference_pointcloud, aligned_pointcloud, dummy_arg)\n    -- Ignore dummy_arg.\n    return { {0,0,0}, {0,0,0} }\nen","completion":""}
{"prompt":"-- Examples:\n-- >>> strip_scheme(\"https:\/\/www.conda.io\")\n-- 'www.conda.io'\n-- >>> strip_scheme(\"s3:\/\/some.bucket\/plus\/a\/path.ext\")\n-- 'some.bucket\/plus\/a\/path.ext'\nlocal function strip_scheme(url)\n    return url:gsub(\"^%w+:\/\/\", \"\")\nen","completion":""}
{"prompt":"-- Convert byte value to megabyte\nlocal function byte_to_megabyte(byte)\n    return (byte \/ 1024 \/ 1024)\nen","completion":""}
{"prompt":"-- Returns: x converted to centigrade\n-- The value returned has type float.\n-- Parameter x: the temperature in fahrenheit\n-- Precondition: x is a float\nlocal function to_centigrade(x)\n  return (x - 32.0) * 5.0 \/ 9.0\nen","completion":""}
{"prompt":"-- Reformat command line inputs.\n-- Args:\n-- start_prefix        str       Prefix of start files.\n-- traj_prefix         str       Prefix of trajectory files.\n-- info_prefix         str       Prefix of info file.\n-- language            str       language for plot annotations\n-- Returns:\n-- prefix_dict         dict      The various prefixes are stored in this dict.\n-- language            str       language for plot annotations after mapping. \"en\" or \"de\"\nlocal function interpret_options(start_prefix, traj_prefix, info_name, language)\n  local prefix_dict = {}\n  if start_prefix ~= \"\" then\n    prefix_dict[\"start\"] = start_prefix\n  end\n  if traj_prefix ~= \"\" then\n    prefix_dict[\"traj\"] = traj_prefix\n  end\n  if info_name ~= \"\" then\n    prefix_dict[\"info\"] = info_name\n  end\n  if language ~= \"\" then\n    if language == \"en\" or language == \"de\" then\n      prefix_dict[\"language\"] = language\n    else\n      print(\"Plotter language must be 'en' or 'de'\")\n      os.exit()\n    end\n  end\n  -- TODO: add more prefix options.\n  return prefix_dict\nen","completion":""}
{"prompt":"-- Calculate relative humidity as the ratio of actual vapour pressure\n-- to saturation vapour pressure at the same temperature.\n-- See Allen et al (1998), page 67 for details.\n-- :param avp: Actual vapour pressure [units do not matter so long as they\n-- are the same as for *svp*]. Can be estimated using functions whose\n-- name begins with 'avp_from'.\n-- :param svp: Saturated vapour pressure [units do not matter so long as they\n-- are the same as for *avp*]. Can be estimated using ``svp_from_t()``.\n-- :return: Relative humidity [%].\n-- :rtype: float\nlocal function rh_from_avp_svp(avp, svp)\n  return 100.0 * avp \/ svp\nen","completion":""}
{"prompt":"-- Convert value to number whenever possible, return same value\n-- otherwise.\n-- >>> typedvalue('3')\n-- 3\n-- >>> typedvalue('3.0')\n-- 3.0\n-- >>> typedvalue('foobar')\n-- 'foobar'\nlocal function typedvalue(value)\n  local number = tonumber(value)\n  if number ~= nil then\n    return number\n  else\n    return value\n  end\nen","completion":""}
{"prompt":"-- Count the number of bit 1 in the binary representation of non-negative number s\nlocal function count_bits(s)\n    local c = 0\n    while s > 0 do\n        c = c + s % 2\n        s = s \/\/ 2\n    end\n    return c\nen","completion":""}
{"prompt":"-- This function reverses the order of bytes in the provided string.\n-- Each byte is represented by two characters which are reversed as well.\nlocal function reverse_bytes(hex_string)\n  local reversed = \"\"\n  for i=1,string.len(hex_string),2 do\n    reversed = reversed .. string.sub(hex_string, i+1, i+1) .. string.sub(hex_string, i, i)\n  end\n  return reversed\nen","completion":""}
{"prompt":"-- Helper function that converts a number to a 0 padded hex string\n-- >>> to_hex_string(5, 4)\n-- '0005'\n-- >>> to_hex_string(16)\n-- '10'\n-- >>> to_hex_string(20, 4)\n-- '0014'\n-- >>> to_hex_string(255)\n-- 'FF'\n-- >>> to_hex_string([255, 255])\n-- 'FFFF'\n-- >>> to_hex_string([1, 1])\n-- '0101'\n-- >>> to_hex_string([0, 0, 0])\n-- '000000'\n-- >>> to_hex_string(0, 4)\n-- '0000'\nlocal function to_hex_string(num, minDigits)\n    if type(num) == 'number' then\n        minDigits = minDigits or 2\n        return string.format('%0' .. minDigits .. 'X', num)\n    elseif type(num) == 'table' then\n        local concat = \"\"\n        for i, v in ipairs(num) do\n            concat = concat .. to_hex_string(v)\n        end\n        return concat\n    end\n    return nil\nen","completion":""}
{"prompt":"-- Convert the given Home Assistant light level (0-255) to GE (0-100).\nlocal function to_ge_level(level)\n    return math.floor(math.min(math.max(level \/ 2.55, 0), 100) + 0.5)\nen","completion":""}
{"prompt":"-- Calculates combinations by integer division.\n-- Preferred method for small combinations, but slow on larger ones.\n-- Note: no error checking (expects to be called through combinations())\nlocal function combinations_exact(n, k)\n  local r = 1\n  for i = 1, k do\n    r = r * (n - k + i) \/\/ i\n  end\n  return r\nen","completion":""}
{"prompt":"-- Returns a percentage-formatted string for a value, e.g. 0.9234 becomes 92.34%\nlocal function percentage_string(val)\n    return string.format(\"%.2f\", 100 * val) .. \"%\"\nen","completion":""}
{"prompt":"-- Converts from dB to magnitute ratio\n-- Parameters\n-- ----------\n-- x - Input in dB\n-- Returns\n-- -------\n-- m - magnitude ratio\nlocal function db2mag(x)\n   local b = 10.0^(x\/20.0)\n   return b\nen","completion":""}
{"prompt":"-- Resize the size according to the imagenet training ratio.\nlocal function resize_by_ratio(size)\n  return math.floor(size \/ 0.875)\nen","completion":""}
{"prompt":"-- Takes an array of key=value formatted Strings\n-- and returns a dict\nlocal function kv_array_to_dict(kv_pairs)\n   local dict = {}\n   if kv_pairs == nil or #kv_pairs == 0 then return dict end\n   for _, kv_pair in ipairs(kv_pairs) do\n      local key, value = kv_pair:match(\"^([^=]+)=(.*)$\")\n      if key ~= nil and value ~= nil then\n         dict[key] = value\n      end\n   end\n   return dict\nen","completion":""}
{"prompt":"-- Collapse whitespace and middle-truncate if needed.\nlocal function _normalize_sql(sql, maxlen)\n  if maxlen then\n    local i = string.find(sql, \"\\n\", 1, true)\n    if i then\n      local len = #sql\n      local j = i\n      for k = i + 1, len do\n        if sql:sub(k, k) == \"\\n\" then\n          j = k\n        end\n      end\n      sql = sql:sub(1, j - 1)\n      if len - j > maxlen then\n        local k = j + maxlen \/ 2\n        sql = sql .. \" [...] \" .. sql:sub(k, k)\n      end\n    end\n  end\n  return string.gsub(string.gsub(sql, \"%s+\", \" \"), \"%s+$\", \"\")\nen","completion":""}
{"prompt":"-- Sets navitem class based on submenu state\n-- Args:\n-- is_open (bool): Is submenu open\n-- Returns:\n-- str: Submenu css className\nlocal function set_navitem_class(is_open)\n  if is_open then\n    return \"open\"\n  else\n    return \"\"\n  end\nen","completion":""}
{"prompt":"-- Get the abbreviation of label name:\n-- 'take (an object) from (a person)' -> 'take ... from ...'\nlocal function abbrev(name)\n  return name:gsub('%(.+%)', '...')\nen","completion":""}
{"prompt":"-- Format a range of years into a string.\n-- Parameters\n-- ----------\n-- min_year : `intr`\n-- Low end of the range (inclusive).\n-- max_year : `intr`\n-- High end of the range (inclusive).\n-- Returns\n-- -------\n-- text : `str`\n-- Formatted year range.\nlocal function format_year_range(min_year, max_year)\n  local str = \"\"\n  if min_year == max_year then\n    str = str .. min_year .. \"\"\n  else\n    str = str .. min_year .. \"-\" .. max_year\n  end\n  return str\nen","completion":""}
{"prompt":"-- Place all searchers are one vertex\n-- :param m : number of searchers\n-- :param v : integer or list\nlocal function searchers_start_together(m, v)\n  local vertices = {}\n  if v == nil then v = 1 end\n  if type(v) == 'number' then v = {v, v} end\n  for k=1, m do\n    vertices[k] = v[1]\n  end\n  return vertices\nen","completion":""}
{"prompt":"-- Perform all tests.\nlocal function task_test()\n  print(\"Testing...\")\n  local result = os.execute(test_file_name)\n  os.exit(result)\nen","completion":""}
{"prompt":"-- Makes sure `elements` is returned as a list, whether `elements` is a single item, already a list, or a tuple.\n-- Args:\n-- elements (Optional[any]): The inputs as single item, list, or tuple to be converted into a list\/tuple.\n-- If None, returns empty list\/tuple.\n-- to_tuple (bool): Whether to use tuple (instead of list).\n-- Returns:\n-- Union[list,tuple]: All given elements in a list\/tuple depending on `to_tuple`'s value. If elements is None,\n-- returns an empty list\/tuple.\nlocal function force_list(elements, to_tuple)\n    if elements == nil then\n        if to_tuple then\n            return {}\n        else\n            return {}\n        end\n    end\n    if to_tuple then\n        if type(elements) == \"table\" then\n            return elements\n        else\n            return {elements}\n        end\n    else\n        if type(elements) == \"table\" then\n            return elements\n        else\n            return {elements}\n        end\n    end\nen","completion":""}
{"prompt":"-- Strip the quotes and unescape a string inside single quotes.\nlocal function unescape_single_quotes(origin)\n    if origin:sub(1, 1) == \"'\" and origin:sub(-1) == \"'\" then\n        origin = origin:sub(2, -2):gsub(\"''\", \"'\")\n    end\n    return origin\nen","completion":""}
{"prompt":"-- Detect and build the table titles tuple from ORM object, currently only support SQLAlchemy.\n-- .. versionadded:: 1.4.0\nlocal function get_table_titles(data, primary_key, primary_key_title)\n    local title_tuple = {}\n    if data and type(data) == 'table' then\n        if data.__class and data.__class.__name == \"SQLAlchemyObject\" then\n            -- get the columns from the data object\n            local table_columns = data.columns\n            if table_columns then\n                if type(table_columns) == 'table' then\n                    -- loop through the data object columns\n                    for _, column in ipairs(table_columns) do\n                        -- only accept column with type of string or text\n                        if column.type.python_type == 'text' or column.type.python_type == 'string' then\n                            -- create the title_tuple\n                            local column_name = column.name\n                            -- if the primary_key is not set, then use the first column name as the primary_key\n                            if not primary_key then\n                                primary_key = column_name\n                                primary_key_title = column_name\n                            end\n                            -- if the column name is the primary_key, then use the primary_key_title\n                            if column_name == primary_key then\n                                title_tuple[#title_tuple + 1] = primary_key_title\n                            else\n                                title_tuple[#title_tuple + 1] = column_name\n                            end\n                        end\n                    end\n                end\n            end\n        end\n    end\n    return title_tuple, primary_key, primary_key_title\nen","completion":""}
{"prompt":"-- Escapes strings for SQL insert statements\nlocal function escape_apostrophes(input_str)\n  return string.gsub(input_str, \"'\", \"\\\\'\")\nen","completion":""}
